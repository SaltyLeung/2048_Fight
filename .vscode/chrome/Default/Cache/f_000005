(function outer(modules, cache, entry) {
  var previousRequire = "function" == typeof require && require;
  function newRequire(name, jumped) {
    var module = cache[name];
    if (!module) {
      var moduleData = modules[name];
      if (!moduleData) {
        var currentRequire = "function" == typeof require && require;
        if (!jumped && currentRequire) return currentRequire(name, true);
        if (previousRequire) return previousRequire(name, true);
        var err = new Error("Cannot find module '" + name + "'");
        err.code = "MODULE_NOT_FOUND";
        throw err;
      }
      var exports = {};
      module = cache[name] = {
        exports: exports
      };
      moduleData[0]((function(x) {
        return newRequire(moduleData[1][x] || x);
      }), module, exports);
    }
    return module.exports;
  }
  for (var i = 0; i < entry.length; i++) newRequire(entry[i]);
  return newRequire;
})({
  1: [ (function(require, module, exports) {
    cc._LogInfos = cc._LogInfos || {};
    var engineVersion;
    engineVersion = "1.8.1";
    window["CocosEngine"] = cc.ENGINE_VERSION = engineVersion;
    cc._renderContext = null;
    cc._supportRender = false;
    cc._canvas = null;
    cc.container = null;
    cc._gameDiv = null;
    require("./cocos2d/core/utils");
    require("./cocos2d/core/platform/CCSys");
    var _engineInitCalled = false, _engineLoadedCallback = null;
    cc._engineLoaded = false;
    function _determineRenderType(config) {
      var CONFIG_KEY = cc.game.CONFIG_KEY, userRenderMode = parseInt(config[CONFIG_KEY.renderMode]) || 0;
      (isNaN(userRenderMode) || userRenderMode > 2 || userRenderMode < 0) && (config[CONFIG_KEY.renderMode] = 0);
      cc._renderType = cc.game.RENDER_TYPE_CANVAS;
      cc._supportRender = false;
      if (0 === userRenderMode) {
        if (cc.sys.capabilities["opengl"]) {
          cc._renderType = cc.game.RENDER_TYPE_WEBGL;
          cc._supportRender = true;
        } else if (cc.sys.capabilities["canvas"]) {
          cc._renderType = cc.game.RENDER_TYPE_CANVAS;
          cc._supportRender = true;
        }
      } else if (1 === userRenderMode && cc.sys.capabilities["canvas"]) {
        cc._renderType = cc.game.RENDER_TYPE_CANVAS;
        cc._supportRender = true;
      } else if (2 === userRenderMode && cc.sys.capabilities["opengl"]) {
        cc._renderType = cc.game.RENDER_TYPE_WEBGL;
        cc._supportRender = true;
      }
    }
    function _afterEngineLoaded() {
      cc._engineLoaded = true;
      false;
      console.log(cc.ENGINE_VERSION);
      _engineLoadedCallback && _engineLoadedCallback();
    }
    function _windowLoaded() {
      window.removeEventListener("load", _windowLoaded, false);
      _afterEngineLoaded();
    }
    cc.initEngine = function(config, cb) {
      if (_engineInitCalled) {
        var previousCallback = _engineLoadedCallback;
        _engineLoadedCallback = function() {
          previousCallback && previousCallback();
          cb && cb();
        };
        return;
      }
      _engineLoadedCallback = cb;
      !cc.game.config && config ? cc.game.config = config : cc.game.config || cc.game._loadConfig();
      config = cc.game.config;
      _determineRenderType(config);
      document.body ? _afterEngineLoaded() : window.addEventListener("load", _windowLoaded, false);
      _engineInitCalled = true;
    };
  }), {
    "./cocos2d/core/platform/CCSys": 184,
    "./cocos2d/core/utils": 224
  } ],
  2: [ (function(require, module, exports) {
    var logList;
    var Enum = require("./cocos2d/core/platform/CCEnum");
    cc.DebugMode = Enum({
      NONE: 0,
      INFO: 1,
      WARN: 2,
      ERROR: 3,
      INFO_FOR_WEB_PAGE: 4,
      WARN_FOR_WEB_PAGE: 5,
      ERROR_FOR_WEB_PAGE: 6
    });
    cc._initDebugSetting = function(mode) {
      cc.log = cc.logID = cc.warn = cc.warnID = cc.error = cc.errorID = cc._throw = cc.assert = cc.assertID = function() {};
      if (mode === cc.DebugMode.NONE) return;
      if (true, mode > cc.DebugMode.ERROR) (function() {
        function logToWebPage(msg) {
          if (!cc._canvas) return;
          if (!logList) {
            var logDiv = document.createElement("Div");
            logDiv.setAttribute("id", "logInfoDiv");
            logDiv.setAttribute("width", "200");
            logDiv.setAttribute("height", cc._canvas.height);
            var logDivStyle = logDiv.style;
            logDivStyle.zIndex = "99999";
            logDivStyle.position = "absolute";
            logDivStyle.top = logDivStyle.left = "0";
            logList = document.createElement("textarea");
            logList.setAttribute("rows", "20");
            logList.setAttribute("cols", "30");
            logList.setAttribute("disabled", "true");
            var logListStyle = logList.style;
            logListStyle.backgroundColor = "transparent";
            logListStyle.borderBottom = "1px solid #cccccc";
            logListStyle.borderTopWidth = logListStyle.borderLeftWidth = logListStyle.borderRightWidth = "0px";
            logListStyle.borderTopStyle = logListStyle.borderLeftStyle = logListStyle.borderRightStyle = "none";
            logListStyle.padding = "0px";
            logListStyle.margin = 0;
            logDiv.appendChild(logList);
            cc._canvas.parentNode.appendChild(logDiv);
          }
          logList.value = logList.value + msg + "\r\n";
          logList.scrollTop = logList.scrollHeight;
        }
        cc.error = function() {
          logToWebPage("ERROR :  " + cc.js.formatStr.apply(null, arguments));
        };
        cc.assert = function(cond, msg) {
          "use strict";
          if (!cond && msg) {
            msg = cc.js.formatStr.apply(null, cc.js.shiftArguments.apply(null, arguments));
            logToWebPage("ASSERT: " + msg);
          }
        };
        mode !== cc.DebugMode.ERROR_FOR_WEB_PAGE && (cc.warn = function() {
          logToWebPage("WARN :  " + cc.js.formatStr.apply(null, arguments));
        });
        mode === cc.DebugMode.INFO_FOR_WEB_PAGE && (cc.log = cc.info = function() {
          logToWebPage(cc.js.formatStr.apply(null, arguments));
        });
      })(); else if (console && console.log.apply) {
        console.error || (console.error = console.log);
        console.warn || (console.warn = console.log);
        false;
        console.error.bind ? cc.error = console.error.bind(console) : cc.error = function() {
          return console.error.apply(console, arguments);
        };
        cc.assert = function(cond, msg) {
          if (!cond) {
            msg && (msg = cc.js.formatStr.apply(null, cc.js.shiftArguments.apply(null, arguments)));
            true;
            debugger;
            false;
            throw new Error(msg);
          }
        };
      }
      if (mode !== cc.DebugMode.ERROR) {
        false;
        console.warn.bind ? cc.warn = console.warn.bind(console) : cc.warn = function() {
          return console.warn.apply(console, arguments);
        };
      }
      false;
      if (mode === cc.DebugMode.INFO) {
        false;
        console.log.bind ? cc.log = console.log.bind(console) : cc.log = function() {
          return console.log.apply(console, arguments);
        };
        false;
        cc.info = function() {
          (console.info || console.log).apply(console, arguments);
        };
      }
      cc.warnID = genLogFunc(cc.warn, "Warning");
      cc.errorID = genLogFunc(cc.error, "Error");
      cc.logID = genLogFunc(cc.log, "Log");
      var assertFailed = genLogFunc((function() {
        var argsArr = [ false ];
        for (var i = 0; i < arguments.length; ++i) argsArr.push(arguments[i]);
        cc.assert.apply(null, argsArr);
      }), "Assert");
      cc.assertID = function(cond) {
        "use strict";
        if (cond) return;
        assertFailed.apply(null, cc.js.shiftArguments.apply(null, arguments));
      };
    };
    cc._throw = function(error) {
      var stack = error.stack;
      stack ? cc.error(stack) : cc.error(error);
    };
    var errorMapUrl = "https://github.com/cocos-creator/engine/blob/master/EngineErrorMap.md";
    function genLogFunc(func, type) {
      return function(id) {
        "use strict";
        if (1 === arguments.length) {
          func(cc._LogInfos[id]);
          return;
        }
        var msg;
        true;
        var argsArr = cc.js.shiftArguments.apply(null, arguments);
        func.apply(cc, [ cc._LogInfos[id] ].concat(argsArr));
      };
    }
  }), {
    "./cocos2d/core/platform/CCEnum": 177
  } ],
  3: [ (function(require, module, exports) {
    true;
    var logs = {
      "1000": "cc.ActionManager.addAction(): action must be non-null",
      "1001": "cocos2d: removeAction: Target not found",
      "1002": "cc.ActionManager.removeActionByTag(): an invalid tag",
      "1003": "cc.ActionManager.removeActionByTag(): target must be non-null",
      "1004": "cc.ActionManager.getActionByTag(): an invalid tag",
      "1005": "cocos2d : getActionByTag(tag = %s): Action not found",
      "1006": "[Action step]. override me",
      "1007": "[Action update]. override me",
      "1008": "cocos2d: FiniteTimeAction#reverse: Implement me",
      "1009": "cc.EaseElastic.reverse(): it should be overridden in subclass.",
      "1010": "cc.IntervalAction: reverse not implemented.",
      "1011": "cc.ActionInterval.setAmplitudeRate(): it should be overridden in subclass.",
      "1012": "cc.ActionInterval.getAmplitudeRate(): it should be overridden in subclass.",
      "1013": "The speed parameter error",
      "1014": "The repeat parameter error",
      "1015": "parameters should not be ending with null in Javascript",
      "1016": "cc.RotateTo.reverse(): it should be overridden in subclass.",
      "1017": "cc.GridAction.getGrid(): it should be overridden in subclass.",
      "1018": "Grid size must be (1,1)",
      "1019": "Failed to construct, Sequence construction needs two or more actions",
      "1020": "Failed to construct, Spawn construction needs two or more actions",
      "1100": "Expected 'data' dict, but not found. Config file: %s",
      "1101": "Please load the resource first : %s",
      "1200": "cocos2d: Director: Error in gettimeofday",
      "1201": "cocos2d: Director: unrecognized projection",
      "1202": "cocos2d: Director: unrecognized projection",
      "1203": "cocos2d: Director: Error in gettimeofday",
      "1204": "running scene should not null",
      "1205": "the scene should not null",
      "1206": "loadScene: The scene index to load (%s) is out of range.",
      "1207": "loadScene: Unknown name type to load: '%s'",
      "1208": "loadScene: Failed to load scene '%s' because '%s' is already loading",
      "1209": "loadScene: Can not load the scene '%s' because it was not in the build settings before playing.",
      "1210": "Failed to preload '%s', %s",
      "1211": "loadScene: The scene index to load (%s) is out of range.",
      "1212": "loadScene: Unknown name type to load: '%s'",
      "1213": "loadScene: Failed to load scene '%s' because '%s' is already loading",
      "1214": "loadScene: Can not load the scene '%s' because it was not in the build settings before playing.",
      "1215": "Failed to preload '%s', %s",
      "1300": "element type is wrong!",
      "1400": "'%s' is deprecated, please use '%s' instead.",
      "1401": "The first argument should be the destination object",
      "1402": "The 'visible' property of %s is deprecated, use 'enabled' instead please.",
      "1403": "Sorry, cc.audioEngine.willPlayMusic is removed.",
      "1404": "cc.spriteFrameCache is removed, please use cc.loader to load and cache sprite frames of atlas format.",
      "1405": "The '%s' will be removed in v2.0, please use '%s' instead. 😰",
      "1500": "cc.Scheduler#schedule: Callback already scheduled. Updating interval from:%s to %s",
      "1501": "cc.Scheduler#scheduleCallbackForTarget(): callback_fn should be non-null.",
      "1502": "cc.Scheduler#scheduleCallbackForTarget(): target should be non-null.",
      "1503": "cc.Scheduler#pauseTarget():target should be non-null",
      "1504": "cc.Scheduler#resumeTarget():target should be non-null",
      "1505": "cc.Scheduler#isTargetPaused():target should be non-null",
      "1506": "warning: you CANNOT change update priority in scheduled function",
      "1507": "cc.Scheduler#scheduleSelector: Selector already scheduled. Updating interval from: %.4f to %.4f",
      "1508": "Argument callback must not be empty",
      "1509": "Argument target must be non-nullptr",
      "1510": "cc.Scheduler: Illegal target which doesn't have uuid or instanceId",
      "1511": "cc.Scheduler: pause state of the scheduled task doesn't match the element pause state in Scheduler, the given paused state will be ignored",
      "1600": "getZOrder is deprecated. Please use getLocalZOrder instead.",
      "1601": "setZOrder is deprecated. Please use setLocalZOrder instead.",
      "1602": "RotationX != RotationY. Don't know which one to return",
      "1603": "ScaleX != ScaleY. Don't know which one to return",
      "1604": "An Node can't be added as a child of itself.",
      "1605": "child already added. It can't be added again",
      "1606": "child must be non-null",
      "1607": "removeFromParentAndCleanup is deprecated. Use removeFromParent instead",
      "1608": "boundingBox is deprecated. Use getBoundingBox instead",
      "1609": "argument tag is an invalid tag",
      "1610": "cocos2d: removeChildByTag(tag = %s): child not found!",
      "1611": "removeAllChildrenWithCleanup is deprecated. Use removeAllChildren instead",
      "1612": "cc.Node.stopActionBy(): argument tag an invalid tag",
      "1613": "cc.Node.getActionByTag(): argument tag is an invalid tag",
      "1614": "resumeSchedulerAndActions is deprecated, please use resume instead.",
      "1615": "pauseSchedulerAndActions is deprecated, please use pause instead.",
      "1616": "Unknown callback function",
      "1617": "child must be non-null",
      "1618": "cc.Node.runAction(): action must be non-null",
      "1619": "callback function must be non-null",
      "1620": "interval must be positive",
      "1621": "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.",
      "1622": "_ccsg.Node._requestDirtyFlag: failed to satisfy the request, key (%s) for flag have already been taken",
      "1623": "Set '%s' to normal node (not persist root node).",
      "1624": "Replacing with the same sgNode",
      "1625": "The replacement sgNode should not contain any child.",
      "1626": "Should not set alpha via 'color', set 'opacity' please.",
      "1627": "Not support for asynchronous creating node in SG",
      "1628": "Renderer error: Size of the cc._RendererInSG._sgNode must be zero",
      "1629": "The node '%s' has a component inherited from 'cc._RendererInSG'",
      "1630": "JSB environment is not support invoke node.runAction before the 'cc._RendererInSG' component enabled.",
      "1631": "Please use runAction in the method 'start' instead.",
      "1632": "Node name can not include '/'.",
      "1633": "Internal error, should not remove unknown node from parent.",
      "1634": "addChild: The child to add must be instance of cc.Node, not %s.",
      "1635": "reorderChild: this child is not in children list",
      "1700": "cc.AtlasNode.updateAtlasValues(): Shall be overridden in subclasses",
      "1701": "",
      "1702": "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.",
      "1703": "The new text must be String",
      "1800": "cc._EventListenerKeyboard.checkAvailable(): Invalid EventListenerKeyboard!",
      "1801": "cc._EventListenerTouchOneByOne.checkAvailable(): Invalid EventListenerTouchOneByOne!",
      "1802": "cc._EventListenerTouchAllAtOnce.checkAvailable(): Invalid EventListenerTouchAllAtOnce!",
      "1803": "cc._EventListenerAcceleration.checkAvailable(): _onAccelerationEvent must be non-nil",
      "1900": "Invalid parameter.",
      "2000": "Don't call this method if the event is for touch.",
      "2100": "parameters should not be ending with null in Javascript",
      "2101": "Invalid index in MultiplexLayer switchTo message",
      "2102": "Invalid index in MultiplexLayer switchTo message",
      "2103": "cc.Layer.addLayer(): layer should be non-null",
      "2200": "Resolution not valid",
      "2201": "should set resolutionPolicy",
      "2300": "The touches is more than MAX_TOUCHES, nUnusedIndex = %s",
      "2400": "WebGL error %s",
      "2401": "Too many graphics vertices generated, only 65536 vertices support.",
      "2500": "cocos2d: cc.SpriteFrameAnimationCache: No animations were found in provided dictionary.",
      "2501": "cc.SpriteFrameAnimationCache. Invalid animation format",
      "2502": "cc.SpriteFrameAnimationCache.addAnimations(): File could not be found",
      "2503": "cocos2d: cc.SpriteFrameAnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
      "2504": "cocos2d: cc.SpriteFrameAnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
      "2505": "cocos2d: cc.SpriteFrameAnimationCache: None of the frames for animation '%s' were found in the cc.SpriteFrameCache. Animation is not being added to the Animation Cache.",
      "2506": "cocos2d: cc.SpriteFrameAnimationCache: An animation in your dictionary refers to a frame which is not in the cc.SpriteFrameCache. Some or all of the frames for the animation '%s' may be missing.",
      "2507": "cocos2d: CCAnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
      "2508": "cocos2d: cc.SpriteFrameAnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
      "2509": "cc.SpriteFrameAnimationCache.addAnimations(): Invalid texture file name",
      "2600": "cc.Sprite.reorderChild(): this child is not in children list",
      "2601": "cc.Sprite.setIgnoreAnchorPointForPosition(): it is invalid in cc.Sprite when using SpriteBatchNode",
      "2602": "cc.Sprite.setDisplayFrameWithAnimationName(): Frame not found",
      "2603": "cc.Sprite.setDisplayFrameWithAnimationName(): Invalid frame index",
      "2604": "setDisplayFrame is deprecated, please use setSpriteFrame instead.",
      "2605": "cc.Sprite._updateBlendFunc(): _updateBlendFunc doesn't work when the sprite is rendered using a cc.CCSpriteBatchNode",
      "2606": "cc.Sprite.initWithSpriteFrame(): spriteFrame should be non-null",
      "2608": "initWithSpriteFrameName is deprecated and can not provide correct functionality",
      "2609": "cc.Sprite.initWithFile(): filename should be non-null",
      "2610": "cc.Sprite.setDisplayFrameWithAnimationName(): animationName must be non-null",
      "2611": "cc.Sprite.reorderChild(): child should be non-null",
      "2612": "cc.Sprite.addChild(): cc.Sprite only supports cc.Sprites as children when using cc.SpriteBatchNode",
      "2613": "cc.Sprite.addChild(): cc.Sprite only supports a sprite using same texture as children when using cc.SpriteBatchNode",
      "2614": "cc.Sprite.addChild(): child should be non-null",
      "2615": "cc.Sprite.texture setter: Batched sprites should use the same texture as the batchnode",
      "2616": "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
      "2617": "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
      "2618": "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
      "2619": "cc.SpriteBatchNode.addChild(): cc.Sprite is not using the same texture",
      "2620": "Sprite.initWithTexture(): Argument must be non-nil ",
      "2621": "Invalid spriteFrameName",
      "2622": "Invalid argument: cc.Sprite.texture setter expects a CCTexture2D.",
      "2623": "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
      "2624": "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null",
      "2625": "too many tiles, only 16384 tiles will be show",
      "2626": "Unrecognized fill type in bar fill",
      "2627": "Can not generate quad",
      "2728": "%s does not exist",
      "2700": "cc.SpriteBatchNode.addQuadFromSprite(): SpriteBatchNode only supports cc.Sprites as children",
      "2701": "cocos2d: CCSpriteBatchNode: resizing TextureAtlas capacity from %s to %s.",
      "2702": "cocos2d: WARNING: Not enough memory to resize the atlas",
      "2703": "cc.SpriteBatchNode.addChild(): Child doesn't belong to Sprite",
      "2704": "cc.SpriteBatchNode.addChild(): sprite batch node should contain the child",
      "2705": "cc.SpriteBatchNode.addQuadFromSprite(): child should be non-null",
      "2706": "cc.SpriteBatchNode.addChild(): child should be non-null",
      "2707": "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
      "2708": "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
      "2709": "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
      "2710": "Sprite.initWithTexture(): Argument must be non-nil ",
      "2711": "cc.Sprite.addChild(): child should be non-null",
      "2712": "Invalid spriteFrameName",
      "2713": "Invalid argument: cc.Sprite texture setter expects a CCTexture2D.",
      "2714": "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
      "2715": "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null",
      "2716": "cc.SpriteBatchNode.addChild(): child should be non-null",
      "2800": "cocos2d: WARNING: originalWidth/Height not found on the cc.SpriteFrame. AnchorPoint won't work as expected. Regenrate the .plist",
      "2801": "cocos2d: WARNING: an alias with name %s already exists",
      "2802": "cocos2d: WARNING: Sprite frame: %s has already been added by another source, please fix name conflit",
      "2803": "cocos2d: cc.SpriteFrameCahce: Frame %s not found",
      "2804": "Please load the resource first : %s",
      "2805": "cc.SpriteFrameCache.addSpriteFrames(): plist should be non-null",
      "2806": "Argument must be non-nil",
      "2900": "cocos2d: Could not open file: %s",
      "2901": "cc.TextureAtlas.insertQuad(): invalid totalQuads",
      "2902": "cc.TextureAtlas.initWithTexture():texture should be non-null",
      "2903": "cc.TextureAtlas.updateQuad(): quad should be non-null",
      "2904": "cc.TextureAtlas.updateQuad(): Invalid index",
      "2905": "cc.TextureAtlas.insertQuad(): Invalid index",
      "2906": "cc.TextureAtlas.insertQuad(): Invalid index + amount",
      "2907": "cc.TextureAtlas.insertQuadFromIndex(): Invalid newIndex",
      "2908": "cc.TextureAtlas.insertQuadFromIndex(): Invalid fromIndex",
      "2909": "cc.TextureAtlas.removeQuadAtIndex(): Invalid index",
      "2910": "cc.TextureAtlas.removeQuadsAtIndex(): index + amount out of bounds",
      "2911": "cc.TextureAtlas.moveQuadsFromIndex(): move is out of bounds",
      "2912": "cc.TextureAtlas.moveQuadsFromIndex(): Invalid newIndex",
      "2913": "cc.TextureAtlas.moveQuadsFromIndex(): Invalid oldIndex",
      "3000": "TextureCache:addPVRTCImage does not support on HTML5",
      "3001": "TextureCache:addPVRTCImage does not support on HTML5",
      "3002": "textureForKey is deprecated. Please use getTextureForKey instead.",
      "3003": "addPVRImage does not support on HTML5",
      "3004": "cocos2d: Couldn't add UIImage in TextureCache",
      "3005": "cocos2d: '%s' id=%s %s x %s",
      "3006": "cocos2d: '%s' id= HTMLCanvasElement %s x %s",
      "3007": "cocos2d: TextureCache dumpDebugInfo: %s textures, HTMLCanvasElement for %s KB (%s MB)",
      "3008": "cc.Texture.addUIImage(): image should be non-null",
      "3009": "TextureCache: url should be non-null",
      "3100": "initWithETCFile does not support on HTML5",
      "3101": "initWithPVRFile does not support on HTML5",
      "3102": "initWithPVRTCData does not support on HTML5",
      "3103": "cc.Texture.addImage(): path should be non-null",
      "3104": "cocos2d: cc.Texture2D. Can't create Texture. UIImage is nil",
      "3105": "cocos2d: WARNING: Image (%s x %s) is bigger than the supported %s x %s",
      "3106": "initWithString isn't supported on cocos2d-html5",
      "3107": "initWithETCFile does not support on HTML5",
      "3108": "initWithPVRFile does not support on HTML5",
      "3109": "initWithPVRTCData does not support on HTML5",
      "3110": "bitsPerPixelForFormat: %s, cannot give useful result, it's a illegal pixel format",
      "3111": "cocos2d: cc.Texture2D: Using RGB565 texture since image has no alpha",
      "3112": "cc.Texture.addImage(): path should be non-null",
      "3113": "NSInternalInconsistencyException",
      "3114": "SpriteFrame: Failed to load sprite texture '%s'",
      "3115": "Frame Grabber: could not attach texture to framebuffer",
      "3116": "WebGLRenderingContext.CLAMP_TO_EDGE should be used in NPOT textures",
      "3117": "Mimpap texture only works in POT textures",
      "3300": "Rect width exceeds maximum margin: %s",
      "3400": "Rect height exceeds maximum margin: %s",
      "3500": "0 priority is forbidden for fixed priority since it's used for scene graph based priority.",
      "3501": "Invalid listener type!",
      "3502": "Can't set fixed priority with scene graph based listener.",
      "3503": "Invalid parameters.",
      "3504": "listener must be a cc.EventListener object when adding a fixed priority listener",
      "3505": "The listener has been registered, please don't register it again.",
      "3506": "Unsupported listener target.",
      "3507": "Invalid scene graph priority!",
      "3508": "If program goes here, there should be event in dispatch.",
      "3509": "_inDispatch should be 1 here.",
      "3510": "%s's scene graph node not contains in the parent's children",
      "3600": "cc.Class will automatically call super constructor of %s, you should not call it manually.",
      "3601": "The editor property 'playOnFocus' should be used with 'executeInEditMode' in class '%s'",
      "3602": "Unknown editor property '%s' in class '%s'.",
      "3603": "Use 'cc.Float' or 'cc.Integer' instead of 'cc.Number' please. 😂",
      "3604": "Can only indicate one type attribute for %s.",
      "3605": "The default value of %s is not instance of %s.",
      "3606": "No needs to indicate the '%s' attribute for %s, which its default value is type of %s.",
      "3607": "The default value of %s must be an empty string.",
      "3608": "The type of %s must be cc.String, not String.",
      "3609": "The type of %s must be cc.Boolean, not Boolean.",
      "3610": "The type of %s must be cc.Float or cc.Integer, not Number.",
      "3611": "Can not indicate the '%s' attribute for %s, which its default value is type of %s.",
      "3612": "%s Just set the default value to 'new %s()' and it will be handled properly.",
      "3613": "'No need to specify the '%s' attribute for the getter of '%s.%s', every getter is actually non-serialized.",
      "3615": "Each script can have at most one Component.",
      "3616": "Should not specify class name %s for Component which defines in project.",
      "3617": "ctor of CCClass '%s' should not accept any arguments.",
      "3618": "ctor of '%s' can not be another CCClass",
      "3619": "ctor of '%s' must be function type",
      "3620": "this._super declared in '%s.%s' but no super method defined",
      "3621": "Unknown type of %s.%s, maybe you want is '%s'.",
      "3622": "Unknown type of %s.%s, property should be defined in 'properties' or 'ctor'",
      "3623": "Can not use 'editor' attribute, '%s' not inherits from Components.",
      "3624": "'%s' overwrote '%s' but '%s' is defined as 'false' so the super method will not be called. You can set '%s' to null to disable this warning.",
      "3625": "[isChildClassOf] superclass should be function type, not",
      "3626": "Can't remove '%s' because '%s' depends on it.",
      "3627": "Should not add renderer component (%s) to a Canvas node.",
      "3628": "Should not add %s to a node which size is already used by its other component.",
      "3629": "attribute must be type object",
      "3630": "RawType is only available for Assets",
      "3631": "RawType name cannot contain uppercase",
      "3632": "Each asset cannot have more than one RawType",
      "3633": "Properties function of '%s' should return an object!",
      "3634": "Disallow to use '.' in property name",
      "3635": "Default array must be empty, set default value of %s.%s to [], and initialize in 'onLoad' or 'ctor' please. (just like 'this.%s = [...];')",
      "3636": "Can not set default value to non-empty object, unless the object derived from cc.ValueType and overwrite the 'clone' function. Set default value of %s.%s to null or {}, and initialize in 'onLoad' or 'ctor' please. (just like 'this.%s = {foo: bar};')",
      "3637": "Can not declare %s.%s, it is already defined in the prototype of %s",
      "3638": "'%s': the getter of '%s' is already defined!",
      "3640": "'%s': the setter of '%s' is already defined!",
      "3641": "Can not construct %s because it contains object property.",
      "3642": "Cannot define %s.%s because static member name can not be '%s'.",
      "3643": "Can not define a member called 'constructor' in the class '%s', please use 'ctor' instead.",
      "3644": "Please define 'type' parameter of %s.%s as the actual constructor.",
      "3645": "Please define 'type' parameter of %s.%s as the constructor of %s.",
      "3646": "Unknown 'type' parameter of %s.%s：%s",
      "3647": "The length of range array must be equal or greater than 2",
      "3648": "Can not declare %s.%s method, it is already defined in the properties of %s.",
      "3649": "CCClass %s have conflict between its ctor and __ctor__.",
      "3650": 'No need to specifiy "%s" attribute for "%s" property in "%s" class.',
      "3651": 'Can not call `_super` or `prototype.ctor` in ES6 Classes "%s", use `super` instead please.',
      "3652": 'Failed to construct a dummy instance of the "%s" class using `new` behind the scenes. This is for getting default values declared in TypeScript. Please ensure the class will be able to construct during script\'s initialization. %s',
      "3653": 'Please do not specifiy "default" attribute in decorator of "%s" property in "%s" class.\n  Default value must be initialized at their declaration: 😂\n    // Before:\n    @property({\n      type: cc.Integer\n      default: 0  // <--\n    })\n    value;\n\n    // After:\n    @property({\n      type: cc.Integer\n    })\n    value = 0;    // <--',
      "3654": 'Please specifiy a default value for "%s" property at its declaration: 😂\n    // Before:\n    @property(...)\n    value;\n\n    // After:\n    @property(...)\n    value = 0;',
      "3655": 'Can not specifiy "get" or "set"  attribute in decorator for "%s" property in "%s" class.\n  Please use:\n    @property(...)\n    get %s () {\n      ...\n    }\n    @property\n    set %s (value) {\n      ...\n    }',
      "3700": "internal error: _prefab is undefined",
      "3701": "Failed to load prefab asset for node '%s'",
      "3800": "The target can not be made persist because it's invalid or it doesn't have _id property.",
      "3801": "The node can not be made persist because it's not under root node.",
      "3802": "The node can not be made persist because it's not in current scene.",
      "3803": "The target can not be made persist because it's not a cc.Node or it doesn't have _id property.",
      "3804": "getComponent: Type must be non-nil",
      "3805": "Can't add component '%s' because %s already contains the same component.",
      "3806": "Can't add component '%s' to %s because it conflicts with the existing '%s' derived component.",
      "3807": "addComponent: Failed to get class '%s'",
      "3808": "addComponent: Should not add component ('%s') when the scripts are still loading.",
      "3809": "addComponent: The component to add must be a constructor",
      "3810": "addComponent: The component to add must be child class of cc.Component",
      "3811": "_addComponentAt: The component to add must be a constructor",
      "3812": "_addComponentAt: Index out of range",
      "3813": "removeComponent: Component must be non-nil",
      "3814": "Argument must be non-nil",
      "3815": "Component not owned by this entity",
      "3816": "Node '%s' is already activating or deactivating.",
      "3817": "Sorry, the component of '%s' which with an index of %s is corrupted! It has been removed.",
      "3818": "Failed to read or parse project.json",
      "3819": "Warning: target element is not a DIV or CANVAS",
      "3900": "Invalid clip to add",
      "3901": "Invalid clip to remove",
      "3902": "clip is defaultClip, set force to true to force remove clip and animation state",
      "3903": "animation state is playing, set force to true to force stop and remove clip and animation state",
      "3904": "motion path of target [%s] in prop [%s] frame [%s] is not valid",
      "3905": "sprite frames must be an Array.",
      "3906": "Can't find easing type [%s]",
      "3907": "animator not added or already removed",
      "3908": "animation not added or already removed",
      "3909": "[animate] keyFrames must be non-nil",
      "3910": "[animate] ratio should >= 0!",
      "3911": "[animate] ratio should in the order of smallest to largest!",
      "4000": "Sorry, the cc.Font has been modified from Raw Asset to Asset. Please load the font asset before using.",
      "4001": "_ccsg.Label._initBMFontWithString(): Impossible to create font. Please check file",
      "4002": "_ccsg.Label._initBMFontWithString(): re-init is no longer supported",
      "4003": "Label font size can't be shirnked less than 0!",
      "4004": "force notify all fonts loaded!",
      "4005": "cc.LabelAtlas.initWithString(): Unsupported version. Upgrade cocos2d version",
      "4006": "cc.LabelAtlas._updateAtlasValues(): Invalid String length",
      "4007": "cc.LabelBMFont.initWithString(): re-init is no longer supported",
      "4008": "cc.LabelBMFont.initWithString(): Impossible to create font. Please check file",
      "4009": "cocos2d: LabelBMFont: character not found %s",
      "4010": "cc.LabelBMFont.setFntFile() : Impossible to create font. Please check file",
      "4011": "Property spriteFrame of Font '%s' is invalid. Using system font instead.",
      "4012": "The texture of Font '%s' must be already loaded on JSB. Using system font instead.",
      "4013": "Sorry, lineHeight of system font not supported on JSB.",
      "4100": "Property padding is deprecated, please use paddingLeft, paddingRight, paddingTop and paddingBottom instead",
      "4200": "MaskType: IMAGE_STENCIL only support WebGL mode.",
      "4201": "The alphaThreshold invalid in Canvas Mode.",
      "4202": "The inverted invalid in Canvas Mode.",
      "4300": "can not found the %s page.",
      "4400": "Invalid RichText img tag! The sprite frame name can't be found in the ImageAtlas!",
      "4600": "Script attached to '%s' is missing or invalid.",
      "4700": "The dom control is not created!",
      "4800": "unknown asset type %s",
      "4901": "loadRes: should not specify the extname in %s %s",
      "4902": "No need to release non-cached asset.",
      "4903": "Can not get class '%s'",
      "4904": "%s does not exist",
      "4905": "%s load error, must be json file",
      "4906": "Can't find the parser : %s",
      "4907": "%s is armature. please use:",
      "4908": "    ccs.armatureDataManager.addArmatureFileInfoAsync(%s);",
      "4909": "    var armature = new ccs.Armature('name');",
      "4910": "Can't find the parser : %s",
      "4911": "register parser error",
      "4912": "Can't find the parser : %s",
      "4913": "Group versions haven't been loaded, you can also set group data with 'cc.LoaderLayer.groups'",
      "4914": "Resources url '%s' does not exist.",
      "4915": "Pack indices and data do not match in size",
      "4916": "Failed to download package for %s",
      "4917": "cc.LabelBMFont._parseCommonArguments(): page can't be larger than supported",
      "4918": "cc.LabelBMFont._parseCommonArguments(): only supports 1 page",
      "4919": "cc.LabelBMFont._parseImageFileName() : file could not be found",
      "4920": "Sorry, you shouldn't use id as item identity any more, please use url or uuid instead, the current id is being set as url: (%s)",
      "4921": "Invalid pipe or invalid index provided!",
      "4922": "The pipe to be inserted is already in the pipeline!",
      "5000": "object already destroyed",
      "5001": "object not yet destroyed",
      "5100": "Not a plist file!",
      "5200": "Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option",
      "5201": "browser don't support web audio",
      "5300": "Type of target to deserialize not matched with data: target is %s, data is %s",
      "5301": "Can not find script '%s'",
      "5302": "Can not find class '%s'",
      "5400": "'%s' is deprecated, use '%s' instead please.",
      "5401": "'%s' is deprecated, use '%s' instead please.",
      "5402": "cc.js.addon called on non-object: ",
      "5403": "cc.js.mixin: arguments must be type object: ",
      "5404": "The base class to extend from must be non-nil",
      "5405": "The class to extend must be non-nil",
      "5406": "Class should be extended before assigning any prototype members.",
      "5500": "'notify' can't work with 'get/set' !",
      "5501": "'notify' must work with 'default' !",
      "5502": "Invalid url of %s.%s",
      "5503": "The 'url' attribute of '%s.%s' is undefined when loading script.",
      "5504": "The 'url' type of '%s.%s' must be child class of cc.RawAsset.",
      "5505": "The 'url' type of '%s.%s' must not be child class of cc.Asset, otherwise you should use 'type: %s' instead.",
      "5506": "Can not specify 'type' attribute for '%s.%s', because its 'url' is already defined.",
      "5507": "The 'default' attribute of '%s.%s' must be an array",
      "5508": "Invalid type of %s.%s",
      "5509": "The 'type' attribute of '%s.%s' must be child class of cc.Asset, otherwise you should use 'url: %s' instead",
      "5510": "The 'type' attribute of '%s.%s' can not be 'Number', use 'Float' or 'Integer' instead please.",
      "5511": "The 'type' attribute of '%s.%s' is undefined when loading script",
      "5512": "Can not serialize '%s.%s' because the specified type is anonymous, please provide a class name or set the 'serializable' attribute of '%s.%s' to 'false'.",
      "5513": "The 'default' value of '%s.%s' should not be used with a 'get' function.",
      "5514": "The 'default' value of '%s.%s' should not be used with a 'set' function.",
      "5515": "The 'default' value of '%s.%s' can not be an constructor. Set default to null please.",
      "5516": "Property '%s.%s' must define at least one of 'default', 'get' or 'set'.",
      "5517": "'%s.%s' hides inherited property '%s.%s'. To make the current property overwrite that implementation, add the `override: true` attribute please.",
      "5600": "Argument must be non-nil",
      "5601": "Can not get current scene.",
      "5602": "Scene is destroyed",
      "5603": "reference node is destroyed",
      "5700": "no %s or %s on %s",
      "5800": "%s.lerp not yet implemented.",
      "5801": "%s.clone not yet implemented.",
      "5802": "%s.equals not yet implemented.",
      "5900": "MotionStreak only support WebGL mode.",
      "5901": "cc.MotionStreak.getOpacity has not been supported.",
      "5902": "cc.MotionStreak.setOpacity has not been supported.",
      "6000": "Custom should not be false if file is not specified.",
      "6001": "The new %s must not be NaN",
      "6002": "_ccsg.ParticleSystem.addChild() : Can't add a ParticleSystem that uses a different blending function",
      "6003": "cc.ParticleBatchNode.removeChild(): doesn't contain the sprite. Can't remove it",
      "6004": "cc.ParticleBatchNode.reorderChild(): Child doesn't belong to batch",
      "6005": "cc.ParticleBatchNode._increaseAtlasCapacityTo() : WARNING: Not enough memory to resize the atlas",
      "6006": "cocos2d: cc.ParticleBatchNode: resizing TextureAtlas capacity from [%d] to [%d]",
      "6007": "cc.ParticleBatchNode._addChildHelper(): child already added. It can't be added again",
      "6008": "_ccsg.ParticleSystem.initWithFile(): Particles: file not found",
      "6009": "_ccsg.ParticleSystem.initWithDictionary(): Invalid emitterType in config file",
      "6010": "_ccsg.ParticleSystem: error decoding or ungzipping textureImageData",
      "6011": "_ccsg.ParticleSystem: unknown image format with Data",
      "6012": "_ccsg.ParticleSystem.initWithDictionary() : error loading the texture",
      "6013": "Particle system: not enough memory",
      "6014": "Can't change blending functions when the particle is being batched",
      "6015": "_ccsg.ParticleSystem.setDisplayFrame(): QuadParticle only supports SpriteFrames with no offsets",
      "6016": "_ccsg.ParticleSystem._allocMemory(): Memory should not be allocated when not using batchNode",
      "6100": "Not supported file types, Please try use the ccs.load",
      "6200": "Canvas doesn't support mesh slot!",
      "6300": "only cc.DrawNode is accepted as stencil",
      "6301": "Stencil buffer is not enabled.",
      "6302": "Nesting more than %d stencils is not supported. Everything will be drawn without stencil for this node and its children.",
      "6400": "asset.url is not usable in core process",
      "6401": "asset.urls is not usable in core process",
      "6402": "AssetLibrary has already been initialized!",
      "6500": "Widget target must be one of the parent nodes of it",
      "6600": "collider not added or already removed",
      "6601": "Can't find testFunc for (%s, $s).",
      "6700": "Can't init canvas '%s' because it conflicts with the existing '%s', the scene should only have one active canvas at the same time",
      "6701": "Should not add Canvas to a node which already contains a renderer component (%s).",
      "6702": "Should not add Canvas to a node which size is already used by its other component.",
      "6800": "Callback of event must be non-nil",
      "6801": "The message must be provided",
      "6900": "The thing you want to instantiate must be an object",
      "6901": "The thing you want to instantiate is nil",
      "6902": "The thing you want to instantiate is destroyed",
      "6903": "The instantiate method for given asset do not implemented",
      "6904": "Can not instantiate array",
      "6905": "Can not instantiate DOM element",
      "7000": "Failed to init asset's raw path.",
      "7001": "Should not load '%s' from script dynamically, unless it is placed in the 'resources' folder.",
      "7002": "Sorry can not load '%s' because it is not placed in the 'resources' folder.",
      "7003": "Failed to init builtin asset's raw path.",
      "7100": "%s already defined in Enum.",
      "7101": "Sorry, 'cc.Enum' not available on this platform, please report this error here: https://github.com/cocos-creator/engine/issues/new",
      "7200": "Method 'initWithTMXFile' is no effect now, please set property 'tmxAsset' instead.",
      "7201": "Method 'initWithXML' is no effect now, please set property 'tmxAsset' instead.",
      "7202": "Add component TiledLayer into node failed.",
      "7203": "Property 'mapLoaded' is unused now. Please write the logic to the callback 'start'.",
      "7204": "_ccsg.TMXLayer.getTileAt(): TMXLayer: the tiles map has been released",
      "7205": "_ccsg.TMXLayer.getTileGIDAt(): TMXLayer: the tiles map has been released",
      "7206": "_ccsg.TMXLayer.setTileGID(): TMXLayer: the tiles map has been released",
      "7207": "_ccsg.TMXLayer.setTileGID(): invalid gid: %s",
      "7208": "_ccsg.TMXLayer.getTileFlagsAt(): TMXLayer: the tiles map has been released",
      "7209": "_ccsg.TMXLayer.removeTileAt(): TMXLayer: the tiles map has been released",
      "7210": "TMX Hexa zOrder not supported",
      "7211": "TMX invalid value",
      "7212": "_ccsg.TMXTiledMap.initWithTMXFile(): Map not found. Please check the filename.",
      "7213": "_ccsg.TMXTiledMap.initWithXML(): Map not found. Please check the filename.",
      "7214": "propertiesForGID is deprecated. Please use getPropertiesForGID instead.",
      "7215": "cocos2d: Warning: TMX Layer %s has no tiles",
      "7216": "cocos2d: TMXFormat: Unsupported TMX version: %s",
      "7217": "cocos2d: TMXFomat: Unsupported orientation: %s",
      "7218": "cc.TMXMapInfo.parseXMLFile(): unsupported compression method",
      "7219": "cc.TMXMapInfo.parseXMLFile(): Only base64 and/or gzip/zlib maps are supported",
      "7220": "TMX Parser: please load the xml resource first: %s",
      "7300": "The new selected must be number",
      "7301": "The new bake must be boolean",
      "7400": "Failed to set _defaultArmatureIndex for '%s' because its dragonAsset is invalid.",
      "7401": "Failed to set _defaultArmatureIndex for '%s' because the index is out of range.",
      "7402": "Failed to set _animationIndex for '%s' because the index is out of range.",
      "7500": "Failed to set _defaultSkinIndex for '%s' because its skeletonData is invalid.",
      "7501": "Failed to set _defaultSkinIndex for '%s' because the index is out of range.",
      "7502": "Failed to set _animationIndex for '%s' because its skeletonData is invalid.",
      "7503": "Failed to set _animationIndex for '%s' because the index is out of range.",
      "7504": "Can not render dynamic created SkeletonData",
      "7505": "Invalid type of atlasFile, atlas should be registered as raw asset.",
      "7506": "Failed to load spine atlas '$s'",
      "7507": "Please re-import '%s' because its textures is not initialized! (This workflow will be improved in the future.)",
      "7508": "The atlas asset of '%s' is not exists!",
      "7509": "Spine: Animation not found: %s",
      "7510": "Spine: Animation not found: %s",
      "7600": "The context of RenderTexture is invalid.",
      "7700": "On the web is always keep the aspect ratio",
      "7701": "Can't know status",
      "7702": "Video player's duration is not ready to get now!",
      "7800": "Web does not support loading",
      "7801": "Web does not support query history",
      "7802": "Web does not support query history",
      "7803": "The current browser does not support the GoBack",
      "7804": "The current browser does not support the GoForward",
      "7805": "Web does not support zoom",
      "7900": "cc.math.Matrix3.assign(): current matrix equals matIn",
      "7901": "cc.math.mat4Assign(): pOut equals pIn",
      "7902": "cc.mat.Matrix4.assignFrom(): mat4 equals current matrix",
      "7903": "cc.math.Matrix4 equal: pMat1 and pMat2 are same object.",
      "7904": "cc.math.Matrix4.extractPlane: Invalid plane index",
      "7905": "cc.math.mat4Assign(): pOut equals pIn",
      "7906": "cc.mat.Matrix4.assignFrom(): mat4 equals current matrix",
      "7907": "cc.math.Matrix4 equals: pMat1 and pMat2 are same object.",
      "8000": "Can't handle this field type or size",
      "8001": "No bytes requested",
      "8002": "Too many bytes requested",
      "8003": "Missing StripByteCounts!",
      "8100": "cocos2d: ERROR: Failed to compile shader:\n %s",
      "8101": "cocos2d: ERROR: Failed to compile vertex shader",
      "8102": "cocos2d: ERROR: Failed to compile fragment shader",
      "8103": "cc.GLProgram.link(): Cannot link invalid program",
      "8104": "cocos2d: ERROR: Failed to link program: %s",
      "8105": "cocos2d: cc.shaderCache._loadDefaultShader, error shader type",
      "8200": "Please set node's active instead of rigidbody's enabled.",
      "8300": "Should only one camera exists, please check your project.",
      "8301": "Camera does not support Canvas Mode.",
      "8400": "Wrong type arguments, 'filePath' must be a String."
    };
    cc._LogInfos = logs;
  }), {} ],
  4: [ (function(require, module, exports) {
    cc.Action = cc._Class.extend({
      ctor: function() {
        this.originalTarget = null;
        this.target = null;
        this.tag = cc.Action.TAG_INVALID;
      },
      clone: function() {
        var action = new cc.Action();
        action.originalTarget = null;
        action.target = null;
        action.tag = this.tag;
        return action;
      },
      isDone: function() {
        return true;
      },
      startWithTarget: function(target) {
        this.originalTarget = target;
        this.target = target;
      },
      stop: function() {
        this.target = null;
      },
      step: function(dt) {
        cc.logID(1006);
      },
      update: function(dt) {
        cc.logID(1007);
      },
      getTarget: function() {
        return this.target;
      },
      setTarget: function(target) {
        this.target = target;
      },
      getOriginalTarget: function() {
        return this.originalTarget;
      },
      setOriginalTarget: function(originalTarget) {
        this.originalTarget = originalTarget;
      },
      getTag: function() {
        return this.tag;
      },
      setTag: function(tag) {
        this.tag = tag;
      },
      retain: function() {},
      release: function() {}
    });
    cc.Action.TAG_INVALID = -1;
    cc.FiniteTimeAction = cc.Action.extend({
      _duration: 0,
      ctor: function() {
        cc.Action.prototype.ctor.call(this);
        this._duration = 0;
      },
      getDuration: function() {
        return this._duration * (this._timesForRepeat || 1);
      },
      setDuration: function(duration) {
        this._duration = duration;
      },
      reverse: function() {
        cc.logID(1008);
        return null;
      },
      clone: function() {
        return new cc.FiniteTimeAction();
      }
    });
    cc.Speed = cc.Action.extend({
      _speed: 0,
      _innerAction: null,
      ctor: function(action, speed) {
        cc.Action.prototype.ctor.call(this);
        this._speed = 0;
        this._innerAction = null;
        action && this.initWithAction(action, speed);
      },
      getSpeed: function() {
        return this._speed;
      },
      setSpeed: function(speed) {
        this._speed = speed;
      },
      initWithAction: function(action, speed) {
        if (!action) throw new Error("cc.Speed.initWithAction(): action must be non nil");
        this._innerAction = action;
        this._speed = speed;
        return true;
      },
      clone: function() {
        var action = new cc.Speed();
        action.initWithAction(this._innerAction.clone(), this._speed);
        return action;
      },
      startWithTarget: function(target) {
        cc.Action.prototype.startWithTarget.call(this, target);
        this._innerAction.startWithTarget(target);
      },
      stop: function() {
        this._innerAction.stop();
        cc.Action.prototype.stop.call(this);
      },
      step: function(dt) {
        this._innerAction.step(dt * this._speed);
      },
      isDone: function() {
        return this._innerAction.isDone();
      },
      reverse: function() {
        return new cc.Speed(this._innerAction.reverse(), this._speed);
      },
      setInnerAction: function(action) {
        this._innerAction !== action && (this._innerAction = action);
      },
      getInnerAction: function() {
        return this._innerAction;
      }
    });
    cc.speed = function(action, speed) {
      return new cc.Speed(action, speed);
    };
    cc.Follow = cc.Action.extend({
      _followedNode: null,
      _boundarySet: false,
      _boundaryFullyCovered: false,
      _halfScreenSize: null,
      _fullScreenSize: null,
      _worldRect: null,
      leftBoundary: 0,
      rightBoundary: 0,
      topBoundary: 0,
      bottomBoundary: 0,
      ctor: function(followedNode, rect) {
        cc.Action.prototype.ctor.call(this);
        this._followedNode = null;
        this._boundarySet = false;
        this._boundaryFullyCovered = false;
        this._halfScreenSize = null;
        this._fullScreenSize = null;
        this.leftBoundary = 0;
        this.rightBoundary = 0;
        this.topBoundary = 0;
        this.bottomBoundary = 0;
        this._worldRect = cc.rect(0, 0, 0, 0);
        followedNode && (rect ? this.initWithTarget(followedNode, rect) : this.initWithTarget(followedNode));
      },
      clone: function() {
        var action = new cc.Follow();
        var locRect = this._worldRect;
        var rect = new cc.Rect(locRect.x, locRect.y, locRect.width, locRect.height);
        action.initWithTarget(this._followedNode, rect);
        return action;
      },
      isBoundarySet: function() {
        return this._boundarySet;
      },
      setBoudarySet: function(value) {
        this._boundarySet = value;
      },
      initWithTarget: function(followedNode, rect) {
        if (!followedNode) throw new Error("cc.Follow.initWithAction(): followedNode must be non nil");
        var _this = this;
        rect = rect || cc.rect(0, 0, 0, 0);
        _this._followedNode = followedNode;
        _this._worldRect = rect;
        _this._boundarySet = !cc._rectEqualToZero(rect);
        _this._boundaryFullyCovered = false;
        var winSize = cc.director.getWinSize();
        _this._fullScreenSize = cc.p(winSize.width, winSize.height);
        _this._halfScreenSize = cc.pMult(_this._fullScreenSize, .5);
        if (_this._boundarySet) {
          _this.leftBoundary = -(rect.x + rect.width - _this._fullScreenSize.x);
          _this.rightBoundary = -rect.x;
          _this.topBoundary = -rect.y;
          _this.bottomBoundary = -(rect.y + rect.height - _this._fullScreenSize.y);
          _this.rightBoundary < _this.leftBoundary && (_this.rightBoundary = _this.leftBoundary = (_this.leftBoundary + _this.rightBoundary) / 2);
          _this.topBoundary < _this.bottomBoundary && (_this.topBoundary = _this.bottomBoundary = (_this.topBoundary + _this.bottomBoundary) / 2);
          _this.topBoundary === _this.bottomBoundary && _this.leftBoundary === _this.rightBoundary && (_this._boundaryFullyCovered = true);
        }
        return true;
      },
      step: function(dt) {
        var targetWorldPos = this.target.convertToWorldSpaceAR(cc.Vec2.ZERO);
        var followedWorldPos = this._followedNode.convertToWorldSpaceAR(cc.Vec2.ZERO);
        var delta = cc.pSub(targetWorldPos, followedWorldPos);
        var tempPos = this.target.parent.convertToNodeSpaceAR(cc.pAdd(delta, this._halfScreenSize));
        if (this._boundarySet) {
          if (this._boundaryFullyCovered) return;
          this.target.setPosition(cc.clampf(tempPos.x, this.leftBoundary, this.rightBoundary), cc.clampf(tempPos.y, this.bottomBoundary, this.topBoundary));
        } else this.target.setPosition(tempPos.x, tempPos.y);
      },
      isDone: function() {
        return !this._followedNode.isRunning();
      },
      stop: function() {
        this.target = null;
        cc.Action.prototype.stop.call(this);
      }
    });
    cc.follow = function(followedNode, rect) {
      return new cc.Follow(followedNode, rect);
    };
  }), {} ],
  5: [ (function(require, module, exports) {
    cc.cardinalSplineAt = function(p0, p1, p2, p3, tension, t) {
      var t2 = t * t;
      var t3 = t2 * t;
      var s = (1 - tension) / 2;
      var b1 = s * (2 * t2 - t3 - t);
      var b2 = s * (-t3 + t2) + (2 * t3 - 3 * t2 + 1);
      var b3 = s * (t3 - 2 * t2 + t) + (-2 * t3 + 3 * t2);
      var b4 = s * (t3 - t2);
      var x = p0.x * b1 + p1.x * b2 + p2.x * b3 + p3.x * b4;
      var y = p0.y * b1 + p1.y * b2 + p2.y * b3 + p3.y * b4;
      return cc.p(x, y);
    };
    cc.getControlPointAt = function(controlPoints, pos) {
      var p = Math.min(controlPoints.length - 1, Math.max(pos, 0));
      return controlPoints[p];
    };
    function reverseControlPoints(controlPoints) {
      var newArray = [];
      for (var i = controlPoints.length - 1; i >= 0; i--) newArray.push(cc.p(controlPoints[i].x, controlPoints[i].y));
      return newArray;
    }
    function cloneControlPoints(controlPoints) {
      var newArray = [];
      for (var i = 0; i < controlPoints.length; i++) newArray.push(cc.p(controlPoints[i].x, controlPoints[i].y));
      return newArray;
    }
    cc.CardinalSplineTo = cc.ActionInterval.extend({
      _points: null,
      _deltaT: 0,
      _tension: 0,
      _previousPosition: null,
      _accumulatedDiff: null,
      ctor: function(duration, points, tension) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._points = [];
        void 0 !== tension && this.initWithDuration(duration, points, tension);
      },
      initWithDuration: function(duration, points, tension) {
        if (!points || 0 === points.length) throw new Error("Invalid configuration. It must at least have one control point");
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
          this.setPoints(points);
          this._tension = tension;
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.CardinalSplineTo();
        action.initWithDuration(this._duration, cloneControlPoints(this._points), this._tension);
        return action;
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._deltaT = 1 / (this._points.length - 1);
        this._previousPosition = cc.p(this.target.getPositionX(), this.target.getPositionY());
        this._accumulatedDiff = cc.p(0, 0);
      },
      update: function(dt) {
        dt = this._computeEaseTime(dt);
        var p, lt;
        var ps = this._points;
        if (1 === dt) {
          p = ps.length - 1;
          lt = 1;
        } else {
          var locDT = this._deltaT;
          p = 0 | dt / locDT;
          lt = (dt - locDT * p) / locDT;
        }
        var newPos = cc.cardinalSplineAt(cc.getControlPointAt(ps, p - 1), cc.getControlPointAt(ps, p - 0), cc.getControlPointAt(ps, p + 1), cc.getControlPointAt(ps, p + 2), this._tension, lt);
        if (cc.macro.ENABLE_STACKABLE_ACTIONS) {
          var tempX, tempY;
          tempX = this.target.getPositionX() - this._previousPosition.x;
          tempY = this.target.getPositionY() - this._previousPosition.y;
          if (0 !== tempX || 0 !== tempY) {
            var locAccDiff = this._accumulatedDiff;
            tempX = locAccDiff.x + tempX;
            tempY = locAccDiff.y + tempY;
            locAccDiff.x = tempX;
            locAccDiff.y = tempY;
            newPos.x += tempX;
            newPos.y += tempY;
          }
        }
        this.updatePosition(newPos);
      },
      reverse: function() {
        var reversePoints = reverseControlPoints(this._points);
        return cc.cardinalSplineTo(this._duration, reversePoints, this._tension);
      },
      updatePosition: function(newPos) {
        this.target.setPosition(newPos);
        this._previousPosition = newPos;
      },
      getPoints: function() {
        return this._points;
      },
      setPoints: function(points) {
        this._points = points;
      }
    });
    cc.cardinalSplineTo = function(duration, points, tension) {
      return new cc.CardinalSplineTo(duration, points, tension);
    };
    cc.CardinalSplineBy = cc.CardinalSplineTo.extend({
      _startPosition: null,
      ctor: function(duration, points, tension) {
        cc.CardinalSplineTo.prototype.ctor.call(this);
        this._startPosition = cc.p(0, 0);
        void 0 !== tension && this.initWithDuration(duration, points, tension);
      },
      startWithTarget: function(target) {
        cc.CardinalSplineTo.prototype.startWithTarget.call(this, target);
        this._startPosition.x = target.getPositionX();
        this._startPosition.y = target.getPositionY();
      },
      reverse: function() {
        var copyConfig = this._points.slice();
        var current;
        var p = copyConfig[0];
        for (var i = 1; i < copyConfig.length; ++i) {
          current = copyConfig[i];
          copyConfig[i] = cc.pSub(current, p);
          p = current;
        }
        var reverseArray = reverseControlPoints(copyConfig);
        p = reverseArray[reverseArray.length - 1];
        reverseArray.pop();
        p.x = -p.x;
        p.y = -p.y;
        reverseArray.unshift(p);
        for (var i = 1; i < reverseArray.length; ++i) {
          current = reverseArray[i];
          current.x = -current.x;
          current.y = -current.y;
          current.x += p.x;
          current.y += p.y;
          reverseArray[i] = current;
          p = current;
        }
        return cc.cardinalSplineBy(this._duration, reverseArray, this._tension);
      },
      updatePosition: function(newPos) {
        var pos = this._startPosition;
        var posX = newPos.x + pos.x;
        var posY = newPos.y + pos.y;
        this._previousPosition.x = posX;
        this._previousPosition.y = posY;
        this.target.setPosition(posX, posY);
      },
      clone: function() {
        var a = new cc.CardinalSplineBy();
        a.initWithDuration(this._duration, cloneControlPoints(this._points), this._tension);
        return a;
      }
    });
    cc.cardinalSplineBy = function(duration, points, tension) {
      return new cc.CardinalSplineBy(duration, points, tension);
    };
    cc.CatmullRomTo = cc.CardinalSplineTo.extend({
      ctor: function(dt, points) {
        points && this.initWithDuration(dt, points);
      },
      initWithDuration: function(dt, points) {
        return cc.CardinalSplineTo.prototype.initWithDuration.call(this, dt, points, .5);
      },
      clone: function() {
        var action = new cc.CatmullRomTo();
        action.initWithDuration(this._duration, cloneControlPoints(this._points));
        return action;
      }
    });
    cc.catmullRomTo = function(dt, points) {
      return new cc.CatmullRomTo(dt, points);
    };
    cc.CatmullRomBy = cc.CardinalSplineBy.extend({
      ctor: function(dt, points) {
        cc.CardinalSplineBy.prototype.ctor.call(this);
        points && this.initWithDuration(dt, points);
      },
      initWithDuration: function(dt, points) {
        return cc.CardinalSplineTo.prototype.initWithDuration.call(this, dt, points, .5);
      },
      clone: function() {
        var action = new cc.CatmullRomBy();
        action.initWithDuration(this._duration, cloneControlPoints(this._points));
        return action;
      }
    });
    cc.catmullRomBy = function(dt, points) {
      return new cc.CatmullRomBy(dt, points);
    };
  }), {} ],
  6: [ (function(require, module, exports) {
    cc.ActionEase = cc.ActionInterval.extend({
      _inner: null,
      ctor: function(action) {
        cc.ActionInterval.prototype.ctor.call(this);
        action && this.initWithAction(action);
      },
      initWithAction: function(action) {
        if (!action) throw new Error("cc.ActionEase.initWithAction(): action must be non nil");
        if (this.initWithDuration(action.getDuration())) {
          this._inner = action;
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.ActionEase();
        action.initWithAction(this._inner.clone());
        return action;
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._inner.startWithTarget(this.target);
      },
      stop: function() {
        this._inner.stop();
        cc.ActionInterval.prototype.stop.call(this);
      },
      update: function(dt) {
        this._inner.update(dt);
      },
      reverse: function() {
        return new cc.ActionEase(this._inner.reverse());
      },
      getInnerAction: function() {
        return this._inner;
      }
    });
    cc.actionEase = function(action) {
      return new cc.ActionEase(action);
    };
    cc.EaseRateAction = cc.ActionEase.extend({
      _rate: 0,
      ctor: function(action, rate) {
        cc.ActionEase.prototype.ctor.call(this);
        void 0 !== rate && this.initWithAction(action, rate);
      },
      setRate: function(rate) {
        this._rate = rate;
      },
      getRate: function() {
        return this._rate;
      },
      initWithAction: function(action, rate) {
        if (cc.ActionEase.prototype.initWithAction.call(this, action)) {
          this._rate = rate;
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.EaseRateAction();
        action.initWithAction(this._inner.clone(), this._rate);
        return action;
      },
      reverse: function() {
        return new cc.EaseRateAction(this._inner.reverse(), 1 / this._rate);
      }
    });
    cc.easeRateAction = function(action, rate) {
      return new cc.EaseRateAction(action, rate);
    };
    cc.EaseIn = cc.EaseRateAction.extend({
      update: function(dt) {
        this._inner.update(Math.pow(dt, this._rate));
      },
      reverse: function() {
        return new cc.EaseIn(this._inner.reverse(), 1 / this._rate);
      },
      clone: function() {
        var action = new cc.EaseIn();
        action.initWithAction(this._inner.clone(), this._rate);
        return action;
      }
    });
    cc.easeIn = function(rate) {
      return {
        _rate: rate,
        easing: function(dt) {
          return Math.pow(dt, this._rate);
        },
        reverse: function() {
          return cc.easeIn(1 / this._rate);
        }
      };
    };
    cc.EaseOut = cc.EaseRateAction.extend({
      update: function(dt) {
        this._inner.update(Math.pow(dt, 1 / this._rate));
      },
      reverse: function() {
        return new cc.EaseOut(this._inner.reverse(), 1 / this._rate);
      },
      clone: function() {
        var action = new cc.EaseOut();
        action.initWithAction(this._inner.clone(), this._rate);
        return action;
      }
    });
    cc.easeOut = function(rate) {
      return {
        _rate: rate,
        easing: function(dt) {
          return Math.pow(dt, 1 / this._rate);
        },
        reverse: function() {
          return cc.easeOut(1 / this._rate);
        }
      };
    };
    cc.EaseInOut = cc.EaseRateAction.extend({
      update: function(dt) {
        dt *= 2;
        dt < 1 ? this._inner.update(.5 * Math.pow(dt, this._rate)) : this._inner.update(1 - .5 * Math.pow(2 - dt, this._rate));
      },
      clone: function() {
        var action = new cc.EaseInOut();
        action.initWithAction(this._inner.clone(), this._rate);
        return action;
      },
      reverse: function() {
        return new cc.EaseInOut(this._inner.reverse(), this._rate);
      }
    });
    cc.easeInOut = function(rate) {
      return {
        _rate: rate,
        easing: function(dt) {
          dt *= 2;
          return dt < 1 ? .5 * Math.pow(dt, this._rate) : 1 - .5 * Math.pow(2 - dt, this._rate);
        },
        reverse: function() {
          return cc.easeInOut(this._rate);
        }
      };
    };
    cc.EaseExponentialIn = cc.ActionEase.extend({
      update: function(dt) {
        this._inner.update(0 === dt ? 0 : Math.pow(2, 10 * (dt - 1)));
      },
      reverse: function() {
        return new cc.EaseExponentialOut(this._inner.reverse());
      },
      clone: function() {
        var action = new cc.EaseExponentialIn();
        action.initWithAction(this._inner.clone());
        return action;
      }
    });
    cc._easeExponentialInObj = {
      easing: function(dt) {
        return 0 === dt ? 0 : Math.pow(2, 10 * (dt - 1));
      },
      reverse: function() {
        return cc._easeExponentialOutObj;
      }
    };
    cc.easeExponentialIn = function() {
      return cc._easeExponentialInObj;
    };
    cc.EaseExponentialOut = cc.ActionEase.extend({
      update: function(dt) {
        this._inner.update(1 === dt ? 1 : 1 - Math.pow(2, -10 * dt));
      },
      reverse: function() {
        return new cc.EaseExponentialIn(this._inner.reverse());
      },
      clone: function() {
        var action = new cc.EaseExponentialOut();
        action.initWithAction(this._inner.clone());
        return action;
      }
    });
    cc._easeExponentialOutObj = {
      easing: function(dt) {
        return 1 === dt ? 1 : 1 - Math.pow(2, -10 * dt);
      },
      reverse: function() {
        return cc._easeExponentialInObj;
      }
    };
    cc.easeExponentialOut = function() {
      return cc._easeExponentialOutObj;
    };
    cc.EaseExponentialInOut = cc.ActionEase.extend({
      update: function(dt) {
        if (1 !== dt && 0 !== dt) {
          dt *= 2;
          dt = dt < 1 ? .5 * Math.pow(2, 10 * (dt - 1)) : .5 * (2 - Math.pow(2, -10 * (dt - 1)));
        }
        this._inner.update(dt);
      },
      reverse: function() {
        return new cc.EaseExponentialInOut(this._inner.reverse());
      },
      clone: function() {
        var action = new cc.EaseExponentialInOut();
        action.initWithAction(this._inner.clone());
        return action;
      }
    });
    cc._easeExponentialInOutObj = {
      easing: function(dt) {
        if (1 !== dt && 0 !== dt) {
          dt *= 2;
          return dt < 1 ? .5 * Math.pow(2, 10 * (dt - 1)) : .5 * (2 - Math.pow(2, -10 * (dt - 1)));
        }
        return dt;
      },
      reverse: function() {
        return cc._easeExponentialInOutObj;
      }
    };
    cc.easeExponentialInOut = function() {
      return cc._easeExponentialInOutObj;
    };
    cc.EaseSineIn = cc.ActionEase.extend({
      update: function(dt) {
        dt = 0 === dt || 1 === dt ? dt : -1 * Math.cos(dt * Math.PI / 2) + 1;
        this._inner.update(dt);
      },
      reverse: function() {
        return new cc.EaseSineOut(this._inner.reverse());
      },
      clone: function() {
        var action = new cc.EaseSineIn();
        action.initWithAction(this._inner.clone());
        return action;
      }
    });
    cc._easeSineInObj = {
      easing: function(dt) {
        return 0 === dt || 1 === dt ? dt : -1 * Math.cos(dt * Math.PI / 2) + 1;
      },
      reverse: function() {
        return cc._easeSineOutObj;
      }
    };
    cc.easeSineIn = function() {
      return cc._easeSineInObj;
    };
    cc.EaseSineOut = cc.ActionEase.extend({
      update: function(dt) {
        dt = 0 === dt || 1 === dt ? dt : Math.sin(dt * Math.PI / 2);
        this._inner.update(dt);
      },
      reverse: function() {
        return new cc.EaseSineIn(this._inner.reverse());
      },
      clone: function() {
        var action = new cc.EaseSineOut();
        action.initWithAction(this._inner.clone());
        return action;
      }
    });
    cc._easeSineOutObj = {
      easing: function(dt) {
        return 0 === dt || 1 === dt ? dt : Math.sin(dt * Math.PI / 2);
      },
      reverse: function() {
        return cc._easeSineInObj;
      }
    };
    cc.easeSineOut = function() {
      return cc._easeSineOutObj;
    };
    cc.EaseSineInOut = cc.ActionEase.extend({
      update: function(dt) {
        dt = 0 === dt || 1 === dt ? dt : -.5 * (Math.cos(Math.PI * dt) - 1);
        this._inner.update(dt);
      },
      clone: function() {
        var action = new cc.EaseSineInOut();
        action.initWithAction(this._inner.clone());
        return action;
      },
      reverse: function() {
        return new cc.EaseSineInOut(this._inner.reverse());
      }
    });
    cc._easeSineInOutObj = {
      easing: function(dt) {
        return 0 === dt || 1 === dt ? dt : -.5 * (Math.cos(Math.PI * dt) - 1);
      },
      reverse: function() {
        return cc._easeSineInOutObj;
      }
    };
    cc.easeSineInOut = function() {
      return cc._easeSineInOutObj;
    };
    cc.EaseElastic = cc.ActionEase.extend({
      _period: .3,
      ctor: function(action, period) {
        cc.ActionEase.prototype.ctor.call(this);
        action && this.initWithAction(action, period);
      },
      getPeriod: function() {
        return this._period;
      },
      setPeriod: function(period) {
        this._period = period;
      },
      initWithAction: function(action, period) {
        cc.ActionEase.prototype.initWithAction.call(this, action);
        this._period = null == period ? .3 : period;
        return true;
      },
      reverse: function() {
        cc.logID(1009);
        return null;
      },
      clone: function() {
        var action = new cc.EaseElastic();
        action.initWithAction(this._inner.clone(), this._period);
        return action;
      }
    });
    cc.EaseElasticIn = cc.EaseElastic.extend({
      update: function(dt) {
        var newT = 0;
        if (0 === dt || 1 === dt) newT = dt; else {
          var s = this._period / 4;
          dt -= 1;
          newT = -Math.pow(2, 10 * dt) * Math.sin((dt - s) * Math.PI * 2 / this._period);
        }
        this._inner.update(newT);
      },
      reverse: function() {
        return new cc.EaseElasticOut(this._inner.reverse(), this._period);
      },
      clone: function() {
        var action = new cc.EaseElasticIn();
        action.initWithAction(this._inner.clone(), this._period);
        return action;
      }
    });
    cc._easeElasticInObj = {
      easing: function(dt) {
        if (0 === dt || 1 === dt) return dt;
        dt -= 1;
        return -Math.pow(2, 10 * dt) * Math.sin((dt - .075) * Math.PI * 2 / .3);
      },
      reverse: function() {
        return cc._easeElasticOutObj;
      }
    };
    cc.easeElasticIn = function(period) {
      if (period && .3 !== period) return {
        _period: period,
        easing: function(dt) {
          if (0 === dt || 1 === dt) return dt;
          dt -= 1;
          return -Math.pow(2, 10 * dt) * Math.sin((dt - this._period / 4) * Math.PI * 2 / this._period);
        },
        reverse: function() {
          return cc.easeElasticOut(this._period);
        }
      };
      return cc._easeElasticInObj;
    };
    cc.EaseElasticOut = cc.EaseElastic.extend({
      update: function(dt) {
        var newT = 0;
        if (0 === dt || 1 === dt) newT = dt; else {
          var s = this._period / 4;
          newT = Math.pow(2, -10 * dt) * Math.sin((dt - s) * Math.PI * 2 / this._period) + 1;
        }
        this._inner.update(newT);
      },
      reverse: function() {
        return new cc.EaseElasticIn(this._inner.reverse(), this._period);
      },
      clone: function() {
        var action = new cc.EaseElasticOut();
        action.initWithAction(this._inner.clone(), this._period);
        return action;
      }
    });
    cc._easeElasticOutObj = {
      easing: function(dt) {
        return 0 === dt || 1 === dt ? dt : Math.pow(2, -10 * dt) * Math.sin((dt - .075) * Math.PI * 2 / .3) + 1;
      },
      reverse: function() {
        return cc._easeElasticInObj;
      }
    };
    cc.easeElasticOut = function(period) {
      if (period && .3 !== period) return {
        _period: period,
        easing: function(dt) {
          return 0 === dt || 1 === dt ? dt : Math.pow(2, -10 * dt) * Math.sin((dt - this._period / 4) * Math.PI * 2 / this._period) + 1;
        },
        reverse: function() {
          return cc.easeElasticIn(this._period);
        }
      };
      return cc._easeElasticOutObj;
    };
    cc.EaseElasticInOut = cc.EaseElastic.extend({
      update: function(dt) {
        var newT = 0;
        var locPeriod = this._period;
        if (0 === dt || 1 === dt) newT = dt; else {
          dt *= 2;
          locPeriod || (locPeriod = this._period = .3 * 1.5);
          var s = locPeriod / 4;
          dt -= 1;
          newT = dt < 0 ? -.5 * Math.pow(2, 10 * dt) * Math.sin((dt - s) * Math.PI * 2 / locPeriod) : Math.pow(2, -10 * dt) * Math.sin((dt - s) * Math.PI * 2 / locPeriod) * .5 + 1;
        }
        this._inner.update(newT);
      },
      reverse: function() {
        return new cc.EaseElasticInOut(this._inner.reverse(), this._period);
      },
      clone: function() {
        var action = new cc.EaseElasticInOut();
        action.initWithAction(this._inner.clone(), this._period);
        return action;
      }
    });
    cc.easeElasticInOut = function(period) {
      period = period || .3;
      return {
        _period: period,
        easing: function(dt) {
          var newT = 0;
          var locPeriod = this._period;
          if (0 === dt || 1 === dt) newT = dt; else {
            dt *= 2;
            locPeriod || (locPeriod = this._period = .3 * 1.5);
            var s = locPeriod / 4;
            dt -= 1;
            newT = dt < 0 ? -.5 * Math.pow(2, 10 * dt) * Math.sin((dt - s) * Math.PI * 2 / locPeriod) : Math.pow(2, -10 * dt) * Math.sin((dt - s) * Math.PI * 2 / locPeriod) * .5 + 1;
          }
          return newT;
        },
        reverse: function() {
          return cc.easeElasticInOut(this._period);
        }
      };
    };
    cc.EaseBounce = cc.ActionEase.extend({
      bounceTime: function(time1) {
        if (time1 < 1 / 2.75) return 7.5625 * time1 * time1;
        if (time1 < 2 / 2.75) {
          time1 -= 1.5 / 2.75;
          return 7.5625 * time1 * time1 + .75;
        }
        if (time1 < 2.5 / 2.75) {
          time1 -= 2.25 / 2.75;
          return 7.5625 * time1 * time1 + .9375;
        }
        time1 -= 2.625 / 2.75;
        return 7.5625 * time1 * time1 + .984375;
      },
      clone: function() {
        var action = new cc.EaseBounce();
        action.initWithAction(this._inner.clone());
        return action;
      },
      reverse: function() {
        return new cc.EaseBounce(this._inner.reverse());
      }
    });
    cc.EaseBounceIn = cc.EaseBounce.extend({
      update: function(dt) {
        var newT = 1 - this.bounceTime(1 - dt);
        this._inner.update(newT);
      },
      reverse: function() {
        return new cc.EaseBounceOut(this._inner.reverse());
      },
      clone: function() {
        var action = new cc.EaseBounceIn();
        action.initWithAction(this._inner.clone());
        return action;
      }
    });
    cc._bounceTime = function(time1) {
      if (time1 < 1 / 2.75) return 7.5625 * time1 * time1;
      if (time1 < 2 / 2.75) {
        time1 -= 1.5 / 2.75;
        return 7.5625 * time1 * time1 + .75;
      }
      if (time1 < 2.5 / 2.75) {
        time1 -= 2.25 / 2.75;
        return 7.5625 * time1 * time1 + .9375;
      }
      time1 -= 2.625 / 2.75;
      return 7.5625 * time1 * time1 + .984375;
    };
    cc._easeBounceInObj = {
      easing: function(dt) {
        return 1 - cc._bounceTime(1 - dt);
      },
      reverse: function() {
        return cc._easeBounceOutObj;
      }
    };
    cc.easeBounceIn = function() {
      return cc._easeBounceInObj;
    };
    cc.EaseBounceOut = cc.EaseBounce.extend({
      update: function(dt) {
        var newT = this.bounceTime(dt);
        this._inner.update(newT);
      },
      reverse: function() {
        return new cc.EaseBounceIn(this._inner.reverse());
      },
      clone: function() {
        var action = new cc.EaseBounceOut();
        action.initWithAction(this._inner.clone());
        return action;
      }
    });
    cc._easeBounceOutObj = {
      easing: function(dt) {
        return cc._bounceTime(dt);
      },
      reverse: function() {
        return cc._easeBounceInObj;
      }
    };
    cc.easeBounceOut = function() {
      return cc._easeBounceOutObj;
    };
    cc.EaseBounceInOut = cc.EaseBounce.extend({
      update: function(dt) {
        var newT = 0;
        if (dt < .5) {
          dt *= 2;
          newT = .5 * (1 - this.bounceTime(1 - dt));
        } else newT = .5 * this.bounceTime(2 * dt - 1) + .5;
        this._inner.update(newT);
      },
      clone: function() {
        var action = new cc.EaseBounceInOut();
        action.initWithAction(this._inner.clone());
        return action;
      },
      reverse: function() {
        return new cc.EaseBounceInOut(this._inner.reverse());
      }
    });
    cc._easeBounceInOutObj = {
      easing: function(time1) {
        var newT;
        if (time1 < .5) {
          time1 *= 2;
          newT = .5 * (1 - cc._bounceTime(1 - time1));
        } else newT = .5 * cc._bounceTime(2 * time1 - 1) + .5;
        return newT;
      },
      reverse: function() {
        return cc._easeBounceInOutObj;
      }
    };
    cc.easeBounceInOut = function() {
      return cc._easeBounceInOutObj;
    };
    cc.EaseBackIn = cc.ActionEase.extend({
      update: function(dt) {
        var overshoot = 1.70158;
        dt = 0 === dt || 1 === dt ? dt : dt * dt * ((overshoot + 1) * dt - overshoot);
        this._inner.update(dt);
      },
      reverse: function() {
        return new cc.EaseBackOut(this._inner.reverse());
      },
      clone: function() {
        var action = new cc.EaseBackIn();
        action.initWithAction(this._inner.clone());
        return action;
      }
    });
    cc._easeBackInObj = {
      easing: function(time1) {
        var overshoot = 1.70158;
        return 0 === time1 || 1 === time1 ? time1 : time1 * time1 * ((overshoot + 1) * time1 - overshoot);
      },
      reverse: function() {
        return cc._easeBackOutObj;
      }
    };
    cc.easeBackIn = function() {
      return cc._easeBackInObj;
    };
    cc.EaseBackOut = cc.ActionEase.extend({
      update: function(dt) {
        var overshoot = 1.70158;
        dt -= 1;
        this._inner.update(dt * dt * ((overshoot + 1) * dt + overshoot) + 1);
      },
      reverse: function() {
        return new cc.EaseBackIn(this._inner.reverse());
      },
      clone: function() {
        var action = new cc.EaseBackOut();
        action.initWithAction(this._inner.clone());
        return action;
      }
    });
    cc._easeBackOutObj = {
      easing: function(time1) {
        var overshoot = 1.70158;
        time1 -= 1;
        return time1 * time1 * ((overshoot + 1) * time1 + overshoot) + 1;
      },
      reverse: function() {
        return cc._easeBackInObj;
      }
    };
    cc.easeBackOut = function() {
      return cc._easeBackOutObj;
    };
    cc.EaseBackInOut = cc.ActionEase.extend({
      update: function(dt) {
        var overshoot = 2.5949095;
        dt *= 2;
        if (dt < 1) this._inner.update(dt * dt * ((overshoot + 1) * dt - overshoot) / 2); else {
          dt -= 2;
          this._inner.update(dt * dt * ((overshoot + 1) * dt + overshoot) / 2 + 1);
        }
      },
      clone: function() {
        var action = new cc.EaseBackInOut();
        action.initWithAction(this._inner.clone());
        return action;
      },
      reverse: function() {
        return new cc.EaseBackInOut(this._inner.reverse());
      }
    });
    cc._easeBackInOutObj = {
      easing: function(time1) {
        var overshoot = 2.5949095;
        time1 *= 2;
        if (time1 < 1) return time1 * time1 * ((overshoot + 1) * time1 - overshoot) / 2;
        time1 -= 2;
        return time1 * time1 * ((overshoot + 1) * time1 + overshoot) / 2 + 1;
      },
      reverse: function() {
        return cc._easeBackInOutObj;
      }
    };
    cc.easeBackInOut = function() {
      return cc._easeBackInOutObj;
    };
    cc.EaseBezierAction = cc.ActionEase.extend({
      _p0: null,
      _p1: null,
      _p2: null,
      _p3: null,
      ctor: function(action) {
        cc.ActionEase.prototype.ctor.call(this, action);
      },
      _updateTime: function(a, b, c, d, t) {
        return Math.pow(1 - t, 3) * a + 3 * t * Math.pow(1 - t, 2) * b + 3 * Math.pow(t, 2) * (1 - t) * c + Math.pow(t, 3) * d;
      },
      update: function(dt) {
        var t = this._updateTime(this._p0, this._p1, this._p2, this._p3, dt);
        this._inner.update(t);
      },
      clone: function() {
        var action = new cc.EaseBezierAction();
        action.initWithAction(this._inner.clone());
        action.setBezierParamer(this._p0, this._p1, this._p2, this._p3);
        return action;
      },
      reverse: function() {
        var action = new cc.EaseBezierAction(this._inner.reverse());
        action.setBezierParamer(this._p3, this._p2, this._p1, this._p0);
        return action;
      },
      setBezierParamer: function(p0, p1, p2, p3) {
        this._p0 = p0 || 0;
        this._p1 = p1 || 0;
        this._p2 = p2 || 0;
        this._p3 = p3 || 0;
      }
    });
    cc.easeBezierAction = function(p0, p1, p2, p3) {
      return {
        easing: function(time) {
          return cc.EaseBezierAction.prototype._updateTime(p0, p1, p2, p3, time);
        },
        reverse: function() {
          return cc.easeBezierAction(p3, p2, p1, p0);
        }
      };
    };
    cc.EaseQuadraticActionIn = cc.ActionEase.extend({
      _updateTime: function(time) {
        return Math.pow(time, 2);
      },
      update: function(dt) {
        this._inner.update(this._updateTime(dt));
      },
      clone: function() {
        var action = new cc.EaseQuadraticActionIn();
        action.initWithAction(this._inner.clone());
        return action;
      },
      reverse: function() {
        return new cc.EaseQuadraticActionIn(this._inner.reverse());
      }
    });
    cc._easeQuadraticActionIn = {
      easing: cc.EaseQuadraticActionIn.prototype._updateTime,
      reverse: function() {
        return cc._easeQuadraticActionIn;
      }
    };
    cc.easeQuadraticActionIn = function() {
      return cc._easeQuadraticActionIn;
    };
    cc.EaseQuadraticActionOut = cc.ActionEase.extend({
      _updateTime: function(time) {
        return -time * (time - 2);
      },
      update: function(dt) {
        this._inner.update(this._updateTime(dt));
      },
      clone: function() {
        var action = new cc.EaseQuadraticActionOut();
        action.initWithAction();
        return action;
      },
      reverse: function() {
        return new cc.EaseQuadraticActionOut(this._inner.reverse());
      }
    });
    cc._easeQuadraticActionOut = {
      easing: cc.EaseQuadraticActionOut.prototype._updateTime,
      reverse: function() {
        return cc._easeQuadraticActionOut;
      }
    };
    cc.easeQuadraticActionOut = function() {
      return cc._easeQuadraticActionOut;
    };
    cc.EaseQuadraticActionInOut = cc.ActionEase.extend({
      _updateTime: function(time) {
        var resultTime = time;
        time *= 2;
        if (time < 1) resultTime = time * time * .5; else {
          --time;
          resultTime = -.5 * (time * (time - 2) - 1);
        }
        return resultTime;
      },
      update: function(dt) {
        this._inner.update(this._updateTime(dt));
      },
      clone: function() {
        var action = new cc.EaseQuadraticActionInOut();
        action.initWithAction(this._inner.clone());
        return action;
      },
      reverse: function() {
        return new cc.EaseQuadraticActionInOut(this._inner.reverse());
      }
    });
    cc._easeQuadraticActionInOut = {
      easing: cc.EaseQuadraticActionInOut.prototype._updateTime,
      reverse: function() {
        return cc._easeQuadraticActionInOut;
      }
    };
    cc.easeQuadraticActionInOut = function() {
      return cc._easeQuadraticActionInOut;
    };
    cc.EaseQuarticActionIn = cc.ActionEase.extend({
      _updateTime: function(time) {
        return time * time * time * time;
      },
      update: function(dt) {
        this._inner.update(this._updateTime(dt));
      },
      clone: function() {
        var action = new cc.EaseQuarticActionIn();
        action.initWithAction(this._inner.clone());
        return action;
      },
      reverse: function() {
        return new cc.EaseQuarticActionIn(this._inner.reverse());
      }
    });
    cc._easeQuarticActionIn = {
      easing: cc.EaseQuarticActionIn.prototype._updateTime,
      reverse: function() {
        return cc._easeQuarticActionIn;
      }
    };
    cc.easeQuarticActionIn = function() {
      return cc._easeQuarticActionIn;
    };
    cc.EaseQuarticActionOut = cc.ActionEase.extend({
      _updateTime: function(time) {
        time -= 1;
        return -(time * time * time * time - 1);
      },
      update: function(dt) {
        this._inner.update(this._updateTime(dt));
      },
      clone: function() {
        var action = new cc.EaseQuarticActionOut();
        action.initWithAction(this._inner.clone());
        return action;
      },
      reverse: function() {
        return new cc.EaseQuarticActionOut(this._inner.reverse());
      }
    });
    cc._easeQuarticActionOut = {
      easing: cc.EaseQuarticActionOut.prototype._updateTime,
      reverse: function() {
        return cc._easeQuarticActionOut;
      }
    };
    cc.easeQuarticActionOut = function() {
      return cc._easeQuarticActionOut;
    };
    cc.EaseQuarticActionInOut = cc.ActionEase.extend({
      _updateTime: function(time) {
        time *= 2;
        if (time < 1) return .5 * time * time * time * time;
        time -= 2;
        return -.5 * (time * time * time * time - 2);
      },
      update: function(dt) {
        this._inner.update(this._updateTime(dt));
      },
      clone: function() {
        var action = new cc.EaseQuarticActionInOut();
        action.initWithAction(this._inner.clone());
        return action;
      },
      reverse: function() {
        return new cc.EaseQuarticActionInOut(this._inner.reverse());
      }
    });
    cc._easeQuarticActionInOut = {
      easing: cc.EaseQuarticActionInOut.prototype._updateTime,
      reverse: function() {
        return cc._easeQuarticActionInOut;
      }
    };
    cc.easeQuarticActionInOut = function() {
      return cc._easeQuarticActionInOut;
    };
    cc.EaseQuinticActionIn = cc.ActionEase.extend({
      _updateTime: function(time) {
        return time * time * time * time * time;
      },
      update: function(dt) {
        this._inner.update(this._updateTime(dt));
      },
      clone: function() {
        var action = new cc.EaseQuinticActionIn();
        action.initWithAction(this._inner.clone());
        return action;
      },
      reverse: function() {
        return new cc.EaseQuinticActionIn(this._inner.reverse());
      }
    });
    cc._easeQuinticActionIn = {
      easing: cc.EaseQuinticActionIn.prototype._updateTime,
      reverse: function() {
        return cc._easeQuinticActionIn;
      }
    };
    cc.easeQuinticActionIn = function() {
      return cc._easeQuinticActionIn;
    };
    cc.EaseQuinticActionOut = cc.ActionEase.extend({
      _updateTime: function(time) {
        time -= 1;
        return time * time * time * time * time + 1;
      },
      update: function(dt) {
        this._inner.update(this._updateTime(dt));
      },
      clone: function() {
        var action = new cc.EaseQuinticActionOut();
        action.initWithAction(this._inner.clone());
        return action;
      },
      reverse: function() {
        return new cc.EaseQuinticActionOut(this._inner.reverse());
      }
    });
    cc._easeQuinticActionOut = {
      easing: cc.EaseQuinticActionOut.prototype._updateTime,
      reverse: function() {
        return cc._easeQuinticActionOut;
      }
    };
    cc.easeQuinticActionOut = function() {
      return cc._easeQuinticActionOut;
    };
    cc.EaseQuinticActionInOut = cc.ActionEase.extend({
      _updateTime: function(time) {
        time *= 2;
        if (time < 1) return .5 * time * time * time * time * time;
        time -= 2;
        return .5 * (time * time * time * time * time + 2);
      },
      update: function(dt) {
        this._inner.update(this._updateTime(dt));
      },
      clone: function() {
        var action = new cc.EaseQuinticActionInOut();
        action.initWithAction(this._inner.clone());
        return action;
      },
      reverse: function() {
        return new cc.EaseQuinticActionInOut(this._inner.reverse());
      }
    });
    cc._easeQuinticActionInOut = {
      easing: cc.EaseQuinticActionInOut.prototype._updateTime,
      reverse: function() {
        return cc._easeQuinticActionInOut;
      }
    };
    cc.easeQuinticActionInOut = function() {
      return cc._easeQuinticActionInOut;
    };
    cc.EaseCircleActionIn = cc.ActionEase.extend({
      _updateTime: function(time) {
        return -1 * (Math.sqrt(1 - time * time) - 1);
      },
      update: function(dt) {
        this._inner.update(this._updateTime(dt));
      },
      clone: function() {
        var action = new cc.EaseCircleActionIn();
        action.initWithAction(this._inner.clone());
        return action;
      },
      reverse: function() {
        return new cc.EaseCircleActionIn(this._inner.reverse());
      }
    });
    cc._easeCircleActionIn = {
      easing: cc.EaseCircleActionIn.prototype._updateTime,
      reverse: function() {
        return cc._easeCircleActionIn;
      }
    };
    cc.easeCircleActionIn = function() {
      return cc._easeCircleActionIn;
    };
    cc.EaseCircleActionOut = cc.ActionEase.extend({
      _updateTime: function(time) {
        time -= 1;
        return Math.sqrt(1 - time * time);
      },
      update: function(dt) {
        this._inner.update(this._updateTime(dt));
      },
      clone: function() {
        var action = new cc.EaseCircleActionOut();
        action.initWithAction(this._inner.clone());
        return action;
      },
      reverse: function() {
        return new cc.EaseCircleActionOut(this._inner.reverse());
      }
    });
    cc._easeCircleActionOut = {
      easing: cc.EaseCircleActionOut.prototype._updateTime,
      reverse: function() {
        return cc._easeCircleActionOut;
      }
    };
    cc.easeCircleActionOut = function() {
      return cc._easeCircleActionOut;
    };
    cc.EaseCircleActionInOut = cc.ActionEase.extend({
      _updateTime: function(time) {
        time *= 2;
        if (time < 1) return -.5 * (Math.sqrt(1 - time * time) - 1);
        time -= 2;
        return .5 * (Math.sqrt(1 - time * time) + 1);
      },
      update: function(dt) {
        this._inner.update(this._updateTime(dt));
      },
      clone: function() {
        var action = new cc.EaseCircleActionInOut();
        action.initWithAction(this._inner.clone());
        return action;
      },
      reverse: function() {
        return new cc.EaseCircleActionInOut(this._inner.reverse());
      }
    });
    cc._easeCircleActionInOut = {
      easing: cc.EaseCircleActionInOut.prototype._updateTime,
      reverse: function() {
        return cc._easeCircleActionInOut;
      }
    };
    cc.easeCircleActionInOut = function() {
      return cc._easeCircleActionInOut;
    };
    cc.EaseCubicActionIn = cc.ActionEase.extend({
      _updateTime: function(time) {
        return time * time * time;
      },
      update: function(dt) {
        this._inner.update(this._updateTime(dt));
      },
      clone: function() {
        var action = new cc.EaseCubicActionIn();
        action.initWithAction(this._inner.clone());
        return action;
      },
      reverse: function() {
        return new cc.EaseCubicActionIn(this._inner.reverse());
      }
    });
    cc._easeCubicActionIn = {
      easing: cc.EaseCubicActionIn.prototype._updateTime,
      reverse: function() {
        return cc._easeCubicActionIn;
      }
    };
    cc.easeCubicActionIn = function() {
      return cc._easeCubicActionIn;
    };
    cc.EaseCubicActionOut = cc.ActionEase.extend({
      _updateTime: function(time) {
        time -= 1;
        return time * time * time + 1;
      },
      update: function(dt) {
        this._inner.update(this._updateTime(dt));
      },
      clone: function() {
        var action = new cc.EaseCubicActionOut();
        action.initWithAction(this._inner.clone());
        return action;
      },
      reverse: function() {
        return new cc.EaseCubicActionOut(this._inner.reverse());
      }
    });
    cc._easeCubicActionOut = {
      easing: cc.EaseCubicActionOut.prototype._updateTime,
      reverse: function() {
        return cc._easeCubicActionOut;
      }
    };
    cc.easeCubicActionOut = function() {
      return cc._easeCubicActionOut;
    };
    cc.EaseCubicActionInOut = cc.ActionEase.extend({
      _updateTime: function(time) {
        time *= 2;
        if (time < 1) return .5 * time * time * time;
        time -= 2;
        return .5 * (time * time * time + 2);
      },
      update: function(dt) {
        this._inner.update(this._updateTime(dt));
      },
      clone: function() {
        var action = new cc.EaseCubicActionInOut();
        action.initWithAction(this._inner.clone());
        return action;
      },
      reverse: function() {
        return new cc.EaseCubicActionInOut(this._inner.reverse());
      }
    });
    cc._easeCubicActionInOut = {
      easing: cc.EaseCubicActionInOut.prototype._updateTime,
      reverse: function() {
        return cc._easeCubicActionInOut;
      }
    };
    cc.easeCubicActionInOut = function() {
      return cc._easeCubicActionInOut;
    };
  }), {} ],
  7: [ (function(require, module, exports) {
    cc.ActionInstant = cc.FiniteTimeAction.extend({
      isDone: function() {
        return true;
      },
      step: function(dt) {
        this.update(1);
      },
      update: function(dt) {},
      reverse: function() {
        return this.clone();
      },
      clone: function() {
        return new cc.ActionInstant();
      }
    });
    cc.Show = cc.ActionInstant.extend({
      update: function(dt) {
        var _renderComps = this.target.getComponentsInChildren(cc._SGComponent);
        for (var i = 0; i < _renderComps.length; ++i) {
          var render = _renderComps[i];
          render.enabled = true;
        }
      },
      reverse: function() {
        return new cc.Hide();
      },
      clone: function() {
        return new cc.Show();
      }
    });
    cc.show = function() {
      return new cc.Show();
    };
    cc.Hide = cc.ActionInstant.extend({
      update: function(dt) {
        var _renderComps = this.target.getComponentsInChildren(cc._SGComponent);
        for (var i = 0; i < _renderComps.length; ++i) {
          var render = _renderComps[i];
          render.enabled = false;
        }
      },
      reverse: function() {
        return new cc.Show();
      },
      clone: function() {
        return new cc.Hide();
      }
    });
    cc.hide = function() {
      return new cc.Hide();
    };
    cc.ToggleVisibility = cc.ActionInstant.extend({
      update: function(dt) {
        var _renderComps = this.target.getComponentsInChildren(cc._SGComponent);
        for (var i = 0; i < _renderComps.length; ++i) {
          var render = _renderComps[i];
          render.enabled = !render.enabled;
        }
      },
      reverse: function() {
        return new cc.ToggleVisibility();
      },
      clone: function() {
        return new cc.ToggleVisibility();
      }
    });
    cc.toggleVisibility = function() {
      return new cc.ToggleVisibility();
    };
    cc.RemoveSelf = cc.ActionInstant.extend({
      _isNeedCleanUp: true,
      ctor: function(isNeedCleanUp) {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        void 0 !== isNeedCleanUp && this.init(isNeedCleanUp);
      },
      update: function(dt) {
        this.target.removeFromParent(this._isNeedCleanUp);
      },
      init: function(isNeedCleanUp) {
        this._isNeedCleanUp = isNeedCleanUp;
        return true;
      },
      reverse: function() {
        return new cc.RemoveSelf(this._isNeedCleanUp);
      },
      clone: function() {
        return new cc.RemoveSelf(this._isNeedCleanUp);
      }
    });
    cc.removeSelf = function(isNeedCleanUp) {
      return new cc.RemoveSelf(isNeedCleanUp);
    };
    cc.FlipX = cc.ActionInstant.extend({
      _flippedX: false,
      ctor: function(flip) {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._flippedX = false;
        void 0 !== flip && this.initWithFlipX(flip);
      },
      initWithFlipX: function(flip) {
        this._flippedX = flip;
        return true;
      },
      update: function(dt) {
        this.target.scaleX = Math.abs(this.target.scaleX) * (this._flippedX ? -1 : 1);
      },
      reverse: function() {
        return new cc.FlipX(!this._flippedX);
      },
      clone: function() {
        var action = new cc.FlipX();
        action.initWithFlipX(this._flippedX);
        return action;
      }
    });
    cc.flipX = function(flip) {
      return new cc.FlipX(flip);
    };
    cc.FlipY = cc.ActionInstant.extend({
      _flippedY: false,
      ctor: function(flip) {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._flippedY = false;
        void 0 !== flip && this.initWithFlipY(flip);
      },
      initWithFlipY: function(flip) {
        this._flippedY = flip;
        return true;
      },
      update: function(dt) {
        this.target.scaleY = Math.abs(this.target.scaleY) * (this._flippedY ? -1 : 1);
      },
      reverse: function() {
        return new cc.FlipY(!this._flippedY);
      },
      clone: function() {
        var action = new cc.FlipY();
        action.initWithFlipY(this._flippedY);
        return action;
      }
    });
    cc.flipY = function(flip) {
      return new cc.FlipY(flip);
    };
    cc.Place = cc.ActionInstant.extend({
      _x: 0,
      _y: 0,
      ctor: function(pos, y) {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._x = 0;
        this._y = 0;
        if (void 0 !== pos) {
          if (void 0 !== pos.x) {
            y = pos.y;
            pos = pos.x;
          }
          this.initWithPosition(pos, y);
        }
      },
      initWithPosition: function(x, y) {
        this._x = x;
        this._y = y;
        return true;
      },
      update: function(dt) {
        this.target.setPosition(this._x, this._y);
      },
      clone: function() {
        var action = new cc.Place();
        action.initWithPosition(this._x, this._y);
        return action;
      }
    });
    cc.place = function(pos, y) {
      return new cc.Place(pos, y);
    };
    cc.CallFunc = cc.ActionInstant.extend({
      _selectorTarget: null,
      _function: null,
      _data: null,
      ctor: function(selector, selectorTarget, data) {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this.initWithFunction(selector, selectorTarget, data);
      },
      initWithFunction: function(selector, selectorTarget, data) {
        selector && (this._function = selector);
        selectorTarget && (this._selectorTarget = selectorTarget);
        void 0 !== data && (this._data = data);
        return true;
      },
      execute: function() {
        this._function && this._function.call(this._selectorTarget, this.target, this._data);
      },
      update: function(dt) {
        this.execute();
      },
      getTargetCallback: function() {
        return this._selectorTarget;
      },
      setTargetCallback: function(sel) {
        if (sel !== this._selectorTarget) {
          this._selectorTarget && (this._selectorTarget = null);
          this._selectorTarget = sel;
        }
      },
      clone: function() {
        var action = new cc.CallFunc();
        action.initWithFunction(this._function, this._selectorTarget, this._data);
        return action;
      }
    });
    cc.callFunc = function(selector, selectorTarget, data) {
      return new cc.CallFunc(selector, selectorTarget, data);
    };
  }), {} ],
  8: [ (function(require, module, exports) {
    cc.ActionInterval = cc.FiniteTimeAction.extend({
      _elapsed: 0,
      _firstTick: false,
      _easeList: null,
      _timesForRepeat: 1,
      _repeatForever: false,
      _repeatMethod: false,
      _speed: 1,
      _speedMethod: false,
      ctor: function(d) {
        this._speed = 1;
        this._timesForRepeat = 1;
        this._repeatForever = false;
        this.MAX_VALUE = 2;
        this._repeatMethod = false;
        this._speedMethod = false;
        cc.FiniteTimeAction.prototype.ctor.call(this);
        void 0 !== d && this.initWithDuration(d);
      },
      getElapsed: function() {
        return this._elapsed;
      },
      initWithDuration: function(d) {
        this._duration = 0 === d ? cc.macro.FLT_EPSILON : d;
        this._elapsed = 0;
        this._firstTick = true;
        return true;
      },
      isDone: function() {
        return this._elapsed >= this._duration;
      },
      _cloneDecoration: function(action) {
        action._repeatForever = this._repeatForever;
        action._speed = this._speed;
        action._timesForRepeat = this._timesForRepeat;
        action._easeList = this._easeList;
        action._speedMethod = this._speedMethod;
        action._repeatMethod = this._repeatMethod;
      },
      _reverseEaseList: function(action) {
        if (this._easeList) {
          action._easeList = [];
          for (var i = 0; i < this._easeList.length; i++) action._easeList.push(this._easeList[i].reverse());
        }
      },
      clone: function() {
        var action = new cc.ActionInterval(this._duration);
        this._cloneDecoration(action);
        return action;
      },
      easing: function(easeObj) {
        this._easeList ? this._easeList.length = 0 : this._easeList = [];
        for (var i = 0; i < arguments.length; i++) this._easeList.push(arguments[i]);
        return this;
      },
      _computeEaseTime: function(dt) {
        var locList = this._easeList;
        if (!locList || 0 === locList.length) return dt;
        for (var i = 0, n = locList.length; i < n; i++) dt = locList[i].easing(dt);
        return dt;
      },
      step: function(dt) {
        if (this._firstTick) {
          this._firstTick = false;
          this._elapsed = 0;
        } else this._elapsed += dt;
        var t = this._elapsed / (this._duration > 1.192092896e-7 ? this._duration : 1.192092896e-7);
        t = 1 > t ? t : 1;
        this.update(t > 0 ? t : 0);
        if (this._repeatMethod && this._timesForRepeat > 1 && this.isDone()) {
          this._repeatForever || this._timesForRepeat--;
          this.startWithTarget(this.target);
          this.step(this._elapsed - this._duration);
        }
      },
      startWithTarget: function(target) {
        cc.Action.prototype.startWithTarget.call(this, target);
        this._elapsed = 0;
        this._firstTick = true;
      },
      reverse: function() {
        cc.logID(1010);
        return null;
      },
      setAmplitudeRate: function(amp) {
        cc.logID(1011);
      },
      getAmplitudeRate: function() {
        cc.logID(1012);
        return 0;
      },
      speed: function(speed) {
        if (speed <= 0) {
          cc.logID(1013);
          return this;
        }
        this._speedMethod = true;
        this._speed *= speed;
        return this;
      },
      getSpeed: function() {
        return this._speed;
      },
      setSpeed: function(speed) {
        this._speed = speed;
        return this;
      },
      repeat: function(times) {
        times = Math.round(times);
        if (isNaN(times) || times < 1) {
          cc.logID(1014);
          return this;
        }
        this._repeatMethod = true;
        this._timesForRepeat *= times;
        return this;
      },
      repeatForever: function() {
        this._repeatMethod = true;
        this._timesForRepeat = this.MAX_VALUE;
        this._repeatForever = true;
        return this;
      }
    });
    cc.actionInterval = function(d) {
      return new cc.ActionInterval(d);
    };
    cc.Sequence = cc.ActionInterval.extend({
      _actions: null,
      _split: null,
      _last: 0,
      _reversed: false,
      ctor: function(tempArray) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._actions = [];
        var paramArray = tempArray instanceof Array ? tempArray : arguments;
        if (1 === paramArray.length) {
          cc.errorID(1019);
          return;
        }
        var last = paramArray.length - 1;
        last >= 0 && null == paramArray[last] && cc.logID(1015);
        if (last >= 0) {
          var prev = paramArray[0], action1;
          for (var i = 1; i < last; i++) if (paramArray[i]) {
            action1 = prev;
            prev = cc.Sequence._actionOneTwo(action1, paramArray[i]);
          }
          this.initWithTwoActions(prev, paramArray[last]);
        }
      },
      initWithTwoActions: function(actionOne, actionTwo) {
        if (!actionOne || !actionTwo) throw new Error("cc.Sequence.initWithTwoActions(): arguments must all be non nil");
        var d = actionOne._duration + actionTwo._duration;
        this.initWithDuration(d);
        this._actions[0] = actionOne;
        this._actions[1] = actionTwo;
        return true;
      },
      clone: function() {
        var action = new cc.Sequence();
        this._cloneDecoration(action);
        action.initWithTwoActions(this._actions[0].clone(), this._actions[1].clone());
        return action;
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._split = this._actions[0]._duration / this._duration;
        this._last = -1;
      },
      stop: function() {
        -1 !== this._last && this._actions[this._last].stop();
        cc.Action.prototype.stop.call(this);
      },
      update: function(dt) {
        var new_t, found = 0;
        var locSplit = this._split, locActions = this._actions, locLast = this._last, actionFound;
        dt = this._computeEaseTime(dt);
        if (dt < locSplit) {
          new_t = 0 !== locSplit ? dt / locSplit : 1;
          if (0 === found && 1 === locLast && this._reversed) {
            locActions[1].update(0);
            locActions[1].stop();
          }
        } else {
          found = 1;
          new_t = 1 === locSplit ? 1 : (dt - locSplit) / (1 - locSplit);
          if (-1 === locLast) {
            locActions[0].startWithTarget(this.target);
            locActions[0].update(1);
            locActions[0].stop();
          }
          if (0 === locLast) {
            locActions[0].update(1);
            locActions[0].stop();
          }
        }
        actionFound = locActions[found];
        if (locLast === found && actionFound.isDone()) return;
        locLast !== found && actionFound.startWithTarget(this.target);
        new_t *= actionFound._timesForRepeat;
        actionFound.update(new_t > 1 ? new_t % 1 : new_t);
        this._last = found;
      },
      reverse: function() {
        var action = cc.Sequence._actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse());
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        action._reversed = true;
        return action;
      }
    });
    cc.sequence = function(tempArray) {
      var paramArray = tempArray instanceof Array ? tempArray : arguments;
      if (1 === paramArray.length) {
        cc.errorID(1019);
        return null;
      }
      var last = paramArray.length - 1;
      last >= 0 && null == paramArray[last] && cc.logID(1015);
      var result = null;
      if (last >= 0) {
        result = paramArray[0];
        for (var i = 1; i <= last; i++) paramArray[i] && (result = cc.Sequence._actionOneTwo(result, paramArray[i]));
      }
      return result;
    };
    cc.Sequence._actionOneTwo = function(actionOne, actionTwo) {
      var sequence = new cc.Sequence();
      sequence.initWithTwoActions(actionOne, actionTwo);
      return sequence;
    };
    cc.Repeat = cc.ActionInterval.extend({
      _times: 0,
      _total: 0,
      _nextDt: 0,
      _actionInstant: false,
      _innerAction: null,
      ctor: function(action, times) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== times && this.initWithAction(action, times);
      },
      initWithAction: function(action, times) {
        var duration = action._duration * times;
        if (this.initWithDuration(duration)) {
          this._times = times;
          this._innerAction = action;
          if (action instanceof cc.ActionInstant) {
            this._actionInstant = true;
            this._times -= 1;
          }
          this._total = 0;
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.Repeat();
        this._cloneDecoration(action);
        action.initWithAction(this._innerAction.clone(), this._times);
        return action;
      },
      startWithTarget: function(target) {
        this._total = 0;
        this._nextDt = this._innerAction._duration / this._duration;
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._innerAction.startWithTarget(target);
      },
      stop: function() {
        this._innerAction.stop();
        cc.Action.prototype.stop.call(this);
      },
      update: function(dt) {
        dt = this._computeEaseTime(dt);
        var locInnerAction = this._innerAction;
        var locDuration = this._duration;
        var locTimes = this._times;
        var locNextDt = this._nextDt;
        if (dt >= locNextDt) {
          while (dt > locNextDt && this._total < locTimes) {
            locInnerAction.update(1);
            this._total++;
            locInnerAction.stop();
            locInnerAction.startWithTarget(this.target);
            locNextDt += locInnerAction._duration / locDuration;
            this._nextDt = locNextDt;
          }
          if (dt >= 1 && this._total < locTimes) {
            locInnerAction.update(1);
            this._total++;
          }
          this._actionInstant || (this._total === locTimes ? locInnerAction.stop() : locInnerAction.update(dt - (locNextDt - locInnerAction._duration / locDuration)));
        } else locInnerAction.update(dt * locTimes % 1);
      },
      isDone: function() {
        return this._total === this._times;
      },
      reverse: function() {
        var action = new cc.Repeat(this._innerAction.reverse(), this._times);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      },
      setInnerAction: function(action) {
        this._innerAction !== action && (this._innerAction = action);
      },
      getInnerAction: function() {
        return this._innerAction;
      }
    });
    cc.repeat = function(action, times) {
      return new cc.Repeat(action, times);
    };
    cc.RepeatForever = cc.ActionInterval.extend({
      _innerAction: null,
      ctor: function(action) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._innerAction = null;
        action && this.initWithAction(action);
      },
      initWithAction: function(action) {
        if (!action) throw new Error("cc.RepeatForever.initWithAction(): action must be non null");
        this._innerAction = action;
        return true;
      },
      clone: function() {
        var action = new cc.RepeatForever();
        this._cloneDecoration(action);
        action.initWithAction(this._innerAction.clone());
        return action;
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._innerAction.startWithTarget(target);
      },
      step: function(dt) {
        var locInnerAction = this._innerAction;
        locInnerAction.step(dt);
        if (locInnerAction.isDone()) {
          locInnerAction.startWithTarget(this.target);
          locInnerAction.step(locInnerAction.getElapsed() - locInnerAction._duration);
        }
      },
      isDone: function() {
        return false;
      },
      reverse: function() {
        var action = new cc.RepeatForever(this._innerAction.reverse());
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      },
      setInnerAction: function(action) {
        this._innerAction !== action && (this._innerAction = action);
      },
      getInnerAction: function() {
        return this._innerAction;
      }
    });
    cc.repeatForever = function(action) {
      return new cc.RepeatForever(action);
    };
    cc.Spawn = cc.ActionInterval.extend({
      _one: null,
      _two: null,
      ctor: function(tempArray) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._one = null;
        this._two = null;
        var paramArray = tempArray instanceof Array ? tempArray : arguments;
        if (1 === paramArray.length) {
          cc.errorID(1020);
          return;
        }
        var last = paramArray.length - 1;
        last >= 0 && null == paramArray[last] && cc.logID(1015);
        if (last >= 0) {
          var prev = paramArray[0], action1;
          for (var i = 1; i < last; i++) if (paramArray[i]) {
            action1 = prev;
            prev = cc.Spawn._actionOneTwo(action1, paramArray[i]);
          }
          this.initWithTwoActions(prev, paramArray[last]);
        }
      },
      initWithTwoActions: function(action1, action2) {
        if (!action1 || !action2) throw new Error("cc.Spawn.initWithTwoActions(): arguments must all be non null");
        var ret = false;
        var d1 = action1._duration;
        var d2 = action2._duration;
        if (this.initWithDuration(Math.max(d1, d2))) {
          this._one = action1;
          this._two = action2;
          d1 > d2 ? this._two = cc.Sequence._actionOneTwo(action2, cc.delayTime(d1 - d2)) : d1 < d2 && (this._one = cc.Sequence._actionOneTwo(action1, cc.delayTime(d2 - d1)));
          ret = true;
        }
        return ret;
      },
      clone: function() {
        var action = new cc.Spawn();
        this._cloneDecoration(action);
        action.initWithTwoActions(this._one.clone(), this._two.clone());
        return action;
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._one.startWithTarget(target);
        this._two.startWithTarget(target);
      },
      stop: function() {
        this._one.stop();
        this._two.stop();
        cc.Action.prototype.stop.call(this);
      },
      update: function(dt) {
        dt = this._computeEaseTime(dt);
        this._one && this._one.update(dt);
        this._two && this._two.update(dt);
      },
      reverse: function() {
        var action = cc.Spawn._actionOneTwo(this._one.reverse(), this._two.reverse());
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      }
    });
    cc.spawn = function(tempArray) {
      var paramArray = tempArray instanceof Array ? tempArray : arguments;
      if (1 === paramArray.length) {
        cc.errorID(1020);
        return null;
      }
      paramArray.length > 0 && null == paramArray[paramArray.length - 1] && cc.logID(1015);
      var prev = paramArray[0];
      for (var i = 1; i < paramArray.length; i++) null != paramArray[i] && (prev = cc.Spawn._actionOneTwo(prev, paramArray[i]));
      return prev;
    };
    cc.Spawn._actionOneTwo = function(action1, action2) {
      var pSpawn = new cc.Spawn();
      pSpawn.initWithTwoActions(action1, action2);
      return pSpawn;
    };
    cc.RotateTo = cc.ActionInterval.extend({
      _dstAngleX: 0,
      _startAngleX: 0,
      _diffAngleX: 0,
      _dstAngleY: 0,
      _startAngleY: 0,
      _diffAngleY: 0,
      ctor: function(duration, deltaAngleX, deltaAngleY) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== deltaAngleX && this.initWithDuration(duration, deltaAngleX, deltaAngleY);
      },
      initWithDuration: function(duration, deltaAngleX, deltaAngleY) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
          this._dstAngleX = deltaAngleX || 0;
          this._dstAngleY = void 0 !== deltaAngleY ? deltaAngleY : this._dstAngleX;
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.RotateTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._dstAngleX, this._dstAngleY);
        return action;
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        var locStartAngleX = target.rotationX % 360;
        var locDiffAngleX = this._dstAngleX - locStartAngleX;
        locDiffAngleX > 180 && (locDiffAngleX -= 360);
        locDiffAngleX < -180 && (locDiffAngleX += 360);
        this._startAngleX = locStartAngleX;
        this._diffAngleX = locDiffAngleX;
        this._startAngleY = target.rotationY % 360;
        var locDiffAngleY = this._dstAngleY - this._startAngleY;
        locDiffAngleY > 180 && (locDiffAngleY -= 360);
        locDiffAngleY < -180 && (locDiffAngleY += 360);
        this._diffAngleY = locDiffAngleY;
      },
      reverse: function() {
        cc.logID(1016);
      },
      update: function(dt) {
        dt = this._computeEaseTime(dt);
        if (this.target) {
          this.target.rotationX = this._startAngleX + this._diffAngleX * dt;
          this.target.rotationY = this._startAngleY + this._diffAngleY * dt;
        }
      }
    });
    cc.rotateTo = function(duration, deltaAngleX, deltaAngleY) {
      return new cc.RotateTo(duration, deltaAngleX, deltaAngleY);
    };
    cc.RotateBy = cc.ActionInterval.extend({
      _angleX: 0,
      _startAngleX: 0,
      _angleY: 0,
      _startAngleY: 0,
      ctor: function(duration, deltaAngleX, deltaAngleY) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== deltaAngleX && this.initWithDuration(duration, deltaAngleX, deltaAngleY);
      },
      initWithDuration: function(duration, deltaAngleX, deltaAngleY) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
          this._angleX = deltaAngleX || 0;
          this._angleY = void 0 !== deltaAngleY ? deltaAngleY : this._angleX;
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.RotateBy();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._angleX, this._angleY);
        return action;
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._startAngleX = target.rotationX;
        this._startAngleY = target.rotationY;
      },
      update: function(dt) {
        dt = this._computeEaseTime(dt);
        if (this.target) {
          this.target.rotationX = this._startAngleX + this._angleX * dt;
          this.target.rotationY = this._startAngleY + this._angleY * dt;
        }
      },
      reverse: function() {
        var action = new cc.RotateBy(this._duration, -this._angleX, -this._angleY);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      }
    });
    cc.rotateBy = function(duration, deltaAngleX, deltaAngleY) {
      return new cc.RotateBy(duration, deltaAngleX, deltaAngleY);
    };
    cc.MoveBy = cc.ActionInterval.extend({
      _positionDelta: null,
      _startPosition: null,
      _previousPosition: null,
      ctor: function(duration, deltaPos, deltaY) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._positionDelta = cc.p(0, 0);
        this._startPosition = cc.p(0, 0);
        this._previousPosition = cc.p(0, 0);
        void 0 !== deltaPos && this.initWithDuration(duration, deltaPos, deltaY);
      },
      initWithDuration: function(duration, position, y) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
          if (void 0 !== position.x) {
            y = position.y;
            position = position.x;
          }
          this._positionDelta.x = position;
          this._positionDelta.y = y;
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.MoveBy();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._positionDelta);
        return action;
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        var locPosX = target.getPositionX();
        var locPosY = target.getPositionY();
        this._previousPosition.x = locPosX;
        this._previousPosition.y = locPosY;
        this._startPosition.x = locPosX;
        this._startPosition.y = locPosY;
      },
      update: function(dt) {
        dt = this._computeEaseTime(dt);
        if (this.target) {
          var x = this._positionDelta.x * dt;
          var y = this._positionDelta.y * dt;
          var locStartPosition = this._startPosition;
          if (cc.macro.ENABLE_STACKABLE_ACTIONS) {
            var targetX = this.target.getPositionX();
            var targetY = this.target.getPositionY();
            var locPreviousPosition = this._previousPosition;
            locStartPosition.x = locStartPosition.x + targetX - locPreviousPosition.x;
            locStartPosition.y = locStartPosition.y + targetY - locPreviousPosition.y;
            x += locStartPosition.x;
            y += locStartPosition.y;
            locPreviousPosition.x = x;
            locPreviousPosition.y = y;
            this.target.setPosition(x, y);
          } else this.target.setPosition(locStartPosition.x + x, locStartPosition.y + y);
        }
      },
      reverse: function() {
        var action = new cc.MoveBy(this._duration, cc.p(-this._positionDelta.x, -this._positionDelta.y));
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      }
    });
    cc.moveBy = function(duration, deltaPos, deltaY) {
      return new cc.MoveBy(duration, deltaPos, deltaY);
    };
    cc.MoveTo = cc.MoveBy.extend({
      _endPosition: null,
      ctor: function(duration, position, y) {
        cc.MoveBy.prototype.ctor.call(this);
        this._endPosition = cc.p(0, 0);
        void 0 !== position && this.initWithDuration(duration, position, y);
      },
      initWithDuration: function(duration, position, y) {
        if (cc.MoveBy.prototype.initWithDuration.call(this, duration, position, y)) {
          if (void 0 !== position.x) {
            y = position.y;
            position = position.x;
          }
          this._endPosition.x = position;
          this._endPosition.y = y;
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.MoveTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._endPosition);
        return action;
      },
      startWithTarget: function(target) {
        cc.MoveBy.prototype.startWithTarget.call(this, target);
        this._positionDelta.x = this._endPosition.x - target.getPositionX();
        this._positionDelta.y = this._endPosition.y - target.getPositionY();
      }
    });
    cc.moveTo = function(duration, position, y) {
      return new cc.MoveTo(duration, position, y);
    };
    cc.SkewTo = cc.ActionInterval.extend({
      _skewX: 0,
      _skewY: 0,
      _startSkewX: 0,
      _startSkewY: 0,
      _endSkewX: 0,
      _endSkewY: 0,
      _deltaX: 0,
      _deltaY: 0,
      ctor: function(t, sx, sy) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== sy && this.initWithDuration(t, sx, sy);
      },
      initWithDuration: function(t, sx, sy) {
        var ret = false;
        if (cc.ActionInterval.prototype.initWithDuration.call(this, t)) {
          this._endSkewX = sx;
          this._endSkewY = sy;
          ret = true;
        }
        return ret;
      },
      clone: function() {
        var action = new cc.SkewTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._endSkewX, this._endSkewY);
        return action;
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._startSkewX = target.skewX % 180;
        this._deltaX = this._endSkewX - this._startSkewX;
        this._deltaX > 180 && (this._deltaX -= 360);
        this._deltaX < -180 && (this._deltaX += 360);
        this._startSkewY = target.skewY % 360;
        this._deltaY = this._endSkewY - this._startSkewY;
        this._deltaY > 180 && (this._deltaY -= 360);
        this._deltaY < -180 && (this._deltaY += 360);
      },
      update: function(dt) {
        dt = this._computeEaseTime(dt);
        this.target.skewX = this._startSkewX + this._deltaX * dt;
        this.target.skewY = this._startSkewY + this._deltaY * dt;
      }
    });
    cc.skewTo = function(t, sx, sy) {
      return new cc.SkewTo(t, sx, sy);
    };
    cc.SkewBy = cc.SkewTo.extend({
      ctor: function(t, sx, sy) {
        cc.SkewTo.prototype.ctor.call(this);
        void 0 !== sy && this.initWithDuration(t, sx, sy);
      },
      initWithDuration: function(t, deltaSkewX, deltaSkewY) {
        var ret = false;
        if (cc.SkewTo.prototype.initWithDuration.call(this, t, deltaSkewX, deltaSkewY)) {
          this._skewX = deltaSkewX;
          this._skewY = deltaSkewY;
          ret = true;
        }
        return ret;
      },
      clone: function() {
        var action = new cc.SkewBy();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._skewX, this._skewY);
        return action;
      },
      startWithTarget: function(target) {
        cc.SkewTo.prototype.startWithTarget.call(this, target);
        this._deltaX = this._skewX;
        this._deltaY = this._skewY;
        this._endSkewX = this._startSkewX + this._deltaX;
        this._endSkewY = this._startSkewY + this._deltaY;
      },
      reverse: function() {
        var action = new cc.SkewBy(this._duration, -this._skewX, -this._skewY);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      }
    });
    cc.skewBy = function(t, sx, sy) {
      return new cc.SkewBy(t, sx, sy);
    };
    cc.JumpBy = cc.ActionInterval.extend({
      _startPosition: null,
      _delta: null,
      _height: 0,
      _jumps: 0,
      _previousPosition: null,
      ctor: function(duration, position, y, height, jumps) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._startPosition = cc.p(0, 0);
        this._previousPosition = cc.p(0, 0);
        this._delta = cc.p(0, 0);
        void 0 !== height && this.initWithDuration(duration, position, y, height, jumps);
      },
      initWithDuration: function(duration, position, y, height, jumps) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
          if (void 0 === jumps) {
            jumps = height;
            height = y;
            y = position.y;
            position = position.x;
          }
          this._delta.x = position;
          this._delta.y = y;
          this._height = height;
          this._jumps = jumps;
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.JumpBy();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._delta, this._height, this._jumps);
        return action;
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        var locPosX = target.getPositionX();
        var locPosY = target.getPositionY();
        this._previousPosition.x = locPosX;
        this._previousPosition.y = locPosY;
        this._startPosition.x = locPosX;
        this._startPosition.y = locPosY;
      },
      update: function(dt) {
        dt = this._computeEaseTime(dt);
        if (this.target) {
          var frac = dt * this._jumps % 1;
          var y = 4 * this._height * frac * (1 - frac);
          y += this._delta.y * dt;
          var x = this._delta.x * dt;
          var locStartPosition = this._startPosition;
          if (cc.macro.ENABLE_STACKABLE_ACTIONS) {
            var targetX = this.target.getPositionX();
            var targetY = this.target.getPositionY();
            var locPreviousPosition = this._previousPosition;
            locStartPosition.x = locStartPosition.x + targetX - locPreviousPosition.x;
            locStartPosition.y = locStartPosition.y + targetY - locPreviousPosition.y;
            x += locStartPosition.x;
            y += locStartPosition.y;
            locPreviousPosition.x = x;
            locPreviousPosition.y = y;
            this.target.setPosition(x, y);
          } else this.target.setPosition(locStartPosition.x + x, locStartPosition.y + y);
        }
      },
      reverse: function() {
        var action = new cc.JumpBy(this._duration, cc.p(-this._delta.x, -this._delta.y), this._height, this._jumps);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      }
    });
    cc.jumpBy = function(duration, position, y, height, jumps) {
      return new cc.JumpBy(duration, position, y, height, jumps);
    };
    cc.JumpTo = cc.JumpBy.extend({
      _endPosition: null,
      ctor: function(duration, position, y, height, jumps) {
        cc.JumpBy.prototype.ctor.call(this);
        this._endPosition = cc.p(0, 0);
        void 0 !== height && this.initWithDuration(duration, position, y, height, jumps);
      },
      initWithDuration: function(duration, position, y, height, jumps) {
        if (cc.JumpBy.prototype.initWithDuration.call(this, duration, position, y, height, jumps)) {
          if (void 0 === jumps) {
            y = position.y;
            position = position.x;
          }
          this._endPosition.x = position;
          this._endPosition.y = y;
          return true;
        }
        return false;
      },
      startWithTarget: function(target) {
        cc.JumpBy.prototype.startWithTarget.call(this, target);
        this._delta.x = this._endPosition.x - this._startPosition.x;
        this._delta.y = this._endPosition.y - this._startPosition.y;
      },
      clone: function() {
        var action = new cc.JumpTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._endPosition, this._height, this._jumps);
        return action;
      }
    });
    cc.jumpTo = function(duration, position, y, height, jumps) {
      return new cc.JumpTo(duration, position, y, height, jumps);
    };
    cc.bezierAt = function(a, b, c, d, t) {
      return Math.pow(1 - t, 3) * a + 3 * t * Math.pow(1 - t, 2) * b + 3 * Math.pow(t, 2) * (1 - t) * c + Math.pow(t, 3) * d;
    };
    cc.BezierBy = cc.ActionInterval.extend({
      _config: null,
      _startPosition: null,
      _previousPosition: null,
      ctor: function(t, c) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._config = [];
        this._startPosition = cc.p(0, 0);
        this._previousPosition = cc.p(0, 0);
        c && this.initWithDuration(t, c);
      },
      initWithDuration: function(t, c) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, t)) {
          this._config = c;
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.BezierBy();
        this._cloneDecoration(action);
        var newConfigs = [];
        for (var i = 0; i < this._config.length; i++) {
          var selConf = this._config[i];
          newConfigs.push(cc.p(selConf.x, selConf.y));
        }
        action.initWithDuration(this._duration, newConfigs);
        return action;
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        var locPosX = target.getPositionX();
        var locPosY = target.getPositionY();
        this._previousPosition.x = locPosX;
        this._previousPosition.y = locPosY;
        this._startPosition.x = locPosX;
        this._startPosition.y = locPosY;
      },
      update: function(dt) {
        dt = this._computeEaseTime(dt);
        if (this.target) {
          var locConfig = this._config;
          var xa = 0;
          var xb = locConfig[0].x;
          var xc = locConfig[1].x;
          var xd = locConfig[2].x;
          var ya = 0;
          var yb = locConfig[0].y;
          var yc = locConfig[1].y;
          var yd = locConfig[2].y;
          var x = cc.bezierAt(xa, xb, xc, xd, dt);
          var y = cc.bezierAt(ya, yb, yc, yd, dt);
          var locStartPosition = this._startPosition;
          if (cc.macro.ENABLE_STACKABLE_ACTIONS) {
            var targetX = this.target.getPositionX();
            var targetY = this.target.getPositionY();
            var locPreviousPosition = this._previousPosition;
            locStartPosition.x = locStartPosition.x + targetX - locPreviousPosition.x;
            locStartPosition.y = locStartPosition.y + targetY - locPreviousPosition.y;
            x += locStartPosition.x;
            y += locStartPosition.y;
            locPreviousPosition.x = x;
            locPreviousPosition.y = y;
            this.target.setPosition(x, y);
          } else this.target.setPosition(locStartPosition.x + x, locStartPosition.y + y);
        }
      },
      reverse: function() {
        var locConfig = this._config;
        var r = [ cc.pAdd(locConfig[1], cc.pNeg(locConfig[2])), cc.pAdd(locConfig[0], cc.pNeg(locConfig[2])), cc.pNeg(locConfig[2]) ];
        var action = new cc.BezierBy(this._duration, r);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      }
    });
    cc.bezierBy = function(t, c) {
      return new cc.BezierBy(t, c);
    };
    cc.BezierTo = cc.BezierBy.extend({
      _toConfig: null,
      ctor: function(t, c) {
        cc.BezierBy.prototype.ctor.call(this);
        this._toConfig = [];
        c && this.initWithDuration(t, c);
      },
      initWithDuration: function(t, c) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, t)) {
          this._toConfig = c;
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.BezierTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._toConfig);
        return action;
      },
      startWithTarget: function(target) {
        cc.BezierBy.prototype.startWithTarget.call(this, target);
        var locStartPos = this._startPosition;
        var locToConfig = this._toConfig;
        var locConfig = this._config;
        locConfig[0] = cc.pSub(locToConfig[0], locStartPos);
        locConfig[1] = cc.pSub(locToConfig[1], locStartPos);
        locConfig[2] = cc.pSub(locToConfig[2], locStartPos);
      }
    });
    cc.bezierTo = function(t, c) {
      return new cc.BezierTo(t, c);
    };
    cc.ScaleTo = cc.ActionInterval.extend({
      _scaleX: 1,
      _scaleY: 1,
      _startScaleX: 1,
      _startScaleY: 1,
      _endScaleX: 0,
      _endScaleY: 0,
      _deltaX: 0,
      _deltaY: 0,
      ctor: function(duration, sx, sy) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== sx && this.initWithDuration(duration, sx, sy);
      },
      initWithDuration: function(duration, sx, sy) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
          this._endScaleX = sx;
          this._endScaleY = null != sy ? sy : sx;
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.ScaleTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._endScaleX, this._endScaleY);
        return action;
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._startScaleX = target.scaleX;
        this._startScaleY = target.scaleY;
        this._deltaX = this._endScaleX - this._startScaleX;
        this._deltaY = this._endScaleY - this._startScaleY;
      },
      update: function(dt) {
        dt = this._computeEaseTime(dt);
        if (this.target) {
          this.target.scaleX = this._startScaleX + this._deltaX * dt;
          this.target.scaleY = this._startScaleY + this._deltaY * dt;
        }
      }
    });
    cc.scaleTo = function(duration, sx, sy) {
      return new cc.ScaleTo(duration, sx, sy);
    };
    cc.ScaleBy = cc.ScaleTo.extend({
      startWithTarget: function(target) {
        cc.ScaleTo.prototype.startWithTarget.call(this, target);
        this._deltaX = this._startScaleX * this._endScaleX - this._startScaleX;
        this._deltaY = this._startScaleY * this._endScaleY - this._startScaleY;
      },
      reverse: function() {
        var action = new cc.ScaleBy(this._duration, 1 / this._endScaleX, 1 / this._endScaleY);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      },
      clone: function() {
        var action = new cc.ScaleBy();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._endScaleX, this._endScaleY);
        return action;
      }
    });
    cc.scaleBy = function(duration, sx, sy) {
      return new cc.ScaleBy(duration, sx, sy);
    };
    cc.Blink = cc.ActionInterval.extend({
      _times: 0,
      _originalState: false,
      ctor: function(duration, blinks) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== blinks && this.initWithDuration(duration, blinks);
      },
      initWithDuration: function(duration, blinks) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
          this._times = blinks;
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.Blink();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._times);
        return action;
      },
      update: function(dt) {
        dt = this._computeEaseTime(dt);
        if (this.target && !this.isDone()) {
          var slice = 1 / this._times;
          var m = dt % slice;
          this.target.opacity = m > slice / 2 ? 255 : 0;
        }
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._originalState = target.opacity;
      },
      stop: function() {
        this.target.opacity = this._originalState;
        cc.ActionInterval.prototype.stop.call(this);
      },
      reverse: function() {
        var action = new cc.Blink(this._duration, this._times);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      }
    });
    cc.blink = function(duration, blinks) {
      return new cc.Blink(duration, blinks);
    };
    cc.FadeTo = cc.ActionInterval.extend({
      _toOpacity: 0,
      _fromOpacity: 0,
      ctor: function(duration, opacity) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== opacity && this.initWithDuration(duration, opacity);
      },
      initWithDuration: function(duration, opacity) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
          this._toOpacity = opacity;
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.FadeTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._toOpacity);
        return action;
      },
      update: function(time) {
        time = this._computeEaseTime(time);
        var fromOpacity = void 0 !== this._fromOpacity ? this._fromOpacity : 255;
        this.target.opacity = fromOpacity + (this._toOpacity - fromOpacity) * time;
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._fromOpacity = target.opacity;
      }
    });
    cc.fadeTo = function(duration, opacity) {
      return new cc.FadeTo(duration, opacity);
    };
    cc.FadeIn = cc.FadeTo.extend({
      _reverseAction: null,
      ctor: function(duration) {
        cc.FadeTo.prototype.ctor.call(this);
        null == duration && (duration = 0);
        this.initWithDuration(duration, 255);
      },
      reverse: function() {
        var action = new cc.FadeOut();
        action.initWithDuration(this._duration, 0);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      },
      clone: function() {
        var action = new cc.FadeIn();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._toOpacity);
        return action;
      },
      startWithTarget: function(target) {
        this._reverseAction && (this._toOpacity = this._reverseAction._fromOpacity);
        cc.FadeTo.prototype.startWithTarget.call(this, target);
      }
    });
    cc.fadeIn = function(duration) {
      return new cc.FadeIn(duration);
    };
    cc.FadeOut = cc.FadeTo.extend({
      ctor: function(duration) {
        cc.FadeTo.prototype.ctor.call(this);
        null == duration && (duration = 0);
        this.initWithDuration(duration, 0);
      },
      reverse: function() {
        var action = new cc.FadeIn();
        action._reverseAction = this;
        action.initWithDuration(this._duration, 255);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      },
      clone: function() {
        var action = new cc.FadeOut();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._toOpacity);
        return action;
      }
    });
    cc.fadeOut = function(d) {
      return new cc.FadeOut(d);
    };
    cc.TintTo = cc.ActionInterval.extend({
      _to: null,
      _from: null,
      ctor: function(duration, red, green, blue) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._to = cc.color(0, 0, 0);
        this._from = cc.color(0, 0, 0);
        if (red instanceof cc.Color) {
          blue = red.b;
          green = red.g;
          red = red.r;
        }
        void 0 !== blue && this.initWithDuration(duration, red, green, blue);
      },
      initWithDuration: function(duration, red, green, blue) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
          this._to = cc.color(red, green, blue);
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.TintTo();
        this._cloneDecoration(action);
        var locTo = this._to;
        action.initWithDuration(this._duration, locTo.r, locTo.g, locTo.b);
        return action;
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._from = this.target.color;
      },
      update: function(dt) {
        dt = this._computeEaseTime(dt);
        var locFrom = this._from, locTo = this._to;
        locFrom && this.target.setColor(cc.color(locFrom.r + (locTo.r - locFrom.r) * dt, locFrom.g + (locTo.g - locFrom.g) * dt, locFrom.b + (locTo.b - locFrom.b) * dt));
      }
    });
    cc.tintTo = function(duration, red, green, blue) {
      return new cc.TintTo(duration, red, green, blue);
    };
    cc.TintBy = cc.ActionInterval.extend({
      _deltaR: 0,
      _deltaG: 0,
      _deltaB: 0,
      _fromR: 0,
      _fromG: 0,
      _fromB: 0,
      ctor: function(duration, deltaRed, deltaGreen, deltaBlue) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== deltaBlue && this.initWithDuration(duration, deltaRed, deltaGreen, deltaBlue);
      },
      initWithDuration: function(duration, deltaRed, deltaGreen, deltaBlue) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
          this._deltaR = deltaRed;
          this._deltaG = deltaGreen;
          this._deltaB = deltaBlue;
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.TintBy();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._deltaR, this._deltaG, this._deltaB);
        return action;
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        var color = target.color;
        this._fromR = color.r;
        this._fromG = color.g;
        this._fromB = color.b;
      },
      update: function(dt) {
        dt = this._computeEaseTime(dt);
        this.target.color = cc.color(this._fromR + this._deltaR * dt, this._fromG + this._deltaG * dt, this._fromB + this._deltaB * dt);
      },
      reverse: function() {
        var action = new cc.TintBy(this._duration, -this._deltaR, -this._deltaG, -this._deltaB);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      }
    });
    cc.tintBy = function(duration, deltaRed, deltaGreen, deltaBlue) {
      return new cc.TintBy(duration, deltaRed, deltaGreen, deltaBlue);
    };
    cc.DelayTime = cc.ActionInterval.extend({
      update: function(dt) {},
      reverse: function() {
        var action = new cc.DelayTime(this._duration);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      },
      clone: function() {
        var action = new cc.DelayTime();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration);
        return action;
      }
    });
    cc.delayTime = function(d) {
      return new cc.DelayTime(d);
    };
    cc.ReverseTime = cc.ActionInterval.extend({
      _other: null,
      ctor: function(action) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._other = null;
        action && this.initWithAction(action);
      },
      initWithAction: function(action) {
        if (!action) throw new Error("cc.ReverseTime.initWithAction(): action must be non null");
        if (action === this._other) throw new Error("cc.ReverseTime.initWithAction(): the action was already passed in.");
        if (cc.ActionInterval.prototype.initWithDuration.call(this, action._duration)) {
          this._other = action;
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.ReverseTime();
        this._cloneDecoration(action);
        action.initWithAction(this._other.clone());
        return action;
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._other.startWithTarget(target);
      },
      update: function(dt) {
        dt = this._computeEaseTime(dt);
        this._other && this._other.update(1 - dt);
      },
      reverse: function() {
        return this._other.clone();
      },
      stop: function() {
        this._other.stop();
        cc.Action.prototype.stop.call(this);
      }
    });
    cc.reverseTime = function(action) {
      return new cc.ReverseTime(action);
    };
    cc.Animate = cc.ActionInterval.extend({
      _animation: null,
      _nextFrame: 0,
      _origFrame: null,
      _executedLoops: 0,
      _splitTimes: null,
      _currFrameIndex: 0,
      ctor: function(animation) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._splitTimes = [];
        animation && this.initWithAnimation(animation);
      },
      getAnimation: function() {
        return this._animation;
      },
      setAnimation: function(animation) {
        this._animation = animation;
      },
      getCurrentFrameIndex: function() {
        return this._currFrameIndex;
      },
      initWithAnimation: function(animation) {
        if (!animation) throw new Error("cc.Animate.initWithAnimation(): animation must be non-NULL");
        var singleDuration = animation.getDuration();
        if (this.initWithDuration(singleDuration * animation.getLoops())) {
          this._nextFrame = 0;
          this.setAnimation(animation);
          this._origFrame = null;
          this._executedLoops = 0;
          var locTimes = this._splitTimes;
          locTimes.length = 0;
          var accumUnitsOfTime = 0;
          var newUnitOfTimeValue = singleDuration / animation.getTotalDelayUnits();
          var frames = animation.getFrames();
          cc.js.array.verifyType(frames, cc.AnimationFrame);
          for (var i = 0; i < frames.length; i++) {
            var frame = frames[i];
            var value = accumUnitsOfTime * newUnitOfTimeValue / singleDuration;
            accumUnitsOfTime += frame.getDelayUnits();
            locTimes.push(value);
          }
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.Animate();
        this._cloneDecoration(action);
        action.initWithAnimation(this._animation.clone());
        return action;
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._animation.getRestoreOriginalFrame() && (this._origFrame = target.getSpriteFrame());
        this._nextFrame = 0;
        this._executedLoops = 0;
      },
      update: function(dt) {
        dt = this._computeEaseTime(dt);
        if (dt < 1) {
          dt *= this._animation.getLoops();
          var loopNumber = 0 | dt;
          if (loopNumber > this._executedLoops) {
            this._nextFrame = 0;
            this._executedLoops++;
          }
          dt %= 1;
        }
        var frames = this._animation.getFrames();
        var numberOfFrames = frames.length, locSplitTimes = this._splitTimes;
        for (var i = this._nextFrame; i < numberOfFrames; i++) {
          if (!(locSplitTimes[i] <= dt)) break;
          _currFrameIndex = i;
          this.target.setSpriteFrame(frames[_currFrameIndex].getSpriteFrame());
          this._nextFrame = i + 1;
        }
      },
      reverse: function() {
        var locAnimation = this._animation;
        var oldArray = locAnimation.getFrames();
        var newArray = [];
        cc.js.array.verifyType(oldArray, cc.AnimationFrame);
        if (oldArray.length > 0) for (var i = oldArray.length - 1; i >= 0; i--) {
          var element = oldArray[i];
          if (!element) break;
          newArray.push(element.clone());
        }
        var newAnim = new cc.SpriteFrameAnimation(newArray, locAnimation.getDelayPerUnit(), locAnimation.getLoops());
        newAnim.setRestoreOriginalFrame(locAnimation.getRestoreOriginalFrame());
        var action = new cc.Animate(newAnim);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      },
      stop: function() {
        this._animation.getRestoreOriginalFrame() && this.target && this.target.setSpriteFrame(this._origFrame);
        cc.Action.prototype.stop.call(this);
      }
    });
    cc.animate = function(animation) {
      return new cc.Animate(animation);
    };
    cc.TargetedAction = cc.ActionInterval.extend({
      _action: null,
      _forcedTarget: null,
      ctor: function(target, action) {
        cc.ActionInterval.prototype.ctor.call(this);
        action && this.initWithTarget(target, action);
      },
      initWithTarget: function(target, action) {
        if (this.initWithDuration(action._duration)) {
          this._forcedTarget = target;
          this._action = action;
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.TargetedAction();
        this._cloneDecoration(action);
        action.initWithTarget(this._forcedTarget, this._action.clone());
        return action;
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._action.startWithTarget(this._forcedTarget);
      },
      stop: function() {
        this._action.stop();
      },
      update: function(dt) {
        dt = this._computeEaseTime(dt);
        this._action.update(dt);
      },
      getForcedTarget: function() {
        return this._forcedTarget;
      },
      setForcedTarget: function(forcedTarget) {
        this._forcedTarget !== forcedTarget && (this._forcedTarget = forcedTarget);
      }
    });
    cc.targetedAction = function(target, action) {
      return new cc.TargetedAction(target, action);
    };
  }), {} ],
  9: [ (function(require, module, exports) {
    var HashElement = function() {
      this.actions = [];
      this.target = null;
      this.actionIndex = 0;
      this.currentAction = null;
      this.paused = false;
      this.lock = false;
    };
    cc.ActionManager = cc._Class.extend({
      _elementPool: [],
      _searchElementByTarget: function(arr, target) {
        for (var k = 0; k < arr.length; k++) if (target === arr[k].target) return arr[k];
        return null;
      },
      ctor: function() {
        this._hashTargets = {};
        this._arrayTargets = [];
        this._currentTarget = null;
      },
      _getElement: function(target, paused) {
        var element = this._elementPool.pop();
        element || (element = new HashElement());
        element.target = target;
        element.paused = !!paused;
        return element;
      },
      _putElement: function(element) {
        element.actions.length = 0;
        element.actionIndex = 0;
        element.currentAction = null;
        element.paused = false;
        element.target = null;
        element.lock = false;
        this._elementPool.push(element);
      },
      addAction: function(action, target, paused) {
        if (!action) throw new Error("cc.ActionManager.addAction(): action must be non-null");
        if (!target) throw new Error("cc.ActionManager.addAction(): action must be non-null");
        var element = this._hashTargets[target.__instanceId];
        if (element) element.actions || (element.actions = []); else {
          element = this._getElement(target, paused);
          this._hashTargets[target.__instanceId] = element;
          this._arrayTargets.push(element);
        }
        element.actions.push(action);
        action.startWithTarget(target);
      },
      removeAllActions: function() {
        var locTargets = this._arrayTargets;
        for (var i = 0; i < locTargets.length; i++) {
          var element = locTargets[i];
          element && this.removeAllActionsFromTarget(element.target, true);
        }
      },
      removeAllActionsFromTarget: function(target, forceDelete) {
        if (null == target) return;
        var element = this._hashTargets[target.__instanceId];
        if (element) {
          element.actions.length = 0;
          this._deleteHashElement(element);
        }
      },
      removeAction: function(action) {
        if (null == action) return;
        var target = action.getOriginalTarget();
        var element = this._hashTargets[target.__instanceId];
        if (element) {
          for (var i = 0; i < element.actions.length; i++) if (element.actions[i] === action) {
            element.actions.splice(i, 1);
            element.actionIndex >= i && element.actionIndex--;
            break;
          }
        } else cc.logID(1001);
      },
      removeActionByTag: function(tag, target) {
        tag === cc.Action.TAG_INVALID && cc.logID(1002);
        cc.assertID(target, 1003);
        var element = this._hashTargets[target.__instanceId];
        if (element) {
          var limit = element.actions.length;
          for (var i = 0; i < limit; ++i) {
            var action = element.actions[i];
            if (action && action.getTag() === tag && action.getOriginalTarget() === target) {
              this._removeActionAtIndex(i, element);
              break;
            }
          }
        }
      },
      getActionByTag: function(tag, target) {
        tag === cc.Action.TAG_INVALID && cc.logID(1004);
        var element = this._hashTargets[target.__instanceId];
        if (element) {
          if (null != element.actions) for (var i = 0; i < element.actions.length; ++i) {
            var action = element.actions[i];
            if (action && action.getTag() === tag) return action;
          }
          cc.logID(1005, tag);
        }
        return null;
      },
      getNumberOfRunningActionsInTarget: function(target) {
        var element = this._hashTargets[target.__instanceId];
        if (element) return element.actions ? element.actions.length : 0;
        return 0;
      },
      pauseTarget: function(target) {
        var element = this._hashTargets[target.__instanceId];
        element && (element.paused = true);
      },
      resumeTarget: function(target) {
        var element = this._hashTargets[target.__instanceId];
        element && (element.paused = false);
      },
      pauseAllRunningActions: function() {
        var idsWithActions = [];
        var locTargets = this._arrayTargets;
        for (var i = 0; i < locTargets.length; i++) {
          var element = locTargets[i];
          if (element && !element.paused) {
            element.paused = true;
            idsWithActions.push(element.target);
          }
        }
        return idsWithActions;
      },
      resumeTargets: function(targetsToResume) {
        if (!targetsToResume) return;
        for (var i = 0; i < targetsToResume.length; i++) targetsToResume[i] && this.resumeTarget(targetsToResume[i]);
      },
      pauseTargets: function(targetsToPause) {
        if (!targetsToPause) return;
        for (var i = 0; i < targetsToPause.length; i++) targetsToPause[i] && this.pauseTarget(targetsToPause[i]);
      },
      purgeSharedManager: function() {
        cc.director.getScheduler().unscheduleUpdate(this);
      },
      _removeActionAtIndex: function(index, element) {
        var action = element.actions[index];
        element.actions.splice(index, 1);
        element.actionIndex >= index && element.actionIndex--;
        0 === element.actions.length && this._deleteHashElement(element);
      },
      _deleteHashElement: function(element) {
        var ret = false;
        if (element && !element.lock && this._hashTargets[element.target.__instanceId]) {
          delete this._hashTargets[element.target.__instanceId];
          var targets = this._arrayTargets;
          for (var i = 0, l = targets.length; i < l; i++) if (targets[i] === element) {
            targets.splice(i, 1);
            break;
          }
          this._putElement(element);
          ret = true;
        }
        return ret;
      },
      update: function(dt) {
        var locTargets = this._arrayTargets, locCurrTarget;
        for (var elt = 0; elt < locTargets.length; elt++) {
          this._currentTarget = locTargets[elt];
          locCurrTarget = this._currentTarget;
          if (!locCurrTarget.paused && locCurrTarget.actions) {
            locCurrTarget.lock = true;
            for (locCurrTarget.actionIndex = 0; locCurrTarget.actionIndex < locCurrTarget.actions.length; locCurrTarget.actionIndex++) {
              locCurrTarget.currentAction = locCurrTarget.actions[locCurrTarget.actionIndex];
              if (!locCurrTarget.currentAction) continue;
              locCurrTarget.currentAction.step(dt * (locCurrTarget.currentAction._speedMethod ? locCurrTarget.currentAction._speed : 1));
              if (locCurrTarget.currentAction && locCurrTarget.currentAction.isDone()) {
                locCurrTarget.currentAction.stop();
                var action = locCurrTarget.currentAction;
                locCurrTarget.currentAction = null;
                this.removeAction(action);
              }
              locCurrTarget.currentAction = null;
            }
            locCurrTarget.lock = false;
          }
          0 === locCurrTarget.actions.length && this._deleteHashElement(locCurrTarget) && elt--;
        }
      }
    });
    false;
  }), {} ],
  10: [ (function(require, module, exports) {
    require("./CCActionManager");
    require("./CCAction");
    require("./CCActionInterval");
    require("./CCActionInstant");
    require("./CCActionEase");
    require("./CCActionCatmullRom");
  }), {
    "./CCAction": 4,
    "./CCActionCatmullRom": 5,
    "./CCActionEase": 6,
    "./CCActionInstant": 7,
    "./CCActionInterval": 8,
    "./CCActionManager": 9
  } ],
  11: [ (function(require, module, exports) {
    var JS = cc.js;
    var Playable = require("./playable");
    var DynamicAnimCurve = require("./animation-curves").DynamicAnimCurve;
    var quickFindIndex = require("./animation-curves").quickFindIndex;
    var sampleMotionPaths = require("./motion-path-helper").sampleMotionPaths;
    var EventAnimCurve = require("./animation-curves").EventAnimCurve;
    var EventInfo = require("./animation-curves").EventInfo;
    var WrapModeMask = require("./types").WrapModeMask;
    var binarySearch = require("../core/utils/binary-search").binarySearchEpsilon;
    function AnimationAnimator(target, animation) {
      Playable.call(this);
      this.target = target;
      this.animation = animation;
      this._anims = new JS.array.MutableForwardIterator([]);
    }
    JS.extend(AnimationAnimator, Playable);
    var p = AnimationAnimator.prototype;
    p.playState = function(state, startTime) {
      if (!state.clip) return;
      state.curveLoaded || initClipData(this.target, state);
      state.animator = this;
      state.play();
      "number" === typeof startTime && state.setTime(startTime);
      this.play();
    };
    p.stopStatesExcept = function(state) {
      var iterator = this._anims;
      var array = iterator.array;
      for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
        var anim = array[iterator.i];
        if (anim === state) continue;
        this.stopState(anim);
      }
    };
    p.addAnimation = function(anim) {
      var index = this._anims.array.indexOf(anim);
      -1 === index && this._anims.push(anim);
      anim._setListeners(this.animation);
    };
    p.removeAnimation = function(anim) {
      var index = this._anims.array.indexOf(anim);
      if (index >= 0) {
        this._anims.fastRemoveAt(index);
        0 === this._anims.array.length && this.stop();
      } else cc.errorID(3908);
      anim.animator = null;
    };
    p.sample = function() {
      var iterator = this._anims;
      var array = iterator.array;
      for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
        var anim = array[iterator.i];
        anim.sample();
      }
    };
    p.stopState = function(state) {
      state && state.stop();
    };
    p.pauseState = function(state) {
      state && state.pause();
    };
    p.resumeState = function(state) {
      state && state.resume();
      this.isPaused && this.resume();
    };
    p.setStateTime = function(state, time) {
      if (void 0 !== time) {
        if (state) {
          state.setTime(time);
          state.sample();
        }
      } else {
        time = state;
        var array = this._anims.array;
        for (var i = 0; i < array.length; ++i) {
          var anim = array[i];
          anim.setTime(time);
          anim.sample();
        }
      }
    };
    p.onStop = function() {
      var iterator = this._anims;
      var array = iterator.array;
      for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
        var anim = array[iterator.i];
        anim.stop();
      }
    };
    p.onPause = function() {
      var array = this._anims.array;
      for (var i = 0; i < array.length; ++i) {
        var anim = array[i];
        anim.pause();
        anim.animator = null;
      }
    };
    p.onResume = function() {
      var array = this._anims.array;
      for (var i = 0; i < array.length; ++i) {
        var anim = array[i];
        anim.animator = this;
        anim.resume();
      }
    };
    p._reloadClip = function(state) {
      initClipData(this.target, state);
    };
    function createBatchedProperty(propPath, firstDotIndex, mainValue, animValue) {
      mainValue = mainValue.clone();
      var nextValue = mainValue;
      var leftIndex = firstDotIndex + 1;
      var rightIndex = propPath.indexOf(".", leftIndex);
      while (-1 !== rightIndex) {
        var nextName = propPath.slice(leftIndex, rightIndex);
        nextValue = nextValue[nextName];
        leftIndex = rightIndex + 1;
        rightIndex = propPath.indexOf(".", leftIndex);
      }
      var lastPropName = propPath.slice(leftIndex);
      nextValue[lastPropName] = animValue;
      return mainValue;
    }
    false;
    function splitPropPath(propPath) {
      var array = propPath.split(".");
      array.shift();
      return array.length > 0 ? array : null;
    }
    function initClipData(root, state) {
      var clip = state.clip;
      var curves = state.curves;
      curves.length = 0;
      state.duration = clip.duration;
      state.speed = clip.speed;
      state.wrapMode = clip.wrapMode;
      state.frameRate = clip.sample;
      (state.wrapMode & WrapModeMask.Loop) === WrapModeMask.Loop ? state.repeatCount = Infinity : state.repeatCount = 1;
      function checkMotionPath(motionPath) {
        if (!Array.isArray(motionPath)) return false;
        for (var i = 0, l = motionPath.length; i < l; i++) {
          var controls = motionPath[i];
          if (!Array.isArray(controls) || 6 !== controls.length) return false;
        }
        return true;
      }
      function createPropCurve(target, propPath, keyframes) {
        var isMotionPathProp = target instanceof cc.Node && "position" === propPath;
        var motionPaths = [];
        var curve = new DynamicAnimCurve();
        curve.target = target;
        var propName, propValue;
        var dotIndex = propPath.indexOf(".");
        var hasSubProp = -1 !== dotIndex;
        if (hasSubProp) {
          propName = propPath.slice(0, dotIndex);
          propValue = target[propName];
        } else propName = propPath;
        curve.prop = propName;
        curve.subProps = splitPropPath(propPath);
        for (var i = 0, l = keyframes.length; i < l; i++) {
          var keyframe = keyframes[i];
          var ratio = keyframe.frame / state.duration;
          curve.ratios.push(ratio);
          if (isMotionPathProp) {
            var motionPath = keyframe.motionPath;
            if (motionPath && !checkMotionPath(motionPath)) {
              cc.errorID(3904, target.name, propPath, i);
              motionPath = null;
            }
            motionPaths.push(motionPath);
          }
          var curveValue = keyframe.value;
          curve.values.push(curveValue);
          var curveTypes = keyframe.curve;
          if (curveTypes) {
            if ("string" === typeof curveTypes) {
              curve.types.push(curveTypes);
              continue;
            }
            if (Array.isArray(curveTypes)) {
              curveTypes[0] === curveTypes[1] && curveTypes[2] === curveTypes[3] ? curve.types.push(DynamicAnimCurve.Linear) : curve.types.push(DynamicAnimCurve.Bezier(curveTypes));
              continue;
            }
          }
          curve.types.push(DynamicAnimCurve.Linear);
        }
        isMotionPathProp && sampleMotionPaths(motionPaths, curve, clip.duration, clip.sample);
        var ratios = curve.ratios;
        var currRatioDif, lastRatioDif;
        var canOptimize = true;
        var EPSILON = 1e-6;
        for (var _i = 1, _l = ratios.length; _i < _l; _i++) {
          currRatioDif = ratios[_i] - ratios[_i - 1];
          if (1 === _i) lastRatioDif = currRatioDif; else if (Math.abs(currRatioDif - lastRatioDif) > EPSILON) {
            canOptimize = false;
            break;
          }
        }
        curve._findFrameIndex = canOptimize ? quickFindIndex : binarySearch;
        return curve;
      }
      function createTargetCurves(target, curveData) {
        var propsData = curveData.props;
        var compsData = curveData.comps;
        if (propsData) for (var propPath in propsData) {
          var data = propsData[propPath];
          var curve = createPropCurve(target, propPath, data);
          curves.push(curve);
        }
        if (compsData) for (var compName in compsData) {
          var comp = target.getComponent(compName);
          if (!comp) continue;
          var compData = compsData[compName];
          for (var propPath in compData) {
            var data = compData[propPath];
            var curve = createPropCurve(comp, propPath, data);
            curves.push(curve);
          }
        }
      }
      var curveData = clip.curveData;
      var childrenCurveDatas = curveData.paths;
      createTargetCurves(root, curveData);
      for (var namePath in childrenCurveDatas) {
        var target = cc.find(namePath, root);
        if (!target) continue;
        var childCurveDatas = childrenCurveDatas[namePath];
        createTargetCurves(target, childCurveDatas);
      }
      var events = clip.events;
      if (true, events) {
        var curve;
        for (var i = 0, l = events.length; i < l; i++) {
          if (!curve) {
            curve = new EventAnimCurve();
            curve.target = root;
            curves.push(curve);
          }
          var eventData = events[i];
          var ratio = eventData.frame / state.duration;
          var eventInfo;
          var index = binarySearch(curve.ratios, ratio);
          if (index >= 0) eventInfo = curve.events[index]; else {
            eventInfo = new EventInfo();
            curve.ratios.push(ratio);
            curve.events.push(eventInfo);
          }
          eventInfo.add(eventData.func, eventData.params);
        }
      }
    }
    false;
    module.exports = AnimationAnimator;
  }), {
    "../core/utils/binary-search": 221,
    "./animation-curves": 13,
    "./motion-path-helper": 19,
    "./playable": 20,
    "./types": 21
  } ],
  12: [ (function(require, module, exports) {
    var AnimationClip = cc.Class({
      name: "cc.AnimationClip",
      extends: cc.Asset,
      properties: {
        _duration: {
          default: 0,
          type: "Float"
        },
        duration: {
          get: function() {
            return this._duration;
          }
        },
        sample: {
          default: 60
        },
        speed: {
          default: 1
        },
        wrapMode: {
          default: cc.WrapMode.Normal
        },
        curveData: {
          default: {},
          visible: false
        },
        events: {
          default: [],
          visible: false
        }
      },
      statics: {
        createWithSpriteFrames: function(spriteFrames, sample) {
          if (!Array.isArray(spriteFrames)) {
            cc.errorID(3905);
            return null;
          }
          var clip = new AnimationClip();
          clip.sample = sample || clip.sample;
          clip._duration = spriteFrames.length / clip.sample;
          var frames = [];
          var step = 1 / clip.sample;
          for (var i = 0, l = spriteFrames.length; i < l; i++) frames[i] = {
            frame: i * step,
            value: spriteFrames[i]
          };
          clip.curveData = {
            comps: {
              "cc.Sprite": {
                spriteFrame: frames
              }
            }
          };
          return clip;
        }
      }
    });
    cc.AnimationClip = module.exports = AnimationClip;
  }), {} ],
  13: [ (function(require, module, exports) {
    var bezierByTime = require("./bezier").bezierByTime;
    var binarySearch = require("../core/utils/binary-search").binarySearchEpsilon;
    var WrapModeMask = require("./types").WrapModeMask;
    var WrappedInfo = require("./types").WrappedInfo;
    function computeRatioByType(ratio, type) {
      if ("string" === typeof type) {
        var func = cc.Easing[type];
        func ? ratio = func(ratio) : cc.errorID(3906, type);
      } else Array.isArray(type) && (ratio = bezierByTime(type, ratio));
      return ratio;
    }
    var AnimCurve = cc.Class({
      name: "cc.AnimCurve",
      sample: function(time, ratio, state) {},
      onTimeChangedManually: void 0
    });
    function quickFindIndex(ratios, ratio) {
      var length = ratios.length - 1;
      if (0 === length) return 0;
      var start = ratios[0];
      if (ratio < start) return 0;
      var end = ratios[length];
      if (ratio > end) return length;
      ratio = (ratio - start) / (end - start);
      var eachLength = 1 / length;
      var index = ratio / eachLength;
      var floorIndex = 0 | index;
      var EPSILON = 1e-6;
      if (index - floorIndex < EPSILON) return floorIndex;
      return ~(floorIndex + 1);
    }
    var DynamicAnimCurve = cc.Class({
      name: "cc.DynamicAnimCurve",
      extends: AnimCurve,
      properties: {
        target: null,
        prop: "",
        values: [],
        ratios: [],
        types: [],
        subProps: null
      },
      _findFrameIndex: binarySearch,
      sample: function(time, ratio, state) {
        var values = this.values;
        var ratios = this.ratios;
        var frameCount = ratios.length;
        if (0 === frameCount) return;
        var value;
        var index = this._findFrameIndex(ratios, ratio);
        if (index < 0) {
          index = ~index;
          if (index <= 0) value = values[0]; else if (index >= frameCount) value = values[frameCount - 1]; else {
            var fromVal = values[index - 1];
            var isNumber = "number" === typeof fromVal;
            var canLerp = fromVal && fromVal.lerp;
            if (isNumber || canLerp) {
              var fromRatio = ratios[index - 1];
              var toRatio = ratios[index];
              var type = this.types[index - 1];
              var ratioBetweenFrames = (ratio - fromRatio) / (toRatio - fromRatio);
              type && (ratioBetweenFrames = computeRatioByType(ratioBetweenFrames, type));
              var toVal = values[index];
              isNumber ? value = fromVal + (toVal - fromVal) * ratioBetweenFrames : canLerp && (value = fromVal.lerp(toVal, ratioBetweenFrames));
            } else value = fromVal;
          }
        } else value = values[index];
        var subProps = this.subProps;
        if (subProps) {
          var mainProp = this.target[this.prop];
          var subProp = mainProp;
          for (var i = 0; i < subProps.length - 1; i++) {
            var subPropName = subProps[i];
            if (!subProp) return;
            subProp = subProp[subPropName];
          }
          var propName = subProps[subProps.length - 1];
          if (!subProp) return;
          subProp[propName] = value;
          value = mainProp;
        }
        this.target[this.prop] = value;
      }
    });
    DynamicAnimCurve.Linear = null;
    DynamicAnimCurve.Bezier = function(controlPoints) {
      return controlPoints;
    };
    var EventInfo = function() {
      this.events = [];
    };
    EventInfo.prototype.add = function(func, params) {
      this.events.push({
        func: func || "",
        params: params || []
      });
    };
    var EventAnimCurve = cc.Class({
      name: "cc.EventAnimCurve",
      extends: AnimCurve,
      properties: {
        target: null,
        ratios: [],
        events: [],
        _wrappedInfo: {
          default: function() {
            return new WrappedInfo();
          }
        },
        _lastWrappedInfo: null,
        _ignoreIndex: NaN
      },
      _wrapIterations: function(iterations) {
        iterations - (0 | iterations) === 0 && (iterations -= 1);
        return 0 | iterations;
      },
      sample: function(time, ratio, state) {
        var length = this.ratios.length;
        var currentWrappedInfo = state.getWrappedInfo(state.time, this._wrappedInfo);
        var direction = currentWrappedInfo.direction;
        var currentIndex = binarySearch(this.ratios, currentWrappedInfo.ratio);
        if (currentIndex < 0) {
          currentIndex = ~currentIndex - 1;
          direction < 0 && (currentIndex += 1);
        }
        this._ignoreIndex !== currentIndex && (this._ignoreIndex = NaN);
        currentWrappedInfo.frameIndex = currentIndex;
        if (!this._lastWrappedInfo) {
          this._fireEvent(currentIndex);
          this._lastWrappedInfo = new WrappedInfo(currentWrappedInfo);
          return;
        }
        var wrapMode = state.wrapMode;
        var currentIterations = this._wrapIterations(currentWrappedInfo.iterations);
        var lastWrappedInfo = this._lastWrappedInfo;
        var lastIterations = this._wrapIterations(lastWrappedInfo.iterations);
        var lastIndex = lastWrappedInfo.frameIndex;
        var lastDirection = lastWrappedInfo.direction;
        var interationsChanged = -1 !== lastIterations && currentIterations !== lastIterations;
        if (lastIndex === currentIndex && interationsChanged && 1 === length) this._fireEvent(0); else if (lastIndex !== currentIndex || interationsChanged) {
          direction = lastDirection;
          do {
            if (lastIndex !== currentIndex) {
              if (-1 === direction && 0 === lastIndex && currentIndex > 0) {
                (wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong ? direction *= -1 : lastIndex = length;
                lastIterations++;
              } else if (1 === direction && lastIndex === length - 1 && currentIndex < length - 1) {
                (wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong ? direction *= -1 : lastIndex = -1;
                lastIterations++;
              }
              if (lastIndex === currentIndex) break;
              if (lastIterations > currentIterations) break;
            }
            lastIndex += direction;
            cc.director.getAnimationManager().pushDelayEvent(this, "_fireEvent", [ lastIndex ]);
          } while (lastIndex !== currentIndex && lastIndex > -1 && lastIndex < length);
        }
        this._lastWrappedInfo.set(currentWrappedInfo);
      },
      _fireEvent: function(index) {
        if (index < 0 || index >= this.events.length || this._ignoreIndex === index) return;
        var eventInfo = this.events[index];
        var events = eventInfo.events;
        if (!this.target.isValid) return;
        var components = this.target._components;
        for (var i = 0; i < events.length; i++) {
          var event = events[i];
          var funcName = event.func;
          for (var j = 0; j < components.length; j++) {
            var component = components[j];
            var func = component[funcName];
            func && func.apply(component, event.params);
          }
        }
      },
      onTimeChangedManually: function(time, state) {
        this._lastWrappedInfo = null;
        this._ignoreIndex = NaN;
        var info = state.getWrappedInfo(time, this._wrappedInfo);
        var direction = info.direction;
        var frameIndex = binarySearch(this.ratios, info.ratio);
        if (frameIndex < 0) {
          frameIndex = ~frameIndex - 1;
          direction < 0 && (frameIndex += 1);
          this._ignoreIndex = frameIndex;
        }
      }
    });
    false;
    module.exports = {
      AnimCurve: AnimCurve,
      DynamicAnimCurve: DynamicAnimCurve,
      EventAnimCurve: EventAnimCurve,
      EventInfo: EventInfo,
      computeRatioByType: computeRatioByType,
      quickFindIndex: quickFindIndex
    };
  }), {
    "../core/utils/binary-search": 221,
    "./bezier": 16,
    "./types": 21
  } ],
  14: [ (function(require, module, exports) {
    var JS = cc.js;
    var AnimationManager = cc.Class({
      ctor: function() {
        this.__instanceId = cc.ClassManager.getNewInstanceId();
        this._anims = new JS.array.MutableForwardIterator([]);
        this._delayEvents = [];
      },
      update: function(dt) {
        var iterator = this._anims;
        var array = iterator.array;
        for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
          var anim = array[iterator.i];
          anim._isPlaying && !anim._isPaused && anim.update(dt);
        }
        var events = this._delayEvents;
        for (i = 0, l = events.length; i < l; i++) {
          var event = events[i];
          event.target[event.func].apply(event.target, event.args);
        }
        events.length = 0;
      },
      destruct: function() {},
      addAnimation: function(anim) {
        var index = this._anims.array.indexOf(anim);
        -1 === index && this._anims.push(anim);
      },
      removeAnimation: function(anim) {
        var index = this._anims.array.indexOf(anim);
        index >= 0 ? this._anims.fastRemoveAt(index) : cc.errorID(3907);
      },
      pushDelayEvent: function(target, func, args) {
        this._delayEvents.push({
          target: target,
          func: func,
          args: args
        });
      }
    });
    cc.AnimationManager = module.exports = AnimationManager;
  }), {} ],
  15: [ (function(require, module, exports) {
    var JS = cc.js;
    var Playable = require("./playable");
    var Types = require("./types");
    var WrappedInfo = Types.WrappedInfo;
    var WrapMode = Types.WrapMode;
    var WrapModeMask = Types.WrapModeMask;
    function AnimationState(clip, name) {
      Playable.call(this);
      cc.EventTarget.call(this);
      this._firstFramePlayed = false;
      this._delay = 0;
      this._delayTime = 0;
      this._wrappedInfo = new WrappedInfo();
      this._lastWrappedInfo = null;
      this._process = process;
      this._clip = clip;
      this._name = name || clip && clip.name;
      this.animator = null;
      this.curves = [];
      this.delay = 0;
      this.repeatCount = 1;
      this.duration = 1;
      this.speed = 1;
      this.wrapMode = WrapMode.Normal;
      this.time = 0;
      this._emit = this.emit;
      this.emit = function() {
        var args = new Array(arguments.length);
        for (var i = 0, l = args.length; i < l; i++) args[i] = arguments[i];
        cc.director.getAnimationManager().pushDelayEvent(this, "_emit", args);
      };
    }
    JS.extend(AnimationState, Playable);
    var proto = AnimationState.prototype;
    cc.js.mixin(proto, cc.EventTarget.prototype);
    proto._setListeners = function(target) {
      this._capturingListeners = target ? target._capturingListeners : null;
      this._bubblingListeners = target ? target._bubblingListeners : null;
      this._hasListenerCache = target ? target._hasListenerCache : null;
    };
    proto.onPlay = function() {
      this.setTime(0);
      this._delayTime = this._delay;
      cc.director.getAnimationManager().addAnimation(this);
      this.animator && this.animator.addAnimation(this);
      this.emit("play", this);
    };
    proto.onStop = function() {
      this.isPaused || cc.director.getAnimationManager().removeAnimation(this);
      this.animator && this.animator.removeAnimation(this);
      this.emit("stop", this);
    };
    proto.onResume = function() {
      cc.director.getAnimationManager().addAnimation(this);
      this.emit("resume", this);
    };
    proto.onPause = function() {
      cc.director.getAnimationManager().removeAnimation(this);
      this.emit("pause", this);
    };
    proto.setTime = function(time) {
      this.time = time || 0;
      var curves = this.curves;
      for (var i = 0, l = curves.length; i < l; i++) {
        var curve = curves[i];
        curve.onTimeChangedManually && curve.onTimeChangedManually(time, this);
      }
    };
    function process() {
      var info = this.sample();
      var cache = this._hasListenerCache;
      if (cache && cache["lastframe"]) {
        var lastInfo;
        lastInfo || (lastInfo = this._lastWrappedInfo = new WrappedInfo(info));
        this.repeatCount > 1 && (0 | info.iterations) > (0 | lastInfo.iterations) && ((this.wrapMode & WrapModeMask.Reverse) === WrapModeMask.Reverse ? lastInfo.direction < 0 && this.emit("lastframe", this) : lastInfo.direction > 0 && this.emit("lastframe", this));
        lastInfo.set(info);
      }
      if (info.stopped) {
        this.stop();
        this.emit("finished", this);
      }
    }
    function simpleProcess() {
      var time = this.time;
      var duration = this.duration;
      if (time > duration) {
        time %= duration;
        0 === time && (time = duration);
      } else if (time < 0) {
        time %= duration;
        0 !== time && (time += duration);
      }
      var ratio = time / duration;
      var curves = this.curves;
      for (var i = 0, len = curves.length; i < len; i++) {
        var curve = curves[i];
        curve.sample(time, ratio, this);
      }
      var cache = this._hasListenerCache;
      if (cache && cache["lastframe"]) {
        var currentIterations = time > 0 ? time / duration : -time / duration;
        var lastIterations = this._lastIterations;
        void 0 === lastIterations && (lastIterations = this._lastIterations = currentIterations);
        (0 | currentIterations) > (0 | lastIterations) && this.emit("lastframe", this);
        this._lastIterations = currentIterations;
      }
    }
    proto.update = function(delta) {
      if (this._delayTime > 0) {
        this._delayTime -= delta;
        if (this._delayTime > 0) return;
      }
      this._firstFramePlayed ? this.time += delta * this.speed : this._firstFramePlayed = true;
      this._process();
    };
    proto._needRevers = function(currentIterations) {
      var wrapMode = this.wrapMode;
      var needRevers = false;
      if ((wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong) {
        var isEnd = currentIterations - (0 | currentIterations) === 0;
        isEnd && currentIterations > 0 && (currentIterations -= 1);
        var isOddIteration = 1 & currentIterations;
        isOddIteration && (needRevers = !needRevers);
      }
      (wrapMode & WrapModeMask.Reverse) === WrapModeMask.Reverse && (needRevers = !needRevers);
      return needRevers;
    };
    proto.getWrappedInfo = function(time, info) {
      info = info || new WrappedInfo();
      var stopped = false;
      var duration = this.duration;
      var repeatCount = this.repeatCount;
      var currentIterations = time > 0 ? time / duration : -time / duration;
      if (currentIterations >= repeatCount) {
        currentIterations = repeatCount;
        stopped = true;
        var tempRatio = repeatCount - (0 | repeatCount);
        0 === tempRatio && (tempRatio = 1);
        time = tempRatio * duration * (time > 0 ? 1 : -1);
      }
      if (time > duration) {
        var tempTime = time % duration;
        time = 0 === tempTime ? duration : tempTime;
      } else if (time < 0) {
        time %= duration;
        0 !== time && (time += duration);
      }
      var needRevers = false;
      var shouldWrap = this._wrapMode & WrapModeMask.ShouldWrap;
      shouldWrap && (needRevers = this._needRevers(currentIterations));
      var direction = needRevers ? -1 : 1;
      this.speed < 0 && (direction *= -1);
      shouldWrap && needRevers && (time = duration - time);
      info.ratio = time / duration;
      info.time = time;
      info.direction = direction;
      info.stopped = stopped;
      info.iterations = currentIterations;
      return info;
    };
    proto.sample = function() {
      var info = this.getWrappedInfo(this.time, this._wrappedInfo);
      var curves = this.curves;
      for (var i = 0, len = curves.length; i < len; i++) {
        var curve = curves[i];
        curve.sample(info.time, info.ratio, this);
      }
      return info;
    };
    JS.get(proto, "clip", (function() {
      return this._clip;
    }));
    JS.get(proto, "name", (function() {
      return this._name;
    }));
    JS.obsolete(proto, "AnimationState.length", "duration");
    JS.getset(proto, "curveLoaded", (function() {
      return this.curves.length > 0;
    }), (function() {
      this.curves.length = 0;
    }));
    JS.getset(proto, "wrapMode", (function() {
      return this._wrapMode;
    }), (function(value) {
      this._wrapMode = value;
      false;
      this.time = 0;
      value & WrapModeMask.Loop ? this.repeatCount = Infinity : this.repeatCount = 1;
    }));
    JS.getset(proto, "repeatCount", (function() {
      return this._repeatCount;
    }), (function(value) {
      this._repeatCount = value;
      var shouldWrap = this._wrapMode & WrapModeMask.ShouldWrap;
      var reverse = (this.wrapMode & WrapModeMask.Reverse) === WrapModeMask.Reverse;
      this._process = Infinity !== value || shouldWrap || reverse ? process : simpleProcess;
    }));
    JS.getset(proto, "delay", (function() {
      return this._delay;
    }), (function(value) {
      this._delayTime = this._delay = value;
    }));
    cc.AnimationState = module.exports = AnimationState;
  }), {
    "./playable": 20,
    "./types": 21
  } ],
  16: [ (function(require, module, exports) {
    function bezier(C1, C2, C3, C4, t) {
      var t1 = 1 - t;
      return C1 * t1 * t1 * t1 + 3 * C2 * t1 * t1 * t + 3 * C3 * t1 * t * t + C4 * t * t * t;
    }
    var cos = Math.cos, acos = Math.acos, max = Math.max, pi = Math.PI, tau = 2 * pi, sqrt = Math.sqrt;
    function crt(v) {
      return v < 0 ? -Math.pow(-v, 1 / 3) : Math.pow(v, 1 / 3);
    }
    function cardano(curve, x) {
      var pa = x - 0;
      var pb = x - curve[0];
      var pc = x - curve[2];
      var pd = x - 1;
      var pa3 = 3 * pa;
      var pb3 = 3 * pb;
      var pc3 = 3 * pc;
      var d = -pa + pb3 - pc3 + pd, rd = 1 / d, r3 = 1 / 3, a = (pa3 - 6 * pb + pc3) * rd, a3 = a * r3, b = (-pa3 + pb3) * rd, c = pa * rd, p = (3 * b - a * a) * r3, p3 = p * r3, q = (2 * a * a * a - 9 * a * b + 27 * c) / 27, q2 = q / 2, discriminant = q2 * q2 + p3 * p3 * p3, u1, v1, x1, x2, x3;
      if (discriminant < 0) {
        var mp3 = -p * r3, mp33 = mp3 * mp3 * mp3, r = sqrt(mp33), t = -q / (2 * r), cosphi = t < -1 ? -1 : t > 1 ? 1 : t, phi = acos(cosphi), crtr = crt(r), t1 = 2 * crtr;
        x1 = t1 * cos(phi * r3) - a3;
        x2 = t1 * cos((phi + tau) * r3) - a3;
        x3 = t1 * cos((phi + 2 * tau) * r3) - a3;
        return 0 <= x1 && x1 <= 1 ? 0 <= x2 && x2 <= 1 ? 0 <= x3 && x3 <= 1 ? max(x1, x2, x3) : max(x1, x2) : 0 <= x3 && x3 <= 1 ? max(x1, x3) : x1 : 0 <= x2 && x2 <= 1 ? 0 <= x3 && x3 <= 1 ? max(x2, x3) : x2 : x3;
      }
      if (0 === discriminant) {
        u1 = q2 < 0 ? crt(-q2) : -crt(q2);
        x1 = 2 * u1 - a3;
        x2 = -u1 - a3;
        return 0 <= x1 && x1 <= 1 ? 0 <= x2 && x2 <= 1 ? max(x1, x2) : x1 : x2;
      }
      var sd = sqrt(discriminant);
      u1 = crt(-q2 + sd);
      v1 = crt(q2 + sd);
      x1 = u1 - v1 - a3;
      return x1;
    }
    function bezierByTime(controlPoints, x) {
      var percent = cardano(controlPoints, x);
      var p0y = 0;
      var p1y = controlPoints[1];
      var p2y = controlPoints[3];
      var p3y = 1;
      var t1 = 1 - percent;
      return p0y * t1 * t1 * t1 + 3 * p1y * percent * t1 * t1 + 3 * p2y * percent * percent * t1 + p3y * percent * percent * percent;
    }
    false;
    module.exports = {
      bezier: bezier,
      bezierByTime: bezierByTime
    };
  }), {} ],
  17: [ (function(require, module, exports) {
    var Easing = {
      constant: function() {
        return 0;
      },
      linear: function(k) {
        return k;
      },
      quadIn: function(k) {
        return k * k;
      },
      quadOut: function(k) {
        return k * (2 - k);
      },
      quadInOut: function(k) {
        if ((k *= 2) < 1) return .5 * k * k;
        return -.5 * (--k * (k - 2) - 1);
      },
      cubicIn: function(k) {
        return k * k * k;
      },
      cubicOut: function(k) {
        return --k * k * k + 1;
      },
      cubicInOut: function(k) {
        if ((k *= 2) < 1) return .5 * k * k * k;
        return .5 * ((k -= 2) * k * k + 2);
      },
      quartIn: function(k) {
        return k * k * k * k;
      },
      quartOut: function(k) {
        return 1 - --k * k * k * k;
      },
      quartInOut: function(k) {
        if ((k *= 2) < 1) return .5 * k * k * k * k;
        return -.5 * ((k -= 2) * k * k * k - 2);
      },
      quintIn: function(k) {
        return k * k * k * k * k;
      },
      quintOut: function(k) {
        return --k * k * k * k * k + 1;
      },
      quintInOut: function(k) {
        if ((k *= 2) < 1) return .5 * k * k * k * k * k;
        return .5 * ((k -= 2) * k * k * k * k + 2);
      },
      sineIn: function(k) {
        return 1 - Math.cos(k * Math.PI / 2);
      },
      sineOut: function(k) {
        return Math.sin(k * Math.PI / 2);
      },
      sineInOut: function(k) {
        return .5 * (1 - Math.cos(Math.PI * k));
      },
      expoIn: function(k) {
        return 0 === k ? 0 : Math.pow(1024, k - 1);
      },
      expoOut: function(k) {
        return 1 === k ? 1 : 1 - Math.pow(2, -10 * k);
      },
      expoInOut: function(k) {
        if (0 === k) return 0;
        if (1 === k) return 1;
        if ((k *= 2) < 1) return .5 * Math.pow(1024, k - 1);
        return .5 * (2 - Math.pow(2, -10 * (k - 1)));
      },
      circIn: function(k) {
        return 1 - Math.sqrt(1 - k * k);
      },
      circOut: function(k) {
        return Math.sqrt(1 - --k * k);
      },
      circInOut: function(k) {
        if ((k *= 2) < 1) return -.5 * (Math.sqrt(1 - k * k) - 1);
        return .5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
      },
      elasticIn: function(k) {
        var s, a = .1, p = .4;
        if (0 === k) return 0;
        if (1 === k) return 1;
        if (!a || a < 1) {
          a = 1;
          s = p / 4;
        } else s = p * Math.asin(1 / a) / (2 * Math.PI);
        return -a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p);
      },
      elasticOut: function(k) {
        var s, a = .1, p = .4;
        if (0 === k) return 0;
        if (1 === k) return 1;
        if (!a || a < 1) {
          a = 1;
          s = p / 4;
        } else s = p * Math.asin(1 / a) / (2 * Math.PI);
        return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
      },
      elasticInOut: function(k) {
        var s, a = .1, p = .4;
        if (0 === k) return 0;
        if (1 === k) return 1;
        if (!a || a < 1) {
          a = 1;
          s = p / 4;
        } else s = p * Math.asin(1 / a) / (2 * Math.PI);
        if ((k *= 2) < 1) return a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * -.5;
        return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * .5 + 1;
      },
      backIn: function(k) {
        var s = 1.70158;
        return k * k * ((s + 1) * k - s);
      },
      backOut: function(k) {
        var s = 1.70158;
        return --k * k * ((s + 1) * k + s) + 1;
      },
      backInOut: function(k) {
        var s = 2.5949095;
        if ((k *= 2) < 1) return k * k * ((s + 1) * k - s) * .5;
        return .5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
      },
      bounceOut: function(k) {
        return k < 1 / 2.75 ? 7.5625 * k * k : k < 2 / 2.75 ? 7.5625 * (k -= 1.5 / 2.75) * k + .75 : k < 2.5 / 2.75 ? 7.5625 * (k -= 2.25 / 2.75) * k + .9375 : 7.5625 * (k -= 2.625 / 2.75) * k + .984375;
      },
      smooth: function(t) {
        if (t <= 0) return 0;
        if (t >= 1) return 1;
        return t * t * (3 - 2 * t);
      },
      fade: function(t) {
        if (t <= 0) return 0;
        if (t >= 1) return 1;
        return t * t * t * (t * (6 * t - 15) + 10);
      }
    };
    function _makeOutIn(fnIn, fnOut) {
      return function(k) {
        if (k < .5) return fnOut(2 * k) / 2;
        return fnIn(2 * k - 1) / 2 + .5;
      };
    }
    Easing.quadOutIn = _makeOutIn(Easing.quadIn, Easing.quadOut);
    Easing.cubicOutIn = _makeOutIn(Easing.cubicIn, Easing.cubicOut);
    Easing.quartOutIn = _makeOutIn(Easing.quartIn, Easing.quartOut);
    Easing.quintOutIn = _makeOutIn(Easing.quintIn, Easing.quintOut);
    Easing.sineOutIn = _makeOutIn(Easing.sineIn, Easing.sineOut);
    Easing.expoOutIn = _makeOutIn(Easing.expoIn, Easing.expoOut);
    Easing.circOutIn = _makeOutIn(Easing.circIn, Easing.circOut);
    Easing.backOutIn = _makeOutIn(Easing.backIn, Easing.backOut);
    Easing.backOutIn = _makeOutIn(Easing.backIn, Easing.backOut);
    Easing.bounceIn = function(k) {
      return 1 - Easing.bounceOut(1 - k);
    };
    Easing.bounceInOut = function(k) {
      if (k < .5) return .5 * Easing.bounceIn(2 * k);
      return .5 * Easing.bounceOut(2 * k - 1) + .5;
    };
    Easing.bounceOutIn = _makeOutIn(Easing.bounceIn, Easing.bounceOut);
    cc.Easing = module.exports = Easing;
  }), {} ],
  18: [ (function(require, module, exports) {
    require("./bezier");
    require("./easing");
    require("./types");
    require("./motion-path-helper");
    require("./animation-curves");
    require("./animation-clip");
    require("./animation-manager");
    require("./animation-state");
    require("./animation-animator");
  }), {
    "./animation-animator": 11,
    "./animation-clip": 12,
    "./animation-curves": 13,
    "./animation-manager": 14,
    "./animation-state": 15,
    "./bezier": 16,
    "./easing": 17,
    "./motion-path-helper": 19,
    "./types": 21
  } ],
  19: [ (function(require, module, exports) {
    var DynamicAnimCurve = require("./animation-curves").DynamicAnimCurve;
    var computeRatioByType = require("./animation-curves").computeRatioByType;
    var bezier = require("./bezier").bezier;
    var binarySearch = require("../core/utils/binary-search").binarySearchEpsilon;
    var v2 = cc.v2;
    function Curve(points) {
      this.points = points || [];
      this.beziers = [];
      this.ratios = [];
      this.progresses = [];
      this.length = 0;
      this.computeBeziers();
    }
    Curve.prototype.computeBeziers = function() {
      this.beziers.length = 0;
      this.ratios.length = 0;
      this.progresses.length = 0;
      this.length = 0;
      var bezier;
      for (var i = 1; i < this.points.length; i++) {
        var startPoint = this.points[i - 1];
        var endPoint = this.points[i];
        bezier = new Bezier();
        bezier.start = startPoint.pos;
        bezier.startCtrlPoint = startPoint.out;
        bezier.end = endPoint.pos;
        bezier.endCtrlPoint = endPoint.in;
        this.beziers.push(bezier);
        this.length += bezier.getLength();
      }
      var current = 0;
      for (var i = 0; i < this.beziers.length; i++) {
        bezier = this.beziers[i];
        this.ratios[i] = bezier.getLength() / this.length;
        this.progresses[i] = current += this.ratios[i];
      }
      return this.beziers;
    };
    function Bezier() {
      this.start = v2();
      this.end = v2();
      this.startCtrlPoint = v2();
      this.endCtrlPoint = v2();
    }
    Bezier.prototype.getPointAt = function(u) {
      var t = this.getUtoTmapping(u);
      return this.getPoint(t);
    };
    Bezier.prototype.getPoint = function(t) {
      var x = bezier(this.start.x, this.startCtrlPoint.x, this.endCtrlPoint.x, this.end.x, t);
      var y = bezier(this.start.y, this.startCtrlPoint.y, this.endCtrlPoint.y, this.end.y, t);
      return new v2(x, y);
    };
    Bezier.prototype.getLength = function() {
      var lengths = this.getLengths();
      return lengths[lengths.length - 1];
    };
    Bezier.prototype.getLengths = function(divisions) {
      divisions || (divisions = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200);
      if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1) return this.cacheArcLengths;
      var cache = [];
      var current, last = this.getPoint(0);
      var p, sum = 0;
      cache.push(0);
      for (p = 1; p <= divisions; p++) {
        current = this.getPoint(p / divisions);
        sum += cc.pDistance(current, last);
        cache.push(sum);
        last = current;
      }
      this.cacheArcLengths = cache;
      return cache;
    };
    Bezier.prototype.getUtoTmapping = function(u, distance) {
      var arcLengths = this.getLengths();
      var i = 0, il = arcLengths.length;
      var targetArcLength;
      targetArcLength = distance || u * arcLengths[il - 1];
      var low = 0, high = il - 1, comparison;
      while (low <= high) {
        i = Math.floor(low + (high - low) / 2);
        comparison = arcLengths[i] - targetArcLength;
        if (comparison < 0) {
          low = i + 1;
          continue;
        }
        if (comparison > 0) {
          high = i - 1;
          continue;
        }
        high = i;
        break;
      }
      i = high;
      if (arcLengths[i] === targetArcLength) {
        var t = i / (il - 1);
        return t;
      }
      var lengthBefore = arcLengths[i];
      var lengthAfter = arcLengths[i + 1];
      var segmentLength = lengthAfter - lengthBefore;
      var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
      var t = (i + segmentFraction) / (il - 1);
      return t;
    };
    function sampleMotionPaths(motionPaths, data, duration, fps) {
      function createControlPoints(array) {
        if (array instanceof cc.Vec2) return {
          in: array,
          pos: array,
          out: array
        };
        if (Array.isArray(array) && 6 === array.length) return {
          in: v2(array[2], array[3]),
          pos: v2(array[0], array[1]),
          out: v2(array[4], array[5])
        };
        return {
          in: cc.Vec2.ZERO,
          pos: cc.Vec2.ZERO,
          out: cc.Vec2.ZERO
        };
      }
      var values = data.values;
      if (0 === motionPaths.length || 0 === values.length) return;
      values = values.map((function(value) {
        return v2(value[0], value[1]);
      }));
      if (1 === values.length) {
        data.values = values;
        return;
      }
      var types = data.types;
      var ratios = data.ratios;
      var newValues = data.values = [];
      var newTypes = data.types = [];
      var newRatios = data.ratios = [];
      function addNewDatas(value, type, ratio) {
        newValues.push(value);
        newTypes.push(type);
        newRatios.push(ratio);
      }
      var startRatioOffset = 0;
      var EPSILON = 1e-6;
      var newType = DynamicAnimCurve.Linear;
      for (var i = 0, l = motionPaths.length; i < l - 1; i++) {
        var motionPath = motionPaths[i];
        var ratio = ratios[i];
        var nextRatio = ratios[i + 1];
        var betweenRatio = nextRatio - ratio;
        var value = values[i];
        var nextValue = values[i + 1];
        var type = types[i];
        var results = [];
        var progress = startRatioOffset / betweenRatio;
        var speed = 1 / (betweenRatio * duration * fps);
        var finalProgress;
        if (motionPath && motionPath.length > 0) {
          var points = [];
          points.push(createControlPoints(value));
          for (var j = 0, l2 = motionPath.length; j < l2; j++) {
            var controlPoints = createControlPoints(motionPath[j]);
            points.push(controlPoints);
          }
          points.push(createControlPoints(nextValue));
          var curve = new Curve(points);
          curve.computeBeziers();
          var progresses = curve.progresses;
          while (1 - progress > EPSILON) {
            finalProgress = progress;
            finalProgress = computeRatioByType(finalProgress, type);
            var pos, bezier, normal, length;
            if (finalProgress < 0) {
              bezier = curve.beziers[0];
              length = (0 - finalProgress) * bezier.getLength();
              normal = bezier.start.sub(bezier.endCtrlPoint).normalize();
              pos = bezier.start.add(normal.mul(length));
            } else if (finalProgress > 1) {
              bezier = curve.beziers[curve.beziers.length - 1];
              length = (finalProgress - 1) * bezier.getLength();
              normal = bezier.end.sub(bezier.startCtrlPoint).normalize();
              pos = bezier.end.add(normal.mul(length));
            } else {
              var bezierIndex = binarySearch(progresses, finalProgress);
              bezierIndex < 0 && (bezierIndex = ~bezierIndex);
              finalProgress -= bezierIndex > 0 ? progresses[bezierIndex - 1] : 0;
              finalProgress /= curve.ratios[bezierIndex];
              pos = curve.beziers[bezierIndex].getPointAt(finalProgress);
            }
            results.push(pos);
            progress += speed;
          }
        } else while (1 - progress > EPSILON) {
          finalProgress = progress;
          finalProgress = computeRatioByType(finalProgress, type);
          results.push(value.lerp(nextValue, finalProgress));
          progress += speed;
        }
        newType = "constant" === type ? type : DynamicAnimCurve.Linear;
        for (var j = 0, l2 = results.length; j < l2; j++) {
          var newRatio = ratio + startRatioOffset + speed * j * betweenRatio;
          addNewDatas(results[j], newType, newRatio);
        }
        startRatioOffset = Math.abs(progress - 1) > EPSILON ? (progress - 1) * betweenRatio : 0;
      }
      ratios[ratios.length - 1] !== newRatios[newRatios.length - 1] && addNewDatas(values[values.length - 1], newType, ratios[ratios.length - 1]);
    }
    false;
    module.exports = {
      sampleMotionPaths: sampleMotionPaths,
      Curve: Curve,
      Bezier: Bezier
    };
  }), {
    "../core/utils/binary-search": 221,
    "./animation-curves": 13,
    "./bezier": 16
  } ],
  20: [ (function(require, module, exports) {
    var JS = cc.js;
    function Playable() {
      this._isPlaying = false;
      this._isPaused = false;
      this._stepOnce = false;
    }
    var prototype = Playable.prototype;
    JS.get(prototype, "isPlaying", (function() {
      return this._isPlaying;
    }), true);
    JS.get(prototype, "isPaused", (function() {
      return this._isPaused;
    }), true);
    var virtual = function() {};
    prototype.onPlay = virtual;
    prototype.onPause = virtual;
    prototype.onResume = virtual;
    prototype.onStop = virtual;
    prototype.onError = virtual;
    prototype.play = function() {
      if (this._isPlaying) if (this._isPaused) {
        this._isPaused = false;
        this.onResume();
      } else this.onError("already-playing"); else {
        this._isPlaying = true;
        this.onPlay();
      }
    };
    prototype.stop = function() {
      if (this._isPlaying) {
        this._isPlaying = false;
        this.onStop();
        this._isPaused = false;
      }
    };
    prototype.pause = function() {
      if (this._isPlaying && !this._isPaused) {
        this._isPaused = true;
        this.onPause();
      }
    };
    prototype.resume = function() {
      if (this._isPlaying && this._isPaused) {
        this._isPaused = false;
        this.onResume();
      }
    };
    prototype.step = function() {
      this.pause();
      this._stepOnce = true;
      this._isPlaying || this.play();
    };
    module.exports = Playable;
  }), {} ],
  21: [ (function(require, module, exports) {
    var JS = cc.js;
    var WrapModeMask = {
      Loop: 2,
      ShouldWrap: 4,
      PingPong: 22,
      Reverse: 36
    };
    var WrapMode = cc.Enum({
      Default: 0,
      Normal: 1,
      Reverse: WrapModeMask.Reverse,
      Loop: WrapModeMask.Loop,
      LoopReverse: WrapModeMask.Loop | WrapModeMask.Reverse,
      PingPong: WrapModeMask.PingPong,
      PingPongReverse: WrapModeMask.PingPong | WrapModeMask.Reverse
    });
    cc.WrapMode = WrapMode;
    function WrappedInfo(info) {
      if (info) {
        this.set(info);
        return;
      }
      this.ratio = 0;
      this.time = 0;
      this.direction = 1;
      this.stopped = true;
      this.iterations = 0;
      this.frameIndex = void 0;
    }
    WrappedInfo.prototype.set = function(info) {
      this.ratio = info.ratio;
      this.time = info.time;
      this.direction = info.direction;
      this.stopped = info.stopped;
      this.iterations = info.iterations;
      this.frameIndex = info.frameIndex;
    };
    module.exports = {
      WrapModeMask: WrapModeMask,
      WrapMode: WrapMode,
      WrappedInfo: WrappedInfo
    };
  }), {} ],
  22: [ (function(require, module, exports) {
    var EventTarget = require("../core/event/event-target");
    var sys = require("../core/platform/CCSys");
    var touchBinded = false;
    var touchPlayList = [];
    var Audio = function(src) {
      EventTarget.call(this);
      this._src = src;
      this._audioType = Audio.Type.UNKNOWN;
      this._element = null;
      this._eventList = {};
      this._state = Audio.State.INITIALZING;
      this._loaded = false;
      this._onended = function() {
        this.emit("ended");
      }.bind(this);
    };
    cc.js.extend(Audio, EventTarget);
    Audio.Type = {
      DOM: "AUDIO",
      WEBAUDIO: "WEBAUDIO",
      NATIVE: "NATIVE",
      UNKNOWN: "UNKNOWN"
    };
    Audio.State = {
      ERROR: -1,
      INITIALZING: 0,
      PLAYING: 1,
      PAUSED: 2
    };
    (function(proto) {
      proto.preload = function() {
        var src = this._src, audio = this;
        if (!src) {
          this._src = "";
          this._audioType = Audio.Type.UNKNOWN;
          this._element = null;
          this._state = Audio.State.INITIALZING;
          this._loaded = false;
          return;
        }
        var item = cc.loader.getItem(src);
        item || (item = cc.loader.getItem(src + "?useDom=1"));
        if (!item) return cc.loader.load(src, (function(error) {
          if (!error) {
            var item = cc.loader.getItem(src);
            audio.mount(item.element || item.buffer);
            audio.emit("load");
          }
        }));
        if (item.complete) {
          audio.mount(item.element || item.buffer);
          audio.emit("load");
        }
      };
      proto._bindEnded = function(callback) {
        callback = callback || this._onended;
        this._audioType === Audio.Type.DOM ? this._element.addEventListener("ended", callback) : this._element.onended = callback;
      };
      proto._unbindEnded = function() {
        this._audioType === Audio.Type.DOM ? this._element.removeEventListener("ended", this._onended) : this._element.onended = null;
      };
      proto.mount = function(elem) {
        if (sys.platform === sys.WECHAT_GAME || elem instanceof HTMLElement) {
          this._element = document.createElement("audio");
          this._element.src = elem.src;
          this._audioType = Audio.Type.DOM;
        } else {
          this._element = new WebAudioElement(elem, this);
          this._audioType = Audio.Type.WEBAUDIO;
        }
        this._state = Audio.State.INITIALZING;
        this._loaded = true;
      };
      proto.play = function() {
        if (!this._element) return;
        this._bindEnded();
        this._element.play();
        this.emit("play");
        this._state = Audio.State.PLAYING;
        sys.platform !== sys.WECHAT_GAME && this._audioType === Audio.Type.DOM && this._element.paused && touchPlayList.push({
          instance: this,
          offset: 0,
          audio: this._element
        });
        if (touchBinded) return;
        touchBinded = true;
        cc.game.canvas.addEventListener("touchstart", (function() {
          var item;
          while (item = touchPlayList.pop()) item.audio.play(item.offset);
        }));
      };
      proto.pause = function() {
        if (!this._element) return;
        this._unbindEnded();
        this._element.pause();
        this.emit("pause");
        this._state = Audio.State.PAUSED;
      };
      proto.resume = function() {
        if (!this._element || 0 === this._element.currentTime) return;
        this._bindEnded();
        this._element.play();
        this.emit("resume");
        this._state = Audio.State.PLAYING;
      };
      proto.stop = function() {
        if (!this._element) return;
        try {
          this._element.currentTime = 0;
        } catch (error) {}
        this._element.pause();
        for (var i = 0; i < touchPlayList.length; i++) if (touchPlayList[i].instance === this) {
          touchPlayList.splice(i, 1);
          break;
        }
        this._unbindEnded();
        this.emit("stop");
        this._state = Audio.State.PAUSED;
      };
      proto.setLoop = function(loop) {
        if (!this._element) return;
        this._element.loop = loop;
      };
      proto.getLoop = function() {
        return this._element && this._element.loop;
      };
      proto.setVolume = function(num) {
        if (!this._element) return;
        this._element.volume = num;
      };
      proto.getVolume = function() {
        return this._element ? this._element.volume : 1;
      };
      proto.setCurrentTime = function(num) {
        if (!this._element) return;
        this._unbindEnded();
        sys.platform !== sys.WECHAT_GAME && this._bindEnded(function() {
          this._bindEnded();
        }.bind(this));
        try {
          this._element.currentTime = num;
        } catch (err) {
          var _element = this._element;
          if (_element.addEventListener) {
            var func = function() {
              _element.removeEventListener("loadedmetadata", func);
              _element.currentTime = num;
            };
            _element.addEventListener("loadedmetadata", func);
          }
        }
      };
      proto.getCurrentTime = function() {
        return this._element ? this._element.currentTime : 0;
      };
      proto.getDuration = function() {
        return this._element ? this._element.duration : 0;
      };
      proto.getState = function() {
        var elem = this._element;
        Audio.State.PLAYING === this._state && elem.paused && (this._state = Audio.State.PAUSED);
        return this._state;
      };
      proto.__defineGetter__("src", (function() {
        return this._src;
      }));
      proto.__defineSetter__("src", (function(string) {
        return this._src = string;
      }));
      proto.__defineGetter__("paused", (function() {
        return !this._element || this._element.paused;
      }));
    })(Audio.prototype);
    var WebAudioElement = function(buffer, audio) {
      this._audio = audio;
      this._context = sys.__audioSupport.context;
      this._buffer = buffer;
      this._volume = this._context["createGain"]();
      this._volume["gain"].value = 1;
      this._volume["connect"](this._context["destination"]);
      this._loop = false;
      this._startTime = -1;
      this._currentSource = null;
      this.playedLength = 0;
      this._currextTimer = null;
      this._endCallback = function() {
        this.onended && this.onended(this);
      }.bind(this);
    };
    (function(proto) {
      proto.play = function(offset) {
        if (this._currentSource && !this.paused) {
          this._currentSource.onended = null;
          this._currentSource.stop(0);
          this.playedLength = 0;
        }
        var audio = this._context["createBufferSource"]();
        audio.buffer = this._buffer;
        audio["connect"](this._volume);
        audio.loop = this._loop;
        this._startTime = this._context.currentTime;
        offset = offset || this.playedLength;
        offset && (this._startTime -= offset);
        var duration = this._buffer.duration;
        var startTime = offset;
        var endTime;
        if (this._loop) audio.start ? audio.start(0, startTime) : audio["notoGrainOn"] ? audio["noteGrainOn"](0, startTime) : audio["noteOn"](0, startTime); else {
          endTime = duration - offset;
          audio.start ? audio.start(0, startTime, endTime) : audio["notoGrainOn"] ? audio["noteGrainOn"](0, startTime, endTime) : audio["noteOn"](0, startTime, endTime);
        }
        this._currentSource = audio;
        audio.onended = this._endCallback;
        if ((!audio.context.state || "suspended" === audio.context.state) && 0 === this._context.currentTime) {
          var self = this;
          clearTimeout(this._currextTimer);
          this._currextTimer = setTimeout((function() {
            sys.platform === sys.WECHAT_GAME && 0 === self._context.currentTime && touchPlayList.push({
              instance: self._audio,
              offset: offset,
              audio: self
            });
          }), 10);
        }
      };
      proto.pause = function() {
        clearTimeout(this._currextTimer);
        if (this.paused) return;
        this.playedLength = this._context.currentTime - this._startTime;
        this.playedLength %= this._buffer.duration;
        var audio = this._currentSource;
        this._currentSource = null;
        this._startTime = -1;
        audio && audio.stop(0);
      };
      proto.__defineGetter__("paused", (function() {
        if (this._currentSource && this._currentSource.loop) return false;
        if (-1 === this._startTime) return true;
        return this._context.currentTime - this._startTime > this._buffer.duration;
      }));
      proto.__defineGetter__("loop", (function() {
        return this._loop;
      }));
      proto.__defineSetter__("loop", (function(bool) {
        this._currentSource && (this._currentSource.loop = bool);
        return this._loop = bool;
      }));
      proto.__defineGetter__("volume", (function() {
        return this._volume["gain"].value;
      }));
      proto.__defineSetter__("volume", (function(num) {
        this._volume["gain"].value = num;
        if (sys.os === sys.OS_IOS && !this.paused && this._currentSource) {
          this._currentSource.onended = null;
          this.pause();
          this.play();
        }
        return num;
      }));
      proto.__defineGetter__("currentTime", (function() {
        if (this.paused) return this.playedLength;
        this.playedLength = this._context.currentTime - this._startTime;
        this.playedLength %= this._buffer.duration;
        return this.playedLength;
      }));
      proto.__defineSetter__("currentTime", (function(num) {
        if (this.paused) this.playedLength = num; else {
          this.pause();
          this.playedLength = num;
          this.play();
        }
        return num;
      }));
      proto.__defineGetter__("duration", (function() {
        return this._buffer.duration;
      }));
    })(WebAudioElement.prototype);
    module.exports = cc.Audio = Audio;
  }), {
    "../core/event/event-target": 113,
    "../core/platform/CCSys": 184
  } ],
  23: [ (function(require, module, exports) {
    var Audio = require("./CCAudio");
    var instanceId = 0;
    var id2audio = {};
    var url2id = {};
    var getAudioFromPath = function(path) {
      var id = instanceId++;
      var list = url2id[path];
      list || (list = url2id[path] = []);
      var audio;
      if (audioEngine._maxAudioInstance <= list.length) {
        var oldId = list.shift();
        var oldAudio = id2audio[oldId];
        oldAudio.stop();
      }
      audio = new Audio(path);
      var callback = function() {
        var id = this.instanceId;
        delete id2audio[id];
        var index = list.indexOf(id);
        cc.js.array.fastRemoveAt(list, index);
      };
      audio.on("ended", callback);
      audio.on("stop", callback);
      id2audio[id] = audio;
      audio.instanceId = id;
      list.push(id);
      return audio;
    };
    var getAudioFromId = function(id) {
      return id2audio[id];
    };
    var audioEngine = {
      AudioState: Audio.State,
      _maxWebAudioSize: 2097152,
      _maxAudioInstance: 24,
      _id2audio: id2audio,
      play: function(filePath, loop, volume) {
        if (true, "string" !== typeof filePath) {
          cc.errorID(8400);
          return;
        }
        var audio = getAudioFromPath(filePath);
        var callback = function() {
          audio.setLoop(loop || false);
          ("number" != typeof volume || isNaN(volume)) && (volume = 1);
          audio.setVolume(volume);
          audio.play();
        };
        audio.__callback = callback;
        audio.on("load", callback);
        audio.preload();
        return audio.instanceId;
      },
      setLoop: function(audioID, loop) {
        var audio = getAudioFromId(audioID);
        if (!audio || !audio.setLoop) return;
        audio.setLoop(loop);
      },
      isLoop: function(audioID) {
        var audio = getAudioFromId(audioID);
        if (!audio || !audio.isLoop) return false;
        return audio.isLoop();
      },
      setVolume: function(audioID, volume) {
        var audio = getAudioFromId(audioID);
        if (!audio) return;
        audio._loaded || audio.once("load", (function() {
          audio.setVolume && audio.setVolume(volume);
        }));
        audio.setVolume && audio.setVolume(volume);
      },
      getVolume: function(audioID) {
        var audio = getAudioFromId(audioID);
        if (!audio || !audio.getVolume) return 1;
        return audio.getVolume();
      },
      setCurrentTime: function(audioID, sec) {
        var audio = getAudioFromId(audioID);
        if (!audio) return false;
        if (!audio._loaded) {
          audio.once("load", (function() {
            audio.setCurrentTime && audio.setCurrentTime(sec);
          }));
          return true;
        }
        audio.setCurrentTime && audio.setCurrentTime(sec);
        return true;
      },
      getCurrentTime: function(audioID) {
        var audio = getAudioFromId(audioID);
        if (!audio || !audio.getCurrentTime) return 0;
        return audio.getCurrentTime();
      },
      getDuration: function(audioID) {
        var audio = getAudioFromId(audioID);
        if (!audio || !audio.getDuration) return 0;
        return audio.getDuration();
      },
      getState: function(audioID) {
        var audio = getAudioFromId(audioID);
        if (!audio || !audio.getState) return this.AudioState.ERROR;
        return audio.getState();
      },
      setFinishCallback: function(audioID, callback) {
        var audio = getAudioFromId(audioID);
        if (!audio) return;
        audio.off("ended", audio._finishCallback);
        audio._finishCallback = callback;
        audio.on("ended", audio._finishCallback);
      },
      pause: function(audioID) {
        var audio = getAudioFromId(audioID);
        if (!audio || !audio.pause) return false;
        audio.pause();
        return true;
      },
      _pauseIDCache: [],
      pauseAll: function() {
        for (var id in id2audio) {
          var audio = id2audio[id];
          var state = audio.getState();
          if (state === Audio.State.PLAYING) {
            this._pauseIDCache.push(id);
            audio.pause();
          }
        }
      },
      resume: function(audioID) {
        var audio = getAudioFromId(audioID);
        if (!audio || !audio.resume) return false;
        0 === audio.getCurrentTime() ? audio.play() : audio.resume();
      },
      resumeAll: function() {
        while (this._pauseIDCache.length > 0) {
          var id = this._pauseIDCache.pop();
          var audio = getAudioFromId(id);
          audio && audio.resume && audio.resume();
        }
      },
      stop: function(audioID) {
        var audio = getAudioFromId(audioID);
        if (!audio || !audio.stop) return false;
        audio.off("load", audio.__callback);
        audio.stop();
        return true;
      },
      stopAll: function() {
        for (var id in id2audio) {
          var audio = id2audio[id];
          if (audio && audio.stop) {
            audio.stop();
            audio.off("load", audio.__callback);
          }
        }
      },
      setMaxAudioInstance: function(num) {
        return this._maxAudioInstance = num;
      },
      getMaxAudioInstance: function() {
        return this._maxAudioInstance;
      },
      uncache: function(filePath) {
        var list = url2id[filePath];
        if (!list) return;
        while (list.length > 0) {
          var id = list.pop();
          var audio = id2audio[id];
          if (audio) {
            audio.stop();
            delete id2audio[id];
          }
        }
      },
      uncacheAll: function() {
        this.stopAll();
        id2audio = {};
        url2id = {};
      },
      getProfile: function(profileName) {},
      preload: function(filePath, callback) {
        cc.loader.load(filePath, callback && function(error) {
          error || callback();
        });
      },
      setMaxWebAudioSize: function(kb) {
        this._maxWebAudioSize = 1024 * kb;
      },
      _breakCache: null,
      _break: function() {
        this._breakCache = [];
        for (var id in id2audio) {
          var audio = id2audio[id];
          var state = audio.getState();
          if (state === Audio.State.PLAYING) {
            this._breakCache.push(id);
            audio.pause();
          }
        }
      },
      _restore: function() {
        if (!this._breakCache) return;
        while (this._breakCache.length > 0) {
          var id = this._breakCache.pop();
          var audio = getAudioFromId(id);
          audio && audio.resume && audio.resume();
        }
        this._breakCache = null;
      }
    };
    module.exports = cc.audioEngine = audioEngine;
    var Module = require("./deprecated");
    Module.removed(audioEngine);
    Module.deprecated(audioEngine);
  }), {
    "./CCAudio": 22,
    "./deprecated": 24
  } ],
  24: [ (function(require, module, exports) {
    var js = cc.js;
    exports.removed = function(audioEngine) {
      function willPlayMusicError() {
        cc.errorID(1403);
      }
      js.getset(audioEngine, "willPlayMusic", willPlayMusicError, willPlayMusicError);
    };
    exports.deprecated = function(audioEngine) {
      var musicId = -1;
      var musicPath = 1;
      var musicLoop = 1;
      var musicVolume = 1;
      var effectsVolume = 1;
      var pauseIDCache = [];
      js.get(audioEngine, "playMusic", (function() {
        return function(url, loop) {
          audioEngine.stop(musicId);
          musicId = audioEngine.play(url, loop, musicVolume);
          musicPath = url;
          musicLoop = loop;
          return musicId;
        };
      }));
      js.get(audioEngine, "stopMusic", (function() {
        return function() {
          audioEngine.stop(musicId);
          return musicId;
        };
      }));
      js.get(audioEngine, "pauseMusic", (function() {
        return function() {
          audioEngine.pause(musicId);
          return musicId;
        };
      }));
      js.get(audioEngine, "resumeMusic", (function() {
        return function() {
          audioEngine.resume(musicId);
          return musicId;
        };
      }));
      js.get(audioEngine, "rewindMusic", (function() {
        return function() {
          audioEngine.setCurrentTime(musicId, 0);
          return musicId;
        };
      }));
      js.get(audioEngine, "getMusicVolume", (function() {
        return function() {
          return musicVolume;
        };
      }));
      js.get(audioEngine, "setMusicVolume", (function() {
        return function(volume) {
          musicVolume = volume;
          audioEngine.setVolume(musicId, musicVolume);
          return musicVolume;
        };
      }));
      js.get(audioEngine, "isMusicPlaying", (function() {
        return function() {
          return audioEngine.getState(musicId) === audioEngine.AudioState.PLAYING;
        };
      }));
      js.get(audioEngine, "playEffect", (function() {
        return function(url, loop, volume) {
          return audioEngine.play(url, loop || false, void 0 === volume ? effectsVolume : volume);
        };
      }));
      js.get(audioEngine, "setEffectsVolume", (function(volume) {
        return function(volume) {
          effectsVolume = volume;
          var id2audio = audioEngine._id2audio;
          for (var id in id2audio) {
            if (id === musicId) continue;
            audioEngine.setVolume(id, volume);
          }
        };
      }));
      js.get(audioEngine, "getEffectsVolume", (function() {
        return function() {
          return effectsVolume;
        };
      }));
      js.get(audioEngine, "pauseEffect", (function() {
        return function(id) {
          return audioEngine.pause(id);
        };
      }));
      js.get(audioEngine, "pauseAllEffects", (function() {
        false;
        return function() {
          pauseIDCache.length = 0;
          var id2audio = audioEngine._id2audio;
          for (var id in id2audio) {
            if (id === musicId) continue;
            var audio = id2audio[id];
            var state = audio.getState();
            if (state === audioEngine.AudioState.PLAYING) {
              pauseIDCache.push(id);
              audio.pause();
            }
          }
        };
      }));
      js.get(audioEngine, "resumeEffect", (function() {
        return function(id) {
          audioEngine.resume(id);
        };
      }));
      js.get(audioEngine, "resumeAllEffects", (function() {
        false;
        return function() {
          var id2audio = audioEngine._id2audio;
          while (pauseIDCache.length > 0) {
            var id = pauseIDCache.pop();
            var audio = id2audio[id];
            audio && audio.resume && audio.resume();
          }
        };
      }));
      js.get(audioEngine, "stopEffect", (function() {
        return function(id) {
          return audioEngine.stop(id);
        };
      }));
      js.get(audioEngine, "stopAllEffects", (function() {
        false;
        return function() {
          var id2audio = audioEngine._id2audio;
          for (var id in id2audio) {
            if (id === musicId) continue;
            var audio = id2audio[id];
            var state = audio.getState();
            state === audioEngine.AudioState.PLAYING && audio.stop();
          }
        };
      }));
      js.get(audioEngine, "unloadEffect", (function() {
        return function(id) {
          return audioEngine.stop(id);
        };
      }));
      true;
      js.get(audioEngine, "end", (function() {
        return function() {
          return audioEngine.stopAll();
        };
      }));
    };
  }), {} ],
  25: [ (function(require, module, exports) {
    cc.ClippingNode = _ccsg.Node.extend({
      inverted: false,
      _alphaThreshold: 0,
      _stencil: null,
      _className: "ClippingNode",
      _originStencilProgram: null,
      ctor: function(stencil) {
        stencil = stencil || null;
        _ccsg.Node.prototype.ctor.call(this);
        this._stencil = stencil;
        stencil && (this._originStencilProgram = stencil.getShaderProgram());
        this.alphaThreshold = 1;
        this.inverted = false;
        this._renderCmd.initStencilBits();
      },
      onEnter: function() {
        _ccsg.Node.prototype.onEnter.call(this);
        this._stencil && this._stencil.performRecursive(_ccsg.Node.performType.onEnter);
      },
      onEnterTransitionDidFinish: function() {
        _ccsg.Node.prototype.onEnterTransitionDidFinish.call(this);
        this._stencil && this._stencil.performRecursive(_ccsg.Node.performType.onEnterTransitionDidFinish);
      },
      onExitTransitionDidStart: function() {
        this._stencil && this._stencil.performRecursive(_ccsg.Node.performType.onExitTransitionDidStart);
        _ccsg.Node.prototype.onExitTransitionDidStart.call(this);
      },
      onExit: function() {
        this._stencil && this._stencil.performRecursive(_ccsg.Node.performType.onExit);
        _ccsg.Node.prototype.onExit.call(this);
      },
      visit: function(parent) {
        this._renderCmd.clippingVisit(parent && parent._renderCmd);
      },
      _visitChildren: function() {
        this._reorderChildDirty && this.sortAllChildren();
        var children = this._children, child;
        for (var i = 0, len = children.length; i < len; i++) {
          child = children[i];
          child && child._visible && child.visit(this);
        }
        this._renderCmd._dirtyFlag = 0;
      },
      getAlphaThreshold: function() {
        return this._alphaThreshold;
      },
      setAlphaThreshold: function(alphaThreshold) {
        1 === alphaThreshold && alphaThreshold !== this._alphaThreshold && this._renderCmd.resetProgramByStencil();
        this._alphaThreshold = alphaThreshold;
      },
      isInverted: function() {
        return this.inverted;
      },
      setInverted: function(inverted) {
        this.inverted = inverted;
      },
      getStencil: function() {
        return this._stencil;
      },
      setStencil: function(stencil) {
        if (this._stencil === stencil) return;
        stencil && (this._originStencilProgram = stencil.getShaderProgram());
        this._renderCmd.setStencil(stencil);
      },
      _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.ClippingNode.CanvasRenderCmd(this) : new cc.ClippingNode.WebGLRenderCmd(this);
      }
    });
    cc.ClippingNode.stencilBits = -1;
    var _p = cc.ClippingNode.prototype;
    cc.defineGetterSetter(_p, "stencil", _p.getStencil, _p.setStencil);
    cc.defineGetterSetter(_p, "alphaThreshold", _p.getAlphaThreshold, _p.setAlphaThreshold);
  }), {} ],
  26: [ (function(require, module, exports) {
    require("../shape-nodes/CCDrawNode");
    cc.ClippingNode.CanvasRenderCmd = function(renderable) {
      this._rootCtor(renderable);
      this._needDraw = false;
      this._rendererClipCmd = new cc.CustomRenderCmd(this, this._drawStencilCommand);
      this._rendererRestoreCmd = new cc.CustomRenderCmd(this, this._restoreCmdCallback);
    };
    var proto = cc.ClippingNode.CanvasRenderCmd.prototype = Object.create(_ccsg.Node.CanvasRenderCmd.prototype);
    proto.constructor = cc.ClippingNode.CanvasRenderCmd;
    proto.resetProgramByStencil = function() {};
    proto.initStencilBits = function() {};
    proto.setStencil = function(stencil) {
      if (null == stencil) return;
      this._node._stencil = stencil;
      stencil instanceof cc.DrawNode || cc.errorID(6300);
    };
    proto._restoreCmdCallback = function(ctx) {
      var wrapper = ctx || cc._renderContext;
      wrapper.restore();
    };
    proto._drawStencilCommand = function(ctx, scaleX, scaleY) {
      var wrapper = ctx || cc._renderContext, context = wrapper.getContext();
      wrapper.save();
      context.beginPath();
      wrapper.setTransform(this._worldTransform, scaleX, scaleY);
      var stencilBuffer = this._node._stencil._buffer;
      for (var index = 0; index < stencilBuffer.length; ++index) {
        var vertices = stencilBuffer[index].verts;
        if (vertices.length < 3) continue;
        context.moveTo(vertices[0].x, -vertices[0].y);
        for (var vIndex = 1; vIndex < vertices.length; ++vIndex) context.lineTo(vertices[vIndex].x, -vertices[vIndex].y);
      }
      context.clip();
    };
    proto.clippingVisit = function(parentCmd) {
      var node = this._node;
      parentCmd = parentCmd || this.getParentRenderCmd();
      this._propagateFlagsDown(parentCmd);
      if (!node._visible) return;
      parentCmd && (this._curLevel = parentCmd._curLevel + 1);
      this._syncStatus(parentCmd);
      node._stencil && cc.renderer.pushRenderCommand(this._rendererClipCmd);
      var children = node._children;
      var i, len = children.length;
      if (len > 0) {
        node.sortAllChildren();
        for (i = 0; i < len; i++) children[i].visit(node);
      }
      node._stencil && cc.renderer.pushRenderCommand(this._rendererRestoreCmd);
      this._dirtyFlag = 0;
    };
  }), {
    "../shape-nodes/CCDrawNode": 274
  } ],
  27: [ (function(require, module, exports) {
    require("../core/CCDrawingPrimitives");
    function setProgram(node, program) {
      node.shaderProgram = program;
      var children = node.children;
      if (!children) return;
      for (var i = 0; i < children.length; i++) setProgram(children[i], program);
    }
    var _currentState = {
      stencilEnabled: false,
      depthWriteMask: true
    };
    cc.ClippingNode.WebGLRenderCmd = function(renderable) {
      this._rootCtor(renderable);
      this._needDraw = false;
      this._beforeVisitCmd = new cc.CustomRenderCmd(this, this._onBeforeVisit);
      this._afterDrawStencilCmd = new cc.CustomRenderCmd(this, this._onAfterDrawStencil);
      this._afterVisitCmd = new cc.CustomRenderCmd(this, this._onAfterVisit);
      this._previousState = null;
      this._state = {
        stencilEnabled: true,
        stencilWriteMask: 0,
        depthWriteMask: false,
        stencilFunc: 0,
        stencilRef: 0,
        stencilValueMask: 0
      };
    };
    var proto = cc.ClippingNode.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.WebGLRenderCmd.prototype);
    proto.constructor = cc.ClippingNode.WebGLRenderCmd;
    cc.ClippingNode.WebGLRenderCmd._init_once = null;
    cc.ClippingNode.WebGLRenderCmd._visit_once = null;
    cc.ClippingNode.WebGLRenderCmd._layer = -1;
    proto.initStencilBits = function() {
      cc.ClippingNode.WebGLRenderCmd._init_once = true;
      if (cc.ClippingNode.WebGLRenderCmd._init_once) {
        cc.ClippingNode.stencilBits = cc._renderContext.getParameter(cc._renderContext.STENCIL_BITS);
        cc.ClippingNode.stencilBits <= 0 && cc.logID(6301);
        cc.ClippingNode.WebGLRenderCmd._init_once = false;
      }
    };
    proto.transform = function(parentCmd, recursive) {
      var node = this._node;
      this.originTransform(parentCmd, recursive);
      if (node._stencil) {
        node._stencil._renderCmd.transform(this, true);
        node._stencil._dirtyFlag &= ~_ccsg.Node._dirtyFlags.transformDirty;
      }
    };
    proto.clippingVisit = function(parentCmd) {
      var node = this._node;
      parentCmd = parentCmd || this.getParentRenderCmd();
      this.visit(parentCmd);
      if (cc.ClippingNode.stencilBits < 1) {
        node._visitChildren();
        return;
      }
      if (!node._stencil || !node._stencil.visible) {
        node.inverted && node._visitChildren();
        return;
      }
      if (cc.ClippingNode.WebGLRenderCmd._layer + 1 === cc.ClippingNode.stencilBits) {
        cc.ClippingNode.WebGLRenderCmd._visit_once = true;
        if (cc.ClippingNode.WebGLRenderCmd._visit_once) {
          cc.logID(6302, cc.ClippingNode.stencilBits);
          cc.ClippingNode.WebGLRenderCmd._visit_once = false;
        }
        node._visitChildren();
        return;
      }
      cc.renderer.pushRenderCommand(this._beforeVisitCmd);
      node._stencil.visit(node);
      cc.renderer.pushRenderCommand(this._afterDrawStencilCmd);
      var locChildren = node._children;
      if (locChildren && locChildren.length > 0) {
        var childLen = locChildren.length;
        node.sortAllChildren();
        for (var i = 0; i < childLen; i++) locChildren[i].visit(node);
      }
      cc.renderer.pushRenderCommand(this._afterVisitCmd);
      this._dirtyFlag = 0;
    };
    proto.setStencil = function(stencil) {
      var node = this._node;
      node._stencil && (node._stencil._parent = null);
      node._stencil = stencil;
      node._stencil && (node._stencil._parent = node);
    };
    proto._drawFullScreenQuadClearStencil = function() {
      var projStack = cc.math.projection_matrix_stack;
      projStack.push();
      projStack.top.identity();
      var modelViewStack = cc.math.modelview_matrix_stack;
      modelViewStack.push();
      modelViewStack.top.identity();
      cc._drawingUtil.drawSolidRect(cc.p(-1, -1), cc.p(1, 1), cc.color(255, 255, 255, 255));
      projStack.pop();
      modelViewStack.pop();
    };
    proto.resetProgramByStencil = function() {
      var node = this._node;
      if (node._stencil) {
        var program = node._originStencilProgram;
        setProgram(node._stencil, program);
      }
    };
    proto._onBeforeVisit = function(ctx) {
      var gl = ctx || cc._renderContext, node = this._node;
      cc.ClippingNode.WebGLRenderCmd._layer++;
      var mask_layer = 1 << cc.ClippingNode.WebGLRenderCmd._layer;
      var mask_layer_l = mask_layer - 1;
      var mask_layer_le = mask_layer | mask_layer_l;
      this._previousState = _currentState;
      gl.enable(gl.STENCIL_TEST);
      gl.stencilMask(mask_layer);
      gl.depthMask(false);
      gl.stencilFunc(gl.NEVER, mask_layer, mask_layer);
      gl.stencilOp(this._node.inverted ? gl.REPLACE : gl.ZERO, gl.KEEP, gl.KEEP);
      this._drawFullScreenQuadClearStencil();
      gl.stencilFunc(gl.NEVER, mask_layer, mask_layer);
      gl.stencilOp(this._node.inverted ? gl.ZERO : gl.REPLACE, gl.KEEP, gl.KEEP);
      if (node.alphaThreshold < 1) {
        var program = cc.shaderCache.programForKey(cc.macro.SHADER_POSITION_TEXTURECOLORALPHATEST);
        cc.gl.useProgram(program.getProgram());
        program.setUniformLocationWith1f(cc.macro.UNIFORM_ALPHA_TEST_VALUE_S, node.alphaThreshold);
        program.setUniformLocationWithMatrix4fv(cc.macro.UNIFORM_MVMATRIX_S, cc.renderer.mat4Identity.mat);
        setProgram(node._stencil, program);
      }
      this._state.stencilWriteMask = mask_layer;
      this._state.stencilRef = this._state.stencilValueMask = mask_layer_le;
      this._state.stencilFunc = gl.NEVER;
      _currentState = this._state;
    };
    proto._onAfterDrawStencil = function(ctx) {
      var gl = ctx || cc._renderContext;
      gl.depthMask(this._previousState.depthWriteMask);
      gl.stencilFunc(gl.EQUAL, this._state.stencilRef, this._state.stencilValueMask);
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
      this._state.stencilFunc = gl.EQUAL;
    };
    proto._onAfterVisit = function(ctx) {
      var gl = ctx || cc._renderContext;
      var state = this._previousState;
      if (state.stencilEnabled) {
        gl.stencilFunc(state.stencilFunc, state.stencilRef, state.stencilValueMask);
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
        gl.stencilMask(state.stencilWriteMask);
      } else gl.disable(gl.STENCIL_TEST);
      _currentState = this._previousState;
      this._previousState = null;
      cc.ClippingNode.WebGLRenderCmd._layer--;
    };
  }), {
    "../core/CCDrawingPrimitives": 36
  } ],
  28: [ (function(require, module, exports) {
    cc.Codec = {
      name: "Jacob__Codec"
    };
    cc.Codec.Base64 = require("./base64");
    cc.Codec.GZip = require("./gzip");
    cc.Codec.unzip = function() {
      return cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, arguments);
    };
    cc.Codec.unzipBase64 = function() {
      var buffer = cc.Codec.Base64.decode.apply(cc.Codec.Base64, arguments);
      try {
        return cc.Codec.GZip.gunzip.call(cc.Codec.GZip, buffer);
      } catch (e) {
        return buffer.slice(7);
      }
    };
    cc.Codec.unzipBase64AsArray = function(input, bytes) {
      bytes = bytes || 1;
      var dec = this.unzipBase64(input), ar = [], i, j, len;
      for (i = 0, len = dec.length / bytes; i < len; i++) {
        ar[i] = 0;
        for (j = bytes - 1; j >= 0; --j) ar[i] += dec.charCodeAt(i * bytes + j) << 8 * j;
      }
      return ar;
    };
    cc.Codec.unzipAsArray = function(input, bytes) {
      bytes = bytes || 1;
      var dec = this.unzip(input), ar = [], i, j, len;
      for (i = 0, len = dec.length / bytes; i < len; i++) {
        ar[i] = 0;
        for (j = bytes - 1; j >= 0; --j) ar[i] += dec.charCodeAt(i * bytes + j) << 8 * j;
      }
      return ar;
    };
  }), {
    "./base64": 29,
    "./gzip": 30
  } ],
  29: [ (function(require, module, exports) {
    var Misc = require("../core/utils/misc");
    var strValue = Misc.BASE64_VALUES;
    var Base64 = {
      name: "Jacob__Codec__Base64"
    };
    Base64.decode = function Jacob__Codec__Base64__decode(input) {
      var output = [], chr1, chr2, chr3, enc1, enc2, enc3, enc4, i = 0;
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      while (i < input.length) {
        enc1 = strValue[input.charCodeAt(i++)];
        enc2 = strValue[input.charCodeAt(i++)];
        enc3 = strValue[input.charCodeAt(i++)];
        enc4 = strValue[input.charCodeAt(i++)];
        chr1 = enc1 << 2 | enc2 >> 4;
        chr2 = (15 & enc2) << 4 | enc3 >> 2;
        chr3 = (3 & enc3) << 6 | enc4;
        output.push(String.fromCharCode(chr1));
        64 !== enc3 && output.push(String.fromCharCode(chr2));
        64 !== enc4 && output.push(String.fromCharCode(chr3));
      }
      output = output.join("");
      return output;
    };
    Base64.decodeAsArray = function Jacob__Codec__Base64___decodeAsArray(input, bytes) {
      var dec = this.decode(input), ar = [], i, j, len;
      for (i = 0, len = dec.length / bytes; i < len; i++) {
        ar[i] = 0;
        for (j = bytes - 1; j >= 0; --j) ar[i] += dec.charCodeAt(i * bytes + j) << 8 * j;
      }
      return ar;
    };
    module.exports = Base64;
  }), {
    "../core/utils/misc": 225
  } ],
  30: [ (function(require, module, exports) {
    var GZip = function Jacob__GZip(data) {
      this.data = data;
      this.debug = false;
      this.gpflags = void 0;
      this.files = 0;
      this.unzipped = [];
      this.buf32k = new Array(32768);
      this.bIdx = 0;
      this.modeZIP = false;
      this.bytepos = 0;
      this.bb = 1;
      this.bits = 0;
      this.nameBuf = [];
      this.fileout = void 0;
      this.literalTree = new Array(GZip.LITERALS);
      this.distanceTree = new Array(32);
      this.treepos = 0;
      this.Places = null;
      this.len = 0;
      this.fpos = new Array(17);
      this.fpos[0] = 0;
      this.flens = void 0;
      this.fmax = void 0;
    };
    GZip.gunzip = function(string) {
      string.constructor === Array || string.constructor === String;
      var gzip = new GZip(string);
      return gzip.gunzip()[0][0];
    };
    GZip.HufNode = function() {
      this.b0 = 0;
      this.b1 = 0;
      this.jump = null;
      this.jumppos = -1;
    };
    GZip.LITERALS = 288;
    GZip.NAMEMAX = 256;
    GZip.bitReverse = [ 0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112, 240, 8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248, 4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244, 12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82, 210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161, 97, 225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 3, 131, 67, 195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243, 11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251, 7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247, 15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255 ];
    GZip.cplens = [ 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0 ];
    GZip.cplext = [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99 ];
    GZip.cpdist = [ 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577 ];
    GZip.cpdext = [ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ];
    GZip.border = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];
    GZip.prototype.gunzip = function() {
      this.outputArr = [];
      this.nextFile();
      return this.unzipped;
    };
    GZip.prototype.readByte = function() {
      this.bits += 8;
      return this.bytepos < this.data.length ? this.data.charCodeAt(this.bytepos++) : -1;
    };
    GZip.prototype.byteAlign = function() {
      this.bb = 1;
    };
    GZip.prototype.readBit = function() {
      var carry;
      this.bits++;
      carry = 1 & this.bb;
      this.bb >>= 1;
      if (0 === this.bb) {
        this.bb = this.readByte();
        carry = 1 & this.bb;
        this.bb = this.bb >> 1 | 128;
      }
      return carry;
    };
    GZip.prototype.readBits = function(a) {
      var res = 0, i = a;
      while (i--) res = res << 1 | this.readBit();
      a && (res = GZip.bitReverse[res] >> 8 - a);
      return res;
    };
    GZip.prototype.flushBuffer = function() {
      this.bIdx = 0;
    };
    GZip.prototype.addBuffer = function(a) {
      this.buf32k[this.bIdx++] = a;
      this.outputArr.push(String.fromCharCode(a));
      32768 === this.bIdx && (this.bIdx = 0);
    };
    GZip.prototype.IsPat = function() {
      while (1) {
        if (this.fpos[this.len] >= this.fmax) return -1;
        if (this.flens[this.fpos[this.len]] === this.len) return this.fpos[this.len]++;
        this.fpos[this.len]++;
      }
    };
    GZip.prototype.Rec = function() {
      var curplace = this.Places[this.treepos];
      var tmp;
      if (17 === this.len) return -1;
      this.treepos++;
      this.len++;
      tmp = this.IsPat();
      if (tmp >= 0) curplace.b0 = tmp; else {
        curplace.b0 = 32768;
        if (this.Rec()) return -1;
      }
      tmp = this.IsPat();
      if (tmp >= 0) {
        curplace.b1 = tmp;
        curplace.jump = null;
      } else {
        curplace.b1 = 32768;
        curplace.jump = this.Places[this.treepos];
        curplace.jumppos = this.treepos;
        if (this.Rec()) return -1;
      }
      this.len--;
      return 0;
    };
    GZip.prototype.CreateTree = function(currentTree, numval, lengths, show) {
      var i;
      this.Places = currentTree;
      this.treepos = 0;
      this.flens = lengths;
      this.fmax = numval;
      for (i = 0; i < 17; i++) this.fpos[i] = 0;
      this.len = 0;
      if (this.Rec()) return -1;
      return 0;
    };
    GZip.prototype.DecodeValue = function(currentTree) {
      var len, i, xtreepos = 0, X = currentTree[xtreepos], b;
      while (1) {
        b = this.readBit();
        if (b) {
          if (!(32768 & X.b1)) return X.b1;
          X = X.jump;
          len = currentTree.length;
          for (i = 0; i < len; i++) if (currentTree[i] === X) {
            xtreepos = i;
            break;
          }
        } else {
          if (!(32768 & X.b0)) return X.b0;
          xtreepos++;
          X = currentTree[xtreepos];
        }
      }
      return -1;
    };
    GZip.prototype.DeflateLoop = function() {
      var last, c, type, i, len;
      do {
        last = this.readBit();
        type = this.readBits(2);
        if (0 === type) {
          var blockLen, cSum;
          this.byteAlign();
          blockLen = this.readByte();
          blockLen |= this.readByte() << 8;
          cSum = this.readByte();
          cSum |= this.readByte() << 8;
          65535 & (blockLen ^ ~cSum) && document.write("BlockLen checksum mismatch\n");
          while (blockLen--) {
            c = this.readByte();
            this.addBuffer(c);
          }
        } else if (1 === type) {
          var j;
          while (1) {
            j = GZip.bitReverse[this.readBits(7)] >> 1;
            if (j > 23) {
              j = j << 1 | this.readBit();
              if (j > 199) {
                j -= 128;
                j = j << 1 | this.readBit();
              } else {
                j -= 48;
                j > 143 && (j += 136);
              }
            } else j += 256;
            if (j < 256) this.addBuffer(j); else {
              if (256 === j) break;
              var len, dist;
              j -= 257;
              len = this.readBits(GZip.cplext[j]) + GZip.cplens[j];
              j = GZip.bitReverse[this.readBits(5)] >> 3;
              if (GZip.cpdext[j] > 8) {
                dist = this.readBits(8);
                dist |= this.readBits(GZip.cpdext[j] - 8) << 8;
              } else dist = this.readBits(GZip.cpdext[j]);
              dist += GZip.cpdist[j];
              for (j = 0; j < len; j++) {
                var c = this.buf32k[this.bIdx - dist & 32767];
                this.addBuffer(c);
              }
            }
          }
        } else if (2 === type) {
          var j, n, literalCodes, distCodes, lenCodes;
          var ll = new Array(320);
          literalCodes = 257 + this.readBits(5);
          distCodes = 1 + this.readBits(5);
          lenCodes = 4 + this.readBits(4);
          for (j = 0; j < 19; j++) ll[j] = 0;
          for (j = 0; j < lenCodes; j++) ll[GZip.border[j]] = this.readBits(3);
          len = this.distanceTree.length;
          for (i = 0; i < len; i++) this.distanceTree[i] = new GZip.HufNode();
          if (this.CreateTree(this.distanceTree, 19, ll, 0)) {
            this.flushBuffer();
            return 1;
          }
          n = literalCodes + distCodes;
          i = 0;
          var z = -1;
          while (i < n) {
            z++;
            j = this.DecodeValue(this.distanceTree);
            if (j < 16) ll[i++] = j; else if (16 === j) {
              var l;
              j = 3 + this.readBits(2);
              if (i + j > n) {
                this.flushBuffer();
                return 1;
              }
              l = i ? ll[i - 1] : 0;
              while (j--) ll[i++] = l;
            } else {
              j = 17 === j ? 3 + this.readBits(3) : 11 + this.readBits(7);
              if (i + j > n) {
                this.flushBuffer();
                return 1;
              }
              while (j--) ll[i++] = 0;
            }
          }
          len = this.literalTree.length;
          for (i = 0; i < len; i++) this.literalTree[i] = new GZip.HufNode();
          if (this.CreateTree(this.literalTree, literalCodes, ll, 0)) {
            this.flushBuffer();
            return 1;
          }
          len = this.literalTree.length;
          for (i = 0; i < len; i++) this.distanceTree[i] = new GZip.HufNode();
          var ll2 = new Array();
          for (i = literalCodes; i < ll.length; i++) ll2[i - literalCodes] = ll[i];
          if (this.CreateTree(this.distanceTree, distCodes, ll2, 0)) {
            this.flushBuffer();
            return 1;
          }
          while (1) {
            j = this.DecodeValue(this.literalTree);
            if (j >= 256) {
              var len, dist;
              j -= 256;
              if (0 === j) break;
              j--;
              len = this.readBits(GZip.cplext[j]) + GZip.cplens[j];
              j = this.DecodeValue(this.distanceTree);
              if (GZip.cpdext[j] > 8) {
                dist = this.readBits(8);
                dist |= this.readBits(GZip.cpdext[j] - 8) << 8;
              } else dist = this.readBits(GZip.cpdext[j]);
              dist += GZip.cpdist[j];
              while (len--) {
                var c = this.buf32k[this.bIdx - dist & 32767];
                this.addBuffer(c);
              }
            } else this.addBuffer(j);
          }
        }
      } while (!last);
      this.flushBuffer();
      this.byteAlign();
      return 0;
    };
    GZip.prototype.unzipFile = function(name) {
      var i;
      this.gunzip();
      for (i = 0; i < this.unzipped.length; i++) if (this.unzipped[i][1] === name) return this.unzipped[i][0];
    };
    GZip.prototype.nextFile = function() {
      this.outputArr = [];
      this.modeZIP = false;
      var tmp = [];
      tmp[0] = this.readByte();
      tmp[1] = this.readByte();
      if (120 === tmp[0] && 218 === tmp[1]) {
        this.DeflateLoop();
        this.unzipped[this.files] = [ this.outputArr.join(""), "geonext.gxt" ];
        this.files++;
      }
      if (31 === tmp[0] && 139 === tmp[1]) {
        this.skipdir();
        this.unzipped[this.files] = [ this.outputArr.join(""), "file" ];
        this.files++;
      }
      if (80 === tmp[0] && 75 === tmp[1]) {
        this.modeZIP = true;
        tmp[2] = this.readByte();
        tmp[3] = this.readByte();
        if (3 === tmp[2] && 4 === tmp[3]) {
          tmp[0] = this.readByte();
          tmp[1] = this.readByte();
          this.gpflags = this.readByte();
          this.gpflags |= this.readByte() << 8;
          var method = this.readByte();
          method |= this.readByte() << 8;
          this.readByte();
          this.readByte();
          this.readByte();
          this.readByte();
          var compSize = this.readByte();
          compSize |= this.readByte() << 8;
          compSize |= this.readByte() << 16;
          compSize |= this.readByte() << 24;
          var size = this.readByte();
          size |= this.readByte() << 8;
          size |= this.readByte() << 16;
          size |= this.readByte() << 24;
          var filelen = this.readByte();
          filelen |= this.readByte() << 8;
          var extralen = this.readByte();
          extralen |= this.readByte() << 8;
          i = 0;
          this.nameBuf = [];
          while (filelen--) {
            var c = this.readByte();
            "/" === c | ":" === c ? i = 0 : i < GZip.NAMEMAX - 1 && (this.nameBuf[i++] = String.fromCharCode(c));
          }
          this.fileout || (this.fileout = this.nameBuf);
          var i = 0;
          while (i < extralen) {
            c = this.readByte();
            i++;
          }
          if (8 === method) {
            this.DeflateLoop();
            this.unzipped[this.files] = [ this.outputArr.join(""), this.nameBuf.join("") ];
            this.files++;
          }
          this.skipdir();
        }
      }
    };
    GZip.prototype.skipdir = function() {
      var tmp = [];
      var compSize, size, os, i, c;
      if (8 & this.gpflags) {
        tmp[0] = this.readByte();
        tmp[1] = this.readByte();
        tmp[2] = this.readByte();
        tmp[3] = this.readByte();
        compSize = this.readByte();
        compSize |= this.readByte() << 8;
        compSize |= this.readByte() << 16;
        compSize |= this.readByte() << 24;
        size = this.readByte();
        size |= this.readByte() << 8;
        size |= this.readByte() << 16;
        size |= this.readByte() << 24;
      }
      this.modeZIP && this.nextFile();
      tmp[0] = this.readByte();
      if (8 !== tmp[0]) return 0;
      this.gpflags = this.readByte();
      this.readByte();
      this.readByte();
      this.readByte();
      this.readByte();
      this.readByte();
      os = this.readByte();
      if (4 & this.gpflags) {
        tmp[0] = this.readByte();
        tmp[2] = this.readByte();
        this.len = tmp[0] + 256 * tmp[1];
        for (i = 0; i < this.len; i++) this.readByte();
      }
      if (8 & this.gpflags) {
        i = 0;
        this.nameBuf = [];
        while (c = this.readByte()) {
          "7" !== c && ":" !== c || (i = 0);
          i < GZip.NAMEMAX - 1 && (this.nameBuf[i++] = c);
        }
      }
      if (16 & this.gpflags) while (c = this.readByte()) ;
      if (2 & this.gpflags) {
        this.readByte();
        this.readByte();
      }
      this.DeflateLoop();
      size = this.readByte();
      size |= this.readByte() << 8;
      size |= this.readByte() << 16;
      size |= this.readByte() << 24;
      this.modeZIP && this.nextFile();
    };
    module.exports = GZip;
  }), {} ],
  31: [ (function(require, module, exports) {
    (function() {
      "use strict";
      function i(a) {
        throw a;
      }
      var r = void 0, v = !0, aa = this;
      function y(a, c) {
        var b = a.split("."), e = aa;
        !(b[0] in e) && e.execScript && e.execScript("var " + b[0]);
        for (var f; b.length && (f = b.shift()); ) b.length || c === r ? e = e[f] ? e[f] : e[f] = {} : e[f] = c;
      }
      var H = "undefined" !== typeof Uint8Array && "undefined" !== typeof Uint16Array && "undefined" !== typeof Uint32Array;
      function ba(a) {
        if ("string" === typeof a) {
          var c = a.split(""), b, e;
          b = 0;
          for (e = c.length; b < e; b++) c[b] = (255 & c[b].charCodeAt(0)) >>> 0;
          a = c;
        }
        for (var f = 1, d = 0, g = a.length, h, m = 0; 0 < g; ) {
          h = 1024 < g ? 1024 : g;
          g -= h;
          do {
            f += a[m++], d += f;
          } while (--h);
          f %= 65521;
          d %= 65521;
        }
        return (d << 16 | f) >>> 0;
      }
      function J(a, c) {
        this.index = "number" === typeof c ? c : 0;
        this.i = 0;
        this.buffer = a instanceof (H ? Uint8Array : Array) ? a : new (H ? Uint8Array : Array)(32768);
        2 * this.buffer.length <= this.index && i(Error("invalid index"));
        this.buffer.length <= this.index && this.f();
      }
      J.prototype.f = function() {
        var a = this.buffer, c, b = a.length, e = new (H ? Uint8Array : Array)(b << 1);
        if (H) e.set(a); else for (c = 0; c < b; ++c) e[c] = a[c];
        return this.buffer = e;
      };
      J.prototype.d = function(a, c, b) {
        var e = this.buffer, f = this.index, d = this.i, g = e[f], h;
        b && 1 < c && (a = 8 < c ? (N[255 & a] << 24 | N[a >>> 8 & 255] << 16 | N[a >>> 16 & 255] << 8 | N[a >>> 24 & 255]) >> 32 - c : N[a] >> 8 - c);
        if (8 > c + d) g = g << c | a, d += c; else for (h = 0; h < c; ++h) g = g << 1 | a >> c - h - 1 & 1, 
        8 === ++d && (d = 0, e[f++] = N[g], g = 0, f === e.length && (e = this.f()));
        e[f] = g;
        this.buffer = e;
        this.i = d;
        this.index = f;
      };
      J.prototype.finish = function() {
        var a = this.buffer, c = this.index, b;
        0 < this.i && (a[c] <<= 8 - this.i, a[c] = N[a[c]], c++);
        H ? b = a.subarray(0, c) : (a.length = c, b = a);
        return b;
      };
      var ca = new (H ? Uint8Array : Array)(256), ha;
      for (ha = 0; 256 > ha; ++ha) {
        for (var R = ha, ia = R, ja = 7, R = R >>> 1; R; R >>>= 1) ia <<= 1, ia |= 1 & R, 
        --ja;
        ca[ha] = (ia << ja & 255) >>> 0;
      }
      var N = ca;
      var ka = [ 0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117 ];
      H && new Uint32Array(ka);
      function la(a) {
        this.buffer = new (H ? Uint16Array : Array)(2 * a);
        this.length = 0;
      }
      la.prototype.getParent = function(a) {
        return 2 * ((a - 2) / 4 | 0);
      };
      la.prototype.push = function(a, c) {
        var b, e, f = this.buffer, d;
        b = this.length;
        f[this.length++] = c;
        for (f[this.length++] = a; 0 < b; ) {
          if (e = this.getParent(b), !(f[b] > f[e])) break;
          d = f[b], f[b] = f[e], f[e] = d, d = f[b + 1], f[b + 1] = f[e + 1], f[e + 1] = d, 
          b = e;
        }
        return this.length;
      };
      la.prototype.pop = function() {
        var a, c, b = this.buffer, e, f, d;
        c = b[0];
        a = b[1];
        this.length -= 2;
        b[0] = b[this.length];
        b[1] = b[this.length + 1];
        for (d = 0; ;) {
          f = 2 * d + 2;
          if (f >= this.length) break;
          f + 2 < this.length && b[f + 2] > b[f] && (f += 2);
          if (!(b[f] > b[d])) break;
          e = b[d], b[d] = b[f], b[f] = e, e = b[d + 1], b[d + 1] = b[f + 1], b[f + 1] = e;
          d = f;
        }
        return {
          index: a,
          value: c,
          length: this.length
        };
      };
      function S(a) {
        var c = a.length, b = 0, e = Number.POSITIVE_INFINITY, f, d, g, h, m, j, s, n, l;
        for (n = 0; n < c; ++n) a[n] > b && (b = a[n]), a[n] < e && (e = a[n]);
        f = 1 << b;
        d = new (H ? Uint32Array : Array)(f);
        g = 1;
        h = 0;
        for (m = 2; g <= b; ) {
          for (n = 0; n < c; ++n) if (a[n] === g) {
            j = 0;
            s = h;
            for (l = 0; l < g; ++l) j = j << 1 | 1 & s, s >>= 1;
            for (l = j; l < f; l += m) d[l] = g << 16 | n;
            ++h;
          }
          ++g;
          h <<= 1;
          m <<= 1;
        }
        return [ d, b, e ];
      }
      function ma(a, c) {
        this.h = pa;
        this.w = 0;
        this.input = a;
        this.b = 0;
        c && (c.lazy && (this.w = c.lazy), "number" === typeof c.compressionType && (this.h = c.compressionType), 
        c.outputBuffer && (this.a = H && c.outputBuffer instanceof Array ? new Uint8Array(c.outputBuffer) : c.outputBuffer), 
        "number" === typeof c.outputIndex && (this.b = c.outputIndex));
        this.a || (this.a = new (H ? Uint8Array : Array)(32768));
      }
      var pa = 2, qa = {
        NONE: 0,
        r: 1,
        j: pa,
        N: 3
      }, ra = [], T;
      for (T = 0; 288 > T; T++) switch (v) {
       case 143 >= T:
        ra.push([ T + 48, 8 ]);
        break;

       case 255 >= T:
        ra.push([ T - 144 + 400, 9 ]);
        break;

       case 279 >= T:
        ra.push([ T - 256 + 0, 7 ]);
        break;

       case 287 >= T:
        ra.push([ T - 280 + 192, 8 ]);
        break;

       default:
        i("invalid literal: " + T);
      }
      ma.prototype.n = function() {
        var a, c, b, e, f = this.input;
        switch (this.h) {
         case 0:
          b = 0;
          for (e = f.length; b < e; ) {
            c = H ? f.subarray(b, b + 65535) : f.slice(b, b + 65535);
            b += c.length;
            var d = c, g = b === e, h = r, m = r, j = r, s = r, n = r, l = this.a, q = this.b;
            if (H) {
              for (l = new Uint8Array(this.a.buffer); l.length <= q + d.length + 5; ) l = new Uint8Array(l.length << 1);
              l.set(this.a);
            }
            h = g ? 1 : 0;
            l[q++] = 0 | h;
            m = d.length;
            j = 65536 + ~m & 65535;
            l[q++] = 255 & m;
            l[q++] = m >>> 8 & 255;
            l[q++] = 255 & j;
            l[q++] = j >>> 8 & 255;
            if (H) l.set(d, q), q += d.length, l = l.subarray(0, q); else {
              s = 0;
              for (n = d.length; s < n; ++s) l[q++] = d[s];
              l.length = q;
            }
            this.b = q;
            this.a = l;
          }
          break;

         case 1:
          var E = new J(new Uint8Array(this.a.buffer), this.b);
          E.d(1, 1, v);
          E.d(1, 2, v);
          var t = sa(this, f), z, K, A;
          z = 0;
          for (K = t.length; z < K; z++) if (A = t[z], J.prototype.d.apply(E, ra[A]), 256 < A) E.d(t[++z], t[++z], v), 
          E.d(t[++z], 5), E.d(t[++z], t[++z], v); else if (256 === A) break;
          this.a = E.finish();
          this.b = this.a.length;
          break;

         case pa:
          var x = new J(new Uint8Array(this.a), this.b), B, k, p, D, C, da = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ], W, Ma, ea, Na, na, va = Array(19), Oa, $, oa, F, Pa;
          B = pa;
          x.d(1, 1, v);
          x.d(B, 2, v);
          k = sa(this, f);
          W = ta(this.L, 15);
          Ma = ua(W);
          ea = ta(this.K, 7);
          Na = ua(ea);
          for (p = 286; 257 < p && 0 === W[p - 1]; p--) ;
          for (D = 30; 1 < D && 0 === ea[D - 1]; D--) ;
          var Qa = p, Ra = D, M = new (H ? Uint32Array : Array)(Qa + Ra), u, O, w, fa, L = new (H ? Uint32Array : Array)(316), I, G, P = new (H ? Uint8Array : Array)(19);
          for (u = O = 0; u < Qa; u++) M[O++] = W[u];
          for (u = 0; u < Ra; u++) M[O++] = ea[u];
          if (!H) {
            u = 0;
            for (fa = P.length; u < fa; ++u) P[u] = 0;
          }
          u = I = 0;
          for (fa = M.length; u < fa; u += O) {
            for (O = 1; u + O < fa && M[u + O] === M[u]; ++O) ;
            w = O;
            if (0 === M[u]) if (3 > w) for (;0 < w--; ) L[I++] = 0, P[0]++; else for (;0 < w; ) G = 138 > w ? w : 138, 
            G > w - 3 && G < w && (G = w - 3), 10 >= G ? (L[I++] = 17, L[I++] = G - 3, P[17]++) : (L[I++] = 18, 
            L[I++] = G - 11, P[18]++), w -= G; else if (L[I++] = M[u], P[M[u]]++, w--, 3 > w) for (;0 < w--; ) L[I++] = M[u], 
            P[M[u]]++; else for (;0 < w; ) G = 6 > w ? w : 6, G > w - 3 && G < w && (G = w - 3), 
            L[I++] = 16, L[I++] = G - 3, P[16]++, w -= G;
          }
          a = H ? L.subarray(0, I) : L.slice(0, I);
          na = ta(P, 7);
          for (F = 0; 19 > F; F++) va[F] = na[da[F]];
          for (C = 19; 4 < C && 0 === va[C - 1]; C--) ;
          Oa = ua(na);
          x.d(p - 257, 5, v);
          x.d(D - 1, 5, v);
          x.d(C - 4, 4, v);
          for (F = 0; F < C; F++) x.d(va[F], 3, v);
          F = 0;
          for (Pa = a.length; F < Pa; F++) if ($ = a[F], x.d(Oa[$], na[$], v), 16 <= $) {
            F++;
            switch ($) {
             case 16:
              oa = 2;
              break;

             case 17:
              oa = 3;
              break;

             case 18:
              oa = 7;
              break;

             default:
              i("invalid code: " + $);
            }
            x.d(a[F], oa, v);
          }
          var Sa = [ Ma, W ], Ta = [ Na, ea ], Q, Ua, ga, ya, Va, Wa, Xa, Ya;
          Va = Sa[0];
          Wa = Sa[1];
          Xa = Ta[0];
          Ya = Ta[1];
          Q = 0;
          for (Ua = k.length; Q < Ua; ++Q) if (ga = k[Q], x.d(Va[ga], Wa[ga], v), 256 < ga) x.d(k[++Q], k[++Q], v), 
          ya = k[++Q], x.d(Xa[ya], Ya[ya], v), x.d(k[++Q], k[++Q], v); else if (256 === ga) break;
          this.a = x.finish();
          this.b = this.a.length;
          break;

         default:
          i("invalid compression type");
        }
        return this.a;
      };
      function wa(a, c) {
        this.length = a;
        this.G = c;
      }
      function xa() {
        var a = za;
        switch (v) {
         case 3 === a:
          return [ 257, a - 3, 0 ];

         case 4 === a:
          return [ 258, a - 4, 0 ];

         case 5 === a:
          return [ 259, a - 5, 0 ];

         case 6 === a:
          return [ 260, a - 6, 0 ];

         case 7 === a:
          return [ 261, a - 7, 0 ];

         case 8 === a:
          return [ 262, a - 8, 0 ];

         case 9 === a:
          return [ 263, a - 9, 0 ];

         case 10 === a:
          return [ 264, a - 10, 0 ];

         case 12 >= a:
          return [ 265, a - 11, 1 ];

         case 14 >= a:
          return [ 266, a - 13, 1 ];

         case 16 >= a:
          return [ 267, a - 15, 1 ];

         case 18 >= a:
          return [ 268, a - 17, 1 ];

         case 22 >= a:
          return [ 269, a - 19, 2 ];

         case 26 >= a:
          return [ 270, a - 23, 2 ];

         case 30 >= a:
          return [ 271, a - 27, 2 ];

         case 34 >= a:
          return [ 272, a - 31, 2 ];

         case 42 >= a:
          return [ 273, a - 35, 3 ];

         case 50 >= a:
          return [ 274, a - 43, 3 ];

         case 58 >= a:
          return [ 275, a - 51, 3 ];

         case 66 >= a:
          return [ 276, a - 59, 3 ];

         case 82 >= a:
          return [ 277, a - 67, 4 ];

         case 98 >= a:
          return [ 278, a - 83, 4 ];

         case 114 >= a:
          return [ 279, a - 99, 4 ];

         case 130 >= a:
          return [ 280, a - 115, 4 ];

         case 162 >= a:
          return [ 281, a - 131, 5 ];

         case 194 >= a:
          return [ 282, a - 163, 5 ];

         case 226 >= a:
          return [ 283, a - 195, 5 ];

         case 257 >= a:
          return [ 284, a - 227, 5 ];

         case 258 === a:
          return [ 285, a - 258, 0 ];

         default:
          i("invalid length: " + a);
        }
      }
      var Aa = [], za, Ba;
      for (za = 3; 258 >= za; za++) Ba = xa(), Aa[za] = Ba[2] << 24 | Ba[1] << 16 | Ba[0];
      var Ca = H ? new Uint32Array(Aa) : Aa;
      function sa(a, c) {
        function b(a, c) {
          var b = a.G, d = [], e = 0, f;
          f = Ca[a.length];
          d[e++] = 65535 & f;
          d[e++] = f >> 16 & 255;
          d[e++] = f >> 24;
          var g;
          switch (v) {
           case 1 === b:
            g = [ 0, b - 1, 0 ];
            break;

           case 2 === b:
            g = [ 1, b - 2, 0 ];
            break;

           case 3 === b:
            g = [ 2, b - 3, 0 ];
            break;

           case 4 === b:
            g = [ 3, b - 4, 0 ];
            break;

           case 6 >= b:
            g = [ 4, b - 5, 1 ];
            break;

           case 8 >= b:
            g = [ 5, b - 7, 1 ];
            break;

           case 12 >= b:
            g = [ 6, b - 9, 2 ];
            break;

           case 16 >= b:
            g = [ 7, b - 13, 2 ];
            break;

           case 24 >= b:
            g = [ 8, b - 17, 3 ];
            break;

           case 32 >= b:
            g = [ 9, b - 25, 3 ];
            break;

           case 48 >= b:
            g = [ 10, b - 33, 4 ];
            break;

           case 64 >= b:
            g = [ 11, b - 49, 4 ];
            break;

           case 96 >= b:
            g = [ 12, b - 65, 5 ];
            break;

           case 128 >= b:
            g = [ 13, b - 97, 5 ];
            break;

           case 192 >= b:
            g = [ 14, b - 129, 6 ];
            break;

           case 256 >= b:
            g = [ 15, b - 193, 6 ];
            break;

           case 384 >= b:
            g = [ 16, b - 257, 7 ];
            break;

           case 512 >= b:
            g = [ 17, b - 385, 7 ];
            break;

           case 768 >= b:
            g = [ 18, b - 513, 8 ];
            break;

           case 1024 >= b:
            g = [ 19, b - 769, 8 ];
            break;

           case 1536 >= b:
            g = [ 20, b - 1025, 9 ];
            break;

           case 2048 >= b:
            g = [ 21, b - 1537, 9 ];
            break;

           case 3072 >= b:
            g = [ 22, b - 2049, 10 ];
            break;

           case 4096 >= b:
            g = [ 23, b - 3073, 10 ];
            break;

           case 6144 >= b:
            g = [ 24, b - 4097, 11 ];
            break;

           case 8192 >= b:
            g = [ 25, b - 6145, 11 ];
            break;

           case 12288 >= b:
            g = [ 26, b - 8193, 12 ];
            break;

           case 16384 >= b:
            g = [ 27, b - 12289, 12 ];
            break;

           case 24576 >= b:
            g = [ 28, b - 16385, 13 ];
            break;

           case 32768 >= b:
            g = [ 29, b - 24577, 13 ];
            break;

           default:
            i("invalid distance");
          }
          f = g;
          d[e++] = f[0];
          d[e++] = f[1];
          d[e++] = f[2];
          var h, j;
          h = 0;
          for (j = d.length; h < j; ++h) l[q++] = d[h];
          t[d[0]]++;
          z[d[3]]++;
          E = a.length + c - 1;
          n = null;
        }
        var e, f, d, g, h, m = {}, j, s, n, l = H ? new Uint16Array(2 * c.length) : [], q = 0, E = 0, t = new (H ? Uint32Array : Array)(286), z = new (H ? Uint32Array : Array)(30), K = a.w, A;
        if (!H) {
          for (d = 0; 285 >= d; ) t[d++] = 0;
          for (d = 0; 29 >= d; ) z[d++] = 0;
        }
        t[256] = 1;
        e = 0;
        for (f = c.length; e < f; ++e) {
          d = h = 0;
          for (g = 3; d < g && e + d !== f; ++d) h = h << 8 | c[e + d];
          m[h] === r && (m[h] = []);
          j = m[h];
          if (!(0 < E--)) {
            for (;0 < j.length && 32768 < e - j[0]; ) j.shift();
            if (e + 3 >= f) {
              n && b(n, -1);
              d = 0;
              for (g = f - e; d < g; ++d) A = c[e + d], l[q++] = A, ++t[A];
              break;
            }
            if (0 < j.length) {
              var x = r, B = r, k = 0, p = r, D = r, C = r, da = r, W = c.length, D = 0, da = j.length;
              a: for (;D < da; D++) {
                x = j[da - D - 1];
                p = 3;
                if (3 < k) {
                  for (C = k; 3 < C; C--) if (c[x + C - 1] !== c[e + C - 1]) continue a;
                  p = k;
                }
                for (;258 > p && e + p < W && c[x + p] === c[e + p]; ) ++p;
                p > k && (B = x, k = p);
                if (258 === p) break;
              }
              s = new wa(k, e - B);
              n ? n.length < s.length ? (A = c[e - 1], l[q++] = A, ++t[A], b(s, 0)) : b(n, -1) : s.length < K ? n = s : b(s, 0);
            } else n ? b(n, -1) : (A = c[e], l[q++] = A, ++t[A]);
          }
          j.push(e);
        }
        l[q++] = 256;
        t[256]++;
        a.L = t;
        a.K = z;
        return H ? l.subarray(0, q) : l;
      }
      function ta(a, c) {
        function b(a) {
          var c = z[a][K[a]];
          c === n ? (b(a + 1), b(a + 1)) : --E[c];
          ++K[a];
        }
        var e = a.length, f = new la(572), d = new (H ? Uint8Array : Array)(e), g, h, m, j, s;
        if (!H) for (j = 0; j < e; j++) d[j] = 0;
        for (j = 0; j < e; ++j) 0 < a[j] && f.push(j, a[j]);
        g = Array(f.length / 2);
        h = new (H ? Uint32Array : Array)(f.length / 2);
        if (1 === g.length) return d[f.pop().index] = 1, d;
        j = 0;
        for (s = f.length / 2; j < s; ++j) g[j] = f.pop(), h[j] = g[j].value;
        var n = h.length, l = new (H ? Uint16Array : Array)(c), q = new (H ? Uint8Array : Array)(c), E = new (H ? Uint8Array : Array)(n), t = Array(c), z = Array(c), K = Array(c), A = (1 << c) - n, x = 1 << c - 1, B, k, p, D, C;
        l[c - 1] = n;
        for (k = 0; k < c; ++k) A < x ? q[k] = 0 : (q[k] = 1, A -= x), A <<= 1, l[c - 2 - k] = (l[c - 1 - k] / 2 | 0) + n;
        l[0] = q[0];
        t[0] = Array(l[0]);
        z[0] = Array(l[0]);
        for (k = 1; k < c; ++k) l[k] > 2 * l[k - 1] + q[k] && (l[k] = 2 * l[k - 1] + q[k]), 
        t[k] = Array(l[k]), z[k] = Array(l[k]);
        for (B = 0; B < n; ++B) E[B] = c;
        for (p = 0; p < l[c - 1]; ++p) t[c - 1][p] = h[p], z[c - 1][p] = p;
        for (B = 0; B < c; ++B) K[B] = 0;
        1 === q[c - 1] && (--E[0], ++K[c - 1]);
        for (k = c - 2; 0 <= k; --k) {
          D = B = 0;
          C = K[k + 1];
          for (p = 0; p < l[k]; p++) D = t[k + 1][C] + t[k + 1][C + 1], D > h[B] ? (t[k][p] = D, 
          z[k][p] = n, C += 2) : (t[k][p] = h[B], z[k][p] = B, ++B);
          K[k] = 0;
          1 === q[k] && b(k);
        }
        m = E;
        j = 0;
        for (s = g.length; j < s; ++j) d[g[j].index] = m[j];
        return d;
      }
      function ua(a) {
        var c = new (H ? Uint16Array : Array)(a.length), b = [], e = [], f = 0, d, g, h, m;
        d = 0;
        for (g = a.length; d < g; d++) b[a[d]] = 1 + (0 | b[a[d]]);
        d = 1;
        for (g = 16; d <= g; d++) e[d] = f, f += 0 | b[d], f > 1 << d && i("overcommitted"), 
        f <<= 1;
        65536 > f && i("undercommitted");
        d = 0;
        for (g = a.length; d < g; d++) {
          f = e[a[d]];
          e[a[d]] += 1;
          h = c[d] = 0;
          for (m = a[d]; h < m; h++) c[d] = c[d] << 1 | 1 & f, f >>>= 1;
        }
        return c;
      }
      function Da(a, c) {
        this.input = a;
        this.a = new (H ? Uint8Array : Array)(32768);
        this.h = U.j;
        var b = {}, e;
        !c && (c = {}) || "number" !== typeof c.compressionType || (this.h = c.compressionType);
        for (e in c) b[e] = c[e];
        b.outputBuffer = this.a;
        this.z = new ma(this.input, b);
      }
      var U = qa;
      Da.prototype.n = function() {
        var a, c, b, e, f, d, g, h = 0;
        g = this.a;
        a = Ea;
        switch (a) {
         case Ea:
          c = Math.LOG2E * Math.log(32768) - 8;
          break;

         default:
          i(Error("invalid compression method"));
        }
        b = c << 4 | a;
        g[h++] = b;
        switch (a) {
         case Ea:
          switch (this.h) {
           case U.NONE:
            f = 0;
            break;

           case U.r:
            f = 1;
            break;

           case U.j:
            f = 2;
            break;

           default:
            i(Error("unsupported compression type"));
          }
          break;

         default:
          i(Error("invalid compression method"));
        }
        e = f << 6 | 0;
        g[h++] = e | 31 - (256 * b + e) % 31;
        d = ba(this.input);
        this.z.b = h;
        g = this.z.n();
        h = g.length;
        H && (g = new Uint8Array(g.buffer), g.length <= h + 4 && (this.a = new Uint8Array(g.length + 4), 
        this.a.set(g), g = this.a), g = g.subarray(0, h + 4));
        g[h++] = d >> 24 & 255;
        g[h++] = d >> 16 & 255;
        g[h++] = d >> 8 & 255;
        g[h++] = 255 & d;
        return g;
      };
      y("Zlib.Deflate", Da);
      y("Zlib.Deflate.compress", (function(a, c) {
        return new Da(a, c).n();
      }));
      y("Zlib.Deflate.CompressionType", U);
      y("Zlib.Deflate.CompressionType.NONE", U.NONE);
      y("Zlib.Deflate.CompressionType.FIXED", U.r);
      y("Zlib.Deflate.CompressionType.DYNAMIC", U.j);
      function V(a, c) {
        this.k = [];
        this.l = 32768;
        this.e = this.g = this.c = this.q = 0;
        this.input = H ? new Uint8Array(a) : a;
        this.s = !1;
        this.m = Fa;
        this.B = !1;
        !c && (c = {}) || (c.index && (this.c = c.index), c.bufferSize && (this.l = c.bufferSize), 
        c.bufferType && (this.m = c.bufferType), c.resize && (this.B = c.resize));
        switch (this.m) {
         case Ga:
          this.b = 32768;
          this.a = new (H ? Uint8Array : Array)(32768 + this.l + 258);
          break;

         case Fa:
          this.b = 0;
          this.a = new (H ? Uint8Array : Array)(this.l);
          this.f = this.J;
          this.t = this.H;
          this.o = this.I;
          break;

         default:
          i(Error("invalid inflate mode"));
        }
      }
      var Ga = 0, Fa = 1, Ha = {
        D: Ga,
        C: Fa
      };
      V.prototype.p = function() {
        for (;!this.s; ) {
          var a = X(this, 3);
          1 & a && (this.s = v);
          a >>>= 1;
          switch (a) {
           case 0:
            var c = this.input, b = this.c, e = this.a, f = this.b, d = r, g = r, h = r, m = e.length, j = r;
            this.e = this.g = 0;
            d = c[b++];
            d === r && i(Error("invalid uncompressed block header: LEN (first byte)"));
            g = d;
            d = c[b++];
            d === r && i(Error("invalid uncompressed block header: LEN (second byte)"));
            g |= d << 8;
            d = c[b++];
            d === r && i(Error("invalid uncompressed block header: NLEN (first byte)"));
            h = d;
            d = c[b++];
            d === r && i(Error("invalid uncompressed block header: NLEN (second byte)"));
            h |= d << 8;
            g === ~h && i(Error("invalid uncompressed block header: length verify"));
            b + g > c.length && i(Error("input buffer is broken"));
            switch (this.m) {
             case Ga:
              for (;f + g > e.length; ) {
                j = m - f;
                g -= j;
                if (H) e.set(c.subarray(b, b + j), f), f += j, b += j; else for (;j--; ) e[f++] = c[b++];
                this.b = f;
                e = this.f();
                f = this.b;
              }
              break;

             case Fa:
              for (;f + g > e.length; ) e = this.f({
                v: 2
              });
              break;

             default:
              i(Error("invalid inflate mode"));
            }
            if (H) e.set(c.subarray(b, b + g), f), f += g, b += g; else for (;g--; ) e[f++] = c[b++];
            this.c = b;
            this.b = f;
            this.a = e;
            break;

           case 1:
            this.o(Ia, Ja);
            break;

           case 2:
            Ka(this);
            break;

           default:
            i(Error("unknown BTYPE: " + a));
          }
        }
        return this.t();
      };
      var La = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ], Za = H ? new Uint16Array(La) : La, $a = [ 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258 ], ab = H ? new Uint16Array($a) : $a, bb = [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0 ], cb = H ? new Uint8Array(bb) : bb, db = [ 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577 ], eb = H ? new Uint16Array(db) : db, fb = [ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ], gb = H ? new Uint8Array(fb) : fb, hb = new (H ? Uint8Array : Array)(288), Y, ib;
      Y = 0;
      for (ib = hb.length; Y < ib; ++Y) hb[Y] = 143 >= Y ? 8 : 255 >= Y ? 9 : 279 >= Y ? 7 : 8;
      var Ia = S(hb), jb = new (H ? Uint8Array : Array)(30), kb, lb;
      kb = 0;
      for (lb = jb.length; kb < lb; ++kb) jb[kb] = 5;
      var Ja = S(jb);
      function X(a, c) {
        for (var b = a.g, e = a.e, f = a.input, d = a.c, g; e < c; ) g = f[d++], g === r && i(Error("input buffer is broken")), 
        b |= g << e, e += 8;
        g = b & (1 << c) - 1;
        a.g = b >>> c;
        a.e = e - c;
        a.c = d;
        return g;
      }
      function mb(a, c) {
        for (var b = a.g, e = a.e, f = a.input, d = a.c, g = c[0], h = c[1], m, j, s; e < h; ) m = f[d++], 
        m === r && i(Error("input buffer is broken")), b |= m << e, e += 8;
        j = g[b & (1 << h) - 1];
        s = j >>> 16;
        a.g = b >> s;
        a.e = e - s;
        a.c = d;
        return 65535 & j;
      }
      function Ka(a) {
        function c(a, b, c) {
          var d, e, f, g;
          for (g = 0; g < a; ) switch (d = mb(this, b), d) {
           case 16:
            for (f = 3 + X(this, 2); f--; ) c[g++] = e;
            break;

           case 17:
            for (f = 3 + X(this, 3); f--; ) c[g++] = 0;
            e = 0;
            break;

           case 18:
            for (f = 11 + X(this, 7); f--; ) c[g++] = 0;
            e = 0;
            break;

           default:
            e = c[g++] = d;
          }
          return c;
        }
        var b = X(a, 5) + 257, e = X(a, 5) + 1, f = X(a, 4) + 4, d = new (H ? Uint8Array : Array)(Za.length), g, h, m, j;
        for (j = 0; j < f; ++j) d[Za[j]] = X(a, 3);
        g = S(d);
        h = new (H ? Uint8Array : Array)(b);
        m = new (H ? Uint8Array : Array)(e);
        a.o(S(c.call(a, b, g, h)), S(c.call(a, e, g, m)));
      }
      V.prototype.o = function(a, c) {
        var b = this.a, e = this.b;
        this.u = a;
        for (var f = b.length - 258, d, g, h, m; 256 !== (d = mb(this, a)); ) if (256 > d) e >= f && (this.b = e, 
        b = this.f(), e = this.b), b[e++] = d; else {
          g = d - 257;
          m = ab[g];
          0 < cb[g] && (m += X(this, cb[g]));
          d = mb(this, c);
          h = eb[d];
          0 < gb[d] && (h += X(this, gb[d]));
          e >= f && (this.b = e, b = this.f(), e = this.b);
          for (;m--; ) b[e] = b[e++ - h];
        }
        for (;8 <= this.e; ) this.e -= 8, this.c--;
        this.b = e;
      };
      V.prototype.I = function(a, c) {
        var b = this.a, e = this.b;
        this.u = a;
        for (var f = b.length, d, g, h, m; 256 !== (d = mb(this, a)); ) if (256 > d) e >= f && (b = this.f(), 
        f = b.length), b[e++] = d; else {
          g = d - 257;
          m = ab[g];
          0 < cb[g] && (m += X(this, cb[g]));
          d = mb(this, c);
          h = eb[d];
          0 < gb[d] && (h += X(this, gb[d]));
          e + m > f && (b = this.f(), f = b.length);
          for (;m--; ) b[e] = b[e++ - h];
        }
        for (;8 <= this.e; ) this.e -= 8, this.c--;
        this.b = e;
      };
      V.prototype.f = function() {
        var a = new (H ? Uint8Array : Array)(this.b - 32768), c = this.b - 32768, b, e, f = this.a;
        if (H) a.set(f.subarray(32768, a.length)); else {
          b = 0;
          for (e = a.length; b < e; ++b) a[b] = f[b + 32768];
        }
        this.k.push(a);
        this.q += a.length;
        if (H) f.set(f.subarray(c, c + 32768)); else for (b = 0; 32768 > b; ++b) f[b] = f[c + b];
        this.b = 32768;
        return f;
      };
      V.prototype.J = function(a) {
        var c, b = this.input.length / this.c + 1 | 0, e, f, d, g = this.input, h = this.a;
        a && ("number" === typeof a.v && (b = a.v), "number" === typeof a.F && (b += a.F));
        2 > b ? (e = (g.length - this.c) / this.u[2], d = e / 2 * 258 | 0, f = d < h.length ? h.length + d : h.length << 1) : f = h.length * b;
        H ? (c = new Uint8Array(f), c.set(h)) : c = h;
        return this.a = c;
      };
      V.prototype.t = function() {
        var a = 0, c = this.a, b = this.k, e, f = new (H ? Uint8Array : Array)(this.q + (this.b - 32768)), d, g, h, m;
        if (0 === b.length) return H ? this.a.subarray(32768, this.b) : this.a.slice(32768, this.b);
        d = 0;
        for (g = b.length; d < g; ++d) {
          e = b[d];
          h = 0;
          for (m = e.length; h < m; ++h) f[a++] = e[h];
        }
        d = 32768;
        for (g = this.b; d < g; ++d) f[a++] = c[d];
        this.k = [];
        return this.buffer = f;
      };
      V.prototype.H = function() {
        var a, c = this.b;
        H ? this.B ? (a = new Uint8Array(c), a.set(this.a.subarray(0, c))) : a = this.a.subarray(0, c) : (this.a.length > c && (this.a.length = c), 
        a = this.a);
        return this.buffer = a;
      };
      function nb(a, c) {
        var b, e;
        this.input = a;
        this.c = 0;
        !c && (c = {}) || (c.index && (this.c = c.index), c.verify && (this.M = c.verify));
        b = a[this.c++];
        e = a[this.c++];
        switch (15 & b) {
         case Ea:
          this.method = Ea;
          break;

         default:
          i(Error("unsupported compression method"));
        }
        0 !== ((b << 8) + e) % 31 && i(Error("invalid fcheck flag:" + ((b << 8) + e) % 31));
        32 & e && i(Error("fdict flag is not supported"));
        this.A = new V(a, {
          index: this.c,
          bufferSize: c.bufferSize,
          bufferType: c.bufferType,
          resize: c.resize
        });
      }
      nb.prototype.p = function() {
        var a = this.input, c, b;
        c = this.A.p();
        this.c = this.A.c;
        this.M && (b = (a[this.c++] << 24 | a[this.c++] << 16 | a[this.c++] << 8 | a[this.c++]) >>> 0, 
        b !== ba(c) && i(Error("invalid adler-32 checksum")));
        return c;
      };
      y("Zlib.Inflate", nb);
      y("Zlib.Inflate.BufferType", Ha);
      Ha.ADAPTIVE = Ha.C;
      Ha.BLOCK = Ha.D;
      y("Zlib.Inflate.prototype.decompress", nb.prototype.p);
      var ob = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];
      H && new Uint16Array(ob);
      var pb = [ 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258 ];
      H && new Uint16Array(pb);
      var qb = [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0 ];
      H && new Uint8Array(qb);
      var rb = [ 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577 ];
      H && new Uint16Array(rb);
      var sb = [ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ];
      H && new Uint8Array(sb);
      var tb = new (H ? Uint8Array : Array)(288), Z, ub;
      Z = 0;
      for (ub = tb.length; Z < ub; ++Z) tb[Z] = 143 >= Z ? 8 : 255 >= Z ? 9 : 279 >= Z ? 7 : 8;
      S(tb);
      var vb = new (H ? Uint8Array : Array)(30), wb, xb;
      wb = 0;
      for (xb = vb.length; wb < xb; ++wb) vb[wb] = 5;
      S(vb);
      var Ea = 8;
    }).call(window);
    var _p = window.Zlib;
    _p.Deflate = _p["Deflate"];
    _p.Deflate.compress = _p.Deflate["compress"];
    _p.Inflate = _p["Inflate"];
    _p.Inflate.BufferType = _p.Inflate["BufferType"];
    _p.Inflate.prototype.decompress = _p.Inflate.prototype["decompress"];
    module.exports = _p;
  }), {} ],
  32: [ (function(require, module, exports) {
    cc.configuration = {
      ERROR: 0,
      STRING: 1,
      INT: 2,
      DOUBLE: 3,
      BOOLEAN: 4,
      _maxTextureSize: 0,
      _maxModelviewStackDepth: 0,
      _supportsPVRTC: false,
      _supportsNPOT: false,
      _supportsBGRA8888: false,
      _supportsDiscardFramebuffer: false,
      _supportsShareableVAO: false,
      _maxSamplesAllowed: 0,
      _maxTextureUnits: 0,
      _GlExtensions: "",
      _valueDict: {},
      _inited: false,
      _init: function() {
        var locValueDict = this._valueDict;
        locValueDict["cocos2d.x.version"] = cc.ENGINE_VERSION;
        locValueDict["cocos2d.x.compiled_with_profiler"] = false;
        locValueDict["cocos2d.x.compiled_with_gl_state_cache"] = cc.macro.ENABLE_GL_STATE_CACHE;
        this._inited = true;
      },
      getMaxTextureSize: function() {
        return this._maxTextureSize;
      },
      getMaxModelviewStackDepth: function() {
        return this._maxModelviewStackDepth;
      },
      getMaxTextureUnits: function() {
        return this._maxTextureUnits;
      },
      supportsNPOT: function() {
        return this._supportsNPOT;
      },
      supportsPVRTC: function() {
        return this._supportsPVRTC;
      },
      supportsETC: function() {
        return false;
      },
      supportsS3TC: function() {
        return false;
      },
      supportsATITC: function() {
        return false;
      },
      supportsBGRA8888: function() {
        return this._supportsBGRA8888;
      },
      supportsDiscardFramebuffer: function() {
        return this._supportsDiscardFramebuffer;
      },
      supportsShareableVAO: function() {
        return this._supportsShareableVAO;
      },
      checkForGLExtension: function(searchName) {
        return this._GlExtensions.indexOf(searchName) > -1;
      },
      getValue: function(key, default_value) {
        this._inited || this._init();
        var locValueDict = this._valueDict;
        if (locValueDict[key]) return locValueDict[key];
        return default_value;
      },
      setValue: function(key, value) {
        this._valueDict[key] = value;
      },
      gatherGPUInfo: function() {
        if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) return;
        this._inited || this._init();
        var gl = cc._renderContext;
        var locValueDict = this._valueDict;
        locValueDict["gl.vendor"] = gl.getParameter(gl.VENDOR);
        locValueDict["gl.renderer"] = gl.getParameter(gl.RENDERER);
        locValueDict["gl.version"] = gl.getParameter(gl.VERSION);
        this._GlExtensions = "";
        var extArr = gl.getSupportedExtensions();
        for (var i = 0; i < extArr.length; i++) this._GlExtensions += extArr[i] + " ";
        this._maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
        locValueDict["gl.max_texture_size"] = this._maxTextureSize;
        this._maxTextureUnits = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        locValueDict["gl.max_texture_units"] = this._maxTextureUnits;
        this._supportsPVRTC = this.checkForGLExtension("GL_IMG_texture_compression_pvrtc");
        locValueDict["gl.supports_PVRTC"] = this._supportsPVRTC;
        this._supportsNPOT = false;
        locValueDict["gl.supports_NPOT"] = this._supportsNPOT;
        this._supportsBGRA8888 = this.checkForGLExtension("GL_IMG_texture_format_BGRA888");
        locValueDict["gl.supports_BGRA8888"] = this._supportsBGRA8888;
        this._supportsDiscardFramebuffer = this.checkForGLExtension("GL_EXT_discard_framebuffer");
        locValueDict["gl.supports_discard_framebuffer"] = this._supportsDiscardFramebuffer;
        this._supportsShareableVAO = this.checkForGLExtension("vertex_array_object");
        locValueDict["gl.supports_vertex_array_object"] = this._supportsShareableVAO;
        cc.checkGLErrorDebug();
      },
      loadConfigFile: function(url) {
        this._inited || this._init();
        var dict = cc.loader.getRes(url);
        if (!dict) throw new Error("Please load the resource first : " + url);
        cc.assertID(dict, 1101, url);
        var getDatas = dict["data"];
        if (!getDatas) {
          cc.logID(1100, url);
          return;
        }
        for (var selKey in getDatas) this._valueDict[selKey] = getDatas[selKey];
      }
    };
  }), {} ],
  33: [ (function(require, module, exports) {
    var EventTarget = require("./event/event-target");
    var Class = require("./platform/_CCClass");
    var AutoReleaseUtils = require("./load-pipeline/auto-release-utils");
    var ComponentScheduler = require("./component-scheduler");
    var NodeActivator = require("./node-activator");
    var EventListeners = require("./event/event-listeners");
    cc.g_NumberOfDraws = 0;
    cc.Director = Class.extend({
      ctor: function() {
        var self = this;
        EventTarget.call(self);
        self._landscape = false;
        self._nextDeltaTimeZero = false;
        self._paused = false;
        self._purgeDirectorInNextLoop = false;
        self._sendCleanupToScene = false;
        self._animationInterval = 0;
        self._oldAnimationInterval = 0;
        self._projection = 0;
        self._projectionDelegate = null;
        self._contentScaleFactor = 1;
        self._winSizeInPoints = null;
        self._openGLView = null;
        self._scenesStack = null;
        self._nextScene = null;
        self._loadingScene = "";
        self._runningScene = null;
        self._scene = null;
        self._totalFrames = 0;
        self._lastUpdate = Date.now();
        self._deltaTime = 0;
        self._dirtyRegion = null;
        self._scheduler = null;
        self._compScheduler = null;
        self._nodeActivator = null;
        self._actionManager = null;
        cc.game.on(cc.game.EVENT_SHOW, (function() {
          self._lastUpdate = Date.now();
        }));
      },
      init: function() {
        this._oldAnimationInterval = this._animationInterval = 1 / cc.defaultFPS;
        this._scenesStack = [];
        this._projection = cc.Director.PROJECTION_DEFAULT;
        this._projectionDelegate = null;
        this._totalFrames = 0;
        this._lastUpdate = Date.now();
        this._paused = false;
        this._purgeDirectorInNextLoop = false;
        this._winSizeInPoints = cc.size(0, 0);
        this._openGLView = null;
        this._contentScaleFactor = 1;
        this._scheduler = new cc.Scheduler();
        if (cc.ActionManager) {
          this._actionManager = new cc.ActionManager();
          this._scheduler.scheduleUpdate(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        } else this._actionManager = null;
        this.sharedInit();
        return true;
      },
      sharedInit: function() {
        this._compScheduler = new ComponentScheduler();
        this._nodeActivator = new NodeActivator();
        if (cc.AnimationManager) {
          this._animationManager = new cc.AnimationManager();
          this._scheduler.scheduleUpdate(this._animationManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        } else this._animationManager = null;
        if (cc.CollisionManager) {
          this._collisionManager = new cc.CollisionManager();
          this._scheduler.scheduleUpdate(this._collisionManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        } else this._collisionManager = null;
        if (cc.PhysicsManager) {
          this._physicsManager = new cc.PhysicsManager();
          this._scheduler.scheduleUpdate(this._physicsManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        } else this._physicsManager = null;
        cc._widgetManager && cc._widgetManager.init(this);
        cc.loader.init(this);
      },
      calculateDeltaTime: function() {
        var now = Date.now();
        if (this._nextDeltaTimeZero) {
          this._deltaTime = 0;
          this._nextDeltaTimeZero = false;
        } else {
          this._deltaTime = (now - this._lastUpdate) / 1e3;
          cc.game.config[cc.game.CONFIG_KEY.debugMode] > 0 && this._deltaTime > 1 && (this._deltaTime = 1 / 60);
        }
        this._lastUpdate = now;
      },
      convertToGL: function(uiPoint) {
        var container = cc.game.container;
        var view = cc.view;
        var box = container.getBoundingClientRect();
        var left = box.left + window.pageXOffset - container.clientLeft;
        var top = box.top + window.pageYOffset - container.clientTop;
        var x = view._devicePixelRatio * (uiPoint.x - left);
        var y = view._devicePixelRatio * (top + box.height - uiPoint.y);
        return view._isRotated ? {
          x: view._viewPortRect.width - y,
          y: x
        } : {
          x: x,
          y: y
        };
      },
      convertToUI: function(glPoint) {
        var container = cc.game.container;
        var view = cc.view;
        var box = container.getBoundingClientRect();
        var left = box.left + window.pageXOffset - container.clientLeft;
        var top = box.top + window.pageYOffset - container.clientTop;
        var uiPoint = {
          x: 0,
          y: 0
        };
        if (view._isRotated) {
          uiPoint.x = left + glPoint.y / view._devicePixelRatio;
          uiPoint.y = top + box.height - (view._viewPortRect.width - glPoint.x) / view._devicePixelRatio;
        } else {
          uiPoint.x = left + glPoint.x * view._devicePixelRatio;
          uiPoint.y = top + box.height - glPoint.y * view._devicePixelRatio;
        }
        return uiPoint;
      },
      _visitScene: function() {
        if (this._runningScene) {
          var renderer = cc.renderer;
          if (renderer.childrenOrderDirty) {
            renderer.clearRenderCommands();
            cc.renderer.assignedZ = 0;
            this._runningScene._renderCmd._curLevel = 0;
            this._runningScene.visit();
            renderer.resetFlag();
          } else renderer.transformDirty() && renderer.transform();
        }
      },
      end: function() {
        this._purgeDirectorInNextLoop = true;
      },
      getContentScaleFactor: function() {
        return this._contentScaleFactor;
      },
      getWinSize: function() {
        return cc.size(this._winSizeInPoints);
      },
      getWinSizeInPixels: function() {
        return cc.size(this._winSizeInPoints.width * this._contentScaleFactor, this._winSizeInPoints.height * this._contentScaleFactor);
      },
      getVisibleSize: null,
      getVisibleOrigin: null,
      getZEye: null,
      pause: function() {
        if (this._paused) return;
        this._oldAnimationInterval = this._animationInterval;
        this.setAnimationInterval(.25);
        this._paused = true;
      },
      popScene: function() {
        cc.assertID(this._runningScene, 1204);
        this._scenesStack.pop();
        var c = this._scenesStack.length;
        if (0 === c) this.end(); else {
          this._sendCleanupToScene = true;
          this._nextScene = this._scenesStack[c - 1];
        }
      },
      purgeCachedData: function() {
        cc.textureCache._clear();
        cc.loader.releaseAll();
      },
      purgeDirector: function() {
        this.getScheduler().unscheduleAll();
        this._compScheduler.unscheduleAll();
        this._nodeActivator.reset();
        cc.eventManager && cc.eventManager.setEnabled(false);
        if (this._runningScene) {
          this._runningScene.performRecursive(_ccsg.Node.performType.onExitTransitionDidStart);
          this._runningScene.performRecursive(_ccsg.Node.performType.onExit);
          this._runningScene.performRecursive(_ccsg.Node.performType.cleanup);
          cc.renderer.clearRenderCommands();
        }
        this._runningScene = null;
        this._nextScene = null;
        this._scenesStack.length = 0;
        this.stopAnimation();
        this.purgeCachedData();
        true;
        cc.checkGLErrorDebug();
      },
      reset: function() {
        this.purgeDirector();
        cc.eventManager && cc.eventManager.setEnabled(true);
        this._actionManager && this._scheduler.scheduleUpdate(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        this._animationManager && this._scheduler.scheduleUpdate(this._animationManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        this._collisionManager && this._scheduler.scheduleUpdate(this._collisionManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        this._physicsManager && this._scheduler.scheduleUpdate(this._physicsManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        this.startAnimation();
      },
      pushScene: function(scene) {
        cc.assertID(scene, 1205);
        this._sendCleanupToScene = false;
        this._scenesStack.push(scene);
        this._nextScene = scene;
      },
      runSceneImmediate: function(scene, onBeforeLoadScene, onLaunched) {
        if (scene instanceof cc.Scene) {
          false;
          scene._load();
          false;
        }
        var game = cc.game;
        var persistNodeList = Object.keys(game._persistRootNodes).map((function(x) {
          return game._persistRootNodes[x];
        }));
        for (var _i = 0; _i < persistNodeList.length; _i++) {
          var node = persistNodeList[_i];
          game._ignoreRemovePersistNode = node;
          node.parent = null;
          game._ignoreRemovePersistNode = null;
        }
        var oldScene = this._scene;
        true;
        false;
        var autoReleaseAssets = oldScene && oldScene.autoReleaseAssets && oldScene.dependAssets;
        AutoReleaseUtils.autoRelease(autoReleaseAssets, scene.dependAssets, persistNodeList);
        false;
        false;
        cc.isValid(oldScene) && oldScene.destroy();
        this._scene = null;
        cc.Object._deferredDestroy();
        false;
        onBeforeLoadScene && onBeforeLoadScene();
        this.emit(cc.Director.EVENT_BEFORE_SCENE_LAUNCH, scene);
        var sgScene = scene;
        if (scene instanceof cc.Scene) {
          this._scene = scene;
          sgScene = scene._sgNode;
          false;
          for (var _i2 = 0; _i2 < persistNodeList.length; _i2++) {
            var _node = persistNodeList[_i2];
            var existNode = scene.getChildByUuid(_node.uuid);
            if (existNode) {
              var index = existNode.getSiblingIndex();
              existNode._destroyImmediate();
              scene.insertChild(_node, index);
            } else _node.parent = scene;
          }
          false;
          false;
          scene._activate();
          false;
        }
        if (this._runningScene) {
          var i = this._scenesStack.length;
          this._scenesStack[Math.max(i - 1, 0)] = sgScene;
          this._sendCleanupToScene = true;
          this._nextScene = sgScene;
        } else {
          this.pushScene(sgScene);
          this.startAnimation();
        }
        this._nextScene && this.setNextScene();
        onLaunched && onLaunched(null, scene);
        this.emit(cc.Director.EVENT_AFTER_SCENE_LAUNCH, scene);
      },
      runScene: function(scene, onBeforeLoadScene, onLaunched) {
        cc.assertID(scene, 1205);
        scene instanceof cc.Scene && scene._load();
        this.once(cc.Director.EVENT_AFTER_UPDATE, (function() {
          this.runSceneImmediate(scene, onBeforeLoadScene, onLaunched);
        }));
      },
      _getSceneUuid: function(key) {
        var scenes = cc.game._sceneInfos;
        if ("string" === typeof key) {
          key.endsWith(".fire") || (key += ".fire");
          "/" === key[0] || key.startsWith("db://assets/") || (key = "/" + key);
          for (var i = 0; i < scenes.length; i++) {
            var info = scenes[i];
            if (info.url.endsWith(key)) return info;
          }
        } else if ("number" === typeof key) {
          if (0 <= key && key < scenes.length) return scenes[key];
          cc.errorID(1206, key);
        } else cc.errorID(1207, key);
        return null;
      },
      loadScene: function(sceneName, onLaunched, _onUnloaded) {
        if (this._loadingScene) {
          cc.errorID(1208, sceneName, this._loadingScene);
          return false;
        }
        var info = this._getSceneUuid(sceneName);
        if (info) {
          var uuid = info.uuid;
          this.emit(cc.Director.EVENT_BEFORE_SCENE_LOADING, sceneName);
          this._loadingScene = sceneName;
          var self;
          var groupName;
          var ensureAsync;
          false;
          this._loadSceneByUuid(uuid, onLaunched, _onUnloaded);
          return true;
        }
        cc.errorID(1209, sceneName);
        return false;
      },
      preloadScene: function(sceneName, onLoaded) {
        var info = this._getSceneUuid(sceneName);
        if (info) {
          this.emit(cc.Director.EVENT_BEFORE_SCENE_LOADING, sceneName);
          cc.loader.load({
            uuid: info.uuid,
            type: "uuid"
          }, (function(error, asset) {
            error && cc.errorID(1210, sceneName, error.message);
            onLoaded && onLoaded(error, asset);
          }));
        } else {
          var error = 'Can not preload the scene "' + sceneName + '" because it is not in the build settings.';
          onLoaded(new Error(error));
          cc.error("preloadScene: " + error);
        }
      },
      _loadSceneByUuid: function(uuid, onLaunched, onUnloaded, dontRunScene) {
        false;
        console.time("LoadScene " + uuid);
        cc.AssetLibrary.loadAsset(uuid, (function(error, sceneAsset) {
          console.timeEnd("LoadScene " + uuid);
          var self = cc.director;
          self._loadingScene = "";
          if (error) {
            error = "Failed to load scene: " + error;
            cc.error(error);
          } else {
            if (sceneAsset instanceof cc.SceneAsset) {
              var scene = sceneAsset.scene;
              scene._id = sceneAsset._uuid;
              scene._name = sceneAsset._name;
              false;
              self.runSceneImmediate(scene, onUnloaded, onLaunched);
              return;
            }
            error = "The asset " + uuid + " is not a scene";
            cc.error(error);
          }
          onLaunched && onLaunched(error);
        }));
      },
      resume: function() {
        if (!this._paused) return;
        this.setAnimationInterval(this._oldAnimationInterval);
        this._lastUpdate = Date.now();
        this._lastUpdate || cc.logID(1200);
        this._paused = false;
        this._deltaTime = 0;
      },
      setContentScaleFactor: function(scaleFactor) {
        scaleFactor !== this._contentScaleFactor && (this._contentScaleFactor = scaleFactor);
      },
      setDepthTest: null,
      setClearColor: null,
      setDefaultValues: function() {},
      setNextDeltaTimeZero: function(nextDeltaTimeZero) {
        this._nextDeltaTimeZero = nextDeltaTimeZero;
      },
      setNextScene: function() {
        var runningIsTransition = false, newIsTransition = false;
        if (cc.TransitionScene) {
          runningIsTransition = !!this._runningScene && this._runningScene instanceof cc.TransitionScene;
          newIsTransition = !!this._nextScene && this._nextScene instanceof cc.TransitionScene;
        }
        if (!newIsTransition) {
          var locRunningScene = this._runningScene;
          if (locRunningScene) {
            locRunningScene.performRecursive(_ccsg.Node.performType.onExitTransitionDidStart);
            locRunningScene.performRecursive(_ccsg.Node.performType.onExit);
          }
          this._sendCleanupToScene && locRunningScene && locRunningScene.performRecursive(_ccsg.Node.performType.cleanup);
        }
        this._runningScene = this._nextScene;
        cc.renderer.childrenOrderDirty = true;
        this._nextScene = null;
        if (!runningIsTransition && null !== this._runningScene) {
          this._runningScene.performRecursive(_ccsg.Node.performType.onEnter);
          this._runningScene.performRecursive(_ccsg.Node.performType.onEnterTransitionDidFinish);
        }
      },
      getDelegate: function() {
        return this._projectionDelegate;
      },
      setDelegate: function(delegate) {
        this._projectionDelegate = delegate;
      },
      setOpenGLView: null,
      setProjection: null,
      setViewport: null,
      getOpenGLView: null,
      getProjection: null,
      setAlphaBlending: null,
      isSendCleanupToScene: function() {
        return this._sendCleanupToScene;
      },
      getRunningScene: function() {
        return this._runningScene;
      },
      getScene: function() {
        return this._scene;
      },
      getAnimationInterval: function() {
        return this._animationInterval;
      },
      isDisplayStats: function() {
        return !!cc.profiler && cc.profiler.isShowingStats();
      },
      setDisplayStats: function(displayStats) {
        if (cc.profiler) {
          displayStats ? cc.profiler.showStats() : cc.profiler.hideStats();
          cc.game.config[cc.game.CONFIG_KEY.showFPS] = !!displayStats;
        }
      },
      isNextDeltaTimeZero: function() {
        return this._nextDeltaTimeZero;
      },
      isPaused: function() {
        return this._paused;
      },
      getTotalFrames: function() {
        return this._totalFrames;
      },
      popToRootScene: function() {
        this.popToSceneStackLevel(1);
      },
      popToSceneStackLevel: function(level) {
        cc.assertID(this._runningScene, 1203);
        var locScenesStack = this._scenesStack;
        var c = locScenesStack.length;
        if (0 === c) {
          this.end();
          return;
        }
        if (level > c) return;
        while (c > level) {
          var current = locScenesStack.pop();
          if (current.running) {
            current.performRecursive(_ccsg.Node.performType.onExitTransitionDidStart);
            current.performRecursive(_ccsg.Node.performType.onExit);
          }
          current.performRecursive(_ccsg.Node.performType.cleanup);
          c--;
        }
        this._nextScene = locScenesStack[locScenesStack.length - 1];
        this._sendCleanupToScene = true;
      },
      getScheduler: function() {
        return this._scheduler;
      },
      setScheduler: function(scheduler) {
        this._scheduler !== scheduler && (this._scheduler = scheduler);
      },
      getActionManager: function() {
        return this._actionManager;
      },
      setActionManager: function(actionManager) {
        if (this._actionManager !== actionManager) {
          this._actionManager && this._scheduler.unscheduleUpdate(this._actionManager);
          this._actionManager = actionManager;
          this._scheduler.scheduleUpdate(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        }
      },
      getAnimationManager: function() {
        return this._animationManager;
      },
      getCollisionManager: function() {
        return this._collisionManager;
      },
      getPhysicsManager: function() {
        return this._physicsManager;
      },
      getDeltaTime: function() {
        return this._deltaTime;
      }
    });
    cc.js.addon(cc.Director.prototype, EventTarget.prototype);
    cc.Director.EVENT_PROJECTION_CHANGED = "director_projection_changed";
    cc.Director.EVENT_BEFORE_SCENE_LOADING = "director_before_scene_loading";
    cc.Director.EVENT_BEFORE_SCENE_LAUNCH = "director_before_scene_launch";
    cc.Director.EVENT_AFTER_SCENE_LAUNCH = "director_after_scene_launch";
    cc.Director.EVENT_BEFORE_UPDATE = "director_before_update";
    cc.Director.EVENT_AFTER_UPDATE = "director_after_update";
    cc.Director.EVENT_BEFORE_VISIT = "director_before_visit";
    cc.Director.EVENT_AFTER_VISIT = "director_after_visit";
    cc.Director.EVENT_AFTER_DRAW = "director_after_draw";
    cc.DisplayLinkDirector = cc.Director.extend({
      invalid: false,
      startAnimation: function() {
        this._nextDeltaTimeZero = true;
        this.invalid = false;
      },
      mainLoop: function() {
        if (this._purgeDirectorInNextLoop) {
          this._purgeDirectorInNextLoop = false;
          this.purgeDirector();
        } else if (!this.invalid) {
          this.calculateDeltaTime();
          if (!this._paused) {
            this.emit(cc.Director.EVENT_BEFORE_UPDATE);
            this._compScheduler.startPhase();
            this._compScheduler.updatePhase(this._deltaTime);
            this._scheduler.update(this._deltaTime);
            this._compScheduler.lateUpdatePhase(this._deltaTime);
            this.emit(cc.Director.EVENT_AFTER_UPDATE);
            cc.Object._deferredDestroy();
          }
          this._nextScene && this.setNextScene();
          this.emit(cc.Director.EVENT_BEFORE_VISIT);
          this._visitScene();
          this.emit(cc.Director.EVENT_AFTER_VISIT);
          cc.g_NumberOfDraws = 0;
          cc.renderer.clear();
          cc.renderer.rendering(cc._renderContext);
          this._totalFrames++;
          this.emit(cc.Director.EVENT_AFTER_DRAW);
          cc.eventManager.frameUpdateListeners();
        }
      },
      stopAnimation: function() {
        this.invalid = true;
      },
      setAnimationInterval: function(value) {
        this._animationInterval = value;
        if (!this.invalid) {
          this.stopAnimation();
          this.startAnimation();
        }
      },
      __fastOn: function(type, callback, target) {
        var listeners = this._bubblingListeners;
        listeners || (listeners = this._bubblingListeners = new EventListeners());
        listeners.add(type, callback, target);
        this._addEventFlag(type, listeners, false);
      },
      __fastOff: function(type, callback, target) {
        var listeners = this._bubblingListeners;
        if (listeners) {
          listeners.remove(type, callback, target);
          this._purgeEventFlag(type, listeners, false);
        }
      }
    });
    cc.Director.sharedDirector = null;
    cc.Director.firstUseDirector = true;
    cc.Director._getInstance = function() {
      if (cc.Director.firstUseDirector) {
        cc.Director.firstUseDirector = false;
        cc.Director.sharedDirector = new cc.DisplayLinkDirector();
        cc.Director.sharedDirector.init();
      }
      return cc.Director.sharedDirector;
    };
    cc.defaultFPS = 60;
    cc.Director.PROJECTION_2D = 0;
    cc.Director.PROJECTION_3D = 1;
    cc.Director.PROJECTION_CUSTOM = 3;
    cc.Director.PROJECTION_DEFAULT = cc.Director.PROJECTION_2D;
  }), {
    "./component-scheduler": 70,
    "./event/event-listeners": 112,
    "./event/event-target": 113,
    "./load-pipeline/auto-release-utils": 134,
    "./node-activator": 147,
    "./platform/_CCClass": 187
  } ],
  34: [ (function(require, module, exports) {
    require("./CCDirector");
    require("./CCGame");
    cc.game.once(cc.game.EVENT_RENDERER_INITED, (function() {
      if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
        var _p = cc.Director.prototype;
        _p.getProjection = function(projection) {
          return this._projection;
        };
        _p.setProjection = function(projection) {
          this._projection = projection;
          this.emit(cc.Director.EVENT_PROJECTION_CHANGED, this);
        };
        _p.setDepthTest = function() {};
        _p.setClearColor = function(clearColor) {
          cc.renderer._clearColor = clearColor;
          cc.renderer._clearFillStyle = "rgb(" + clearColor.r + "," + clearColor.g + "," + clearColor.b + ")";
        };
        _p.setOpenGLView = function(openGLView) {
          this._winSizeInPoints.width = cc._canvas.width;
          this._winSizeInPoints.height = cc._canvas.height;
          this._openGLView = openGLView || cc.view;
          cc.eventManager && cc.eventManager.setEnabled(true);
        };
        _p.getVisibleSize = function() {
          return this.getWinSize();
        };
        _p.getVisibleOrigin = function() {
          return cc.p(0, 0);
        };
      }
    }));
  }), {
    "./CCDirector": 33,
    "./CCGame": 39
  } ],
  35: [ (function(require, module, exports) {
    require("./CCDirector");
    require("./CCGame");
    require("../kazmath");
    var math = cc.math;
    cc.game.once(cc.game.EVENT_RENDERER_INITED, (function() {
      if (cc._renderType !== cc.game.RENDER_TYPE_WEBGL) return;
      cc.DirectorDelegate = cc._Class.extend({
        updateProjection: function() {}
      });
      var _p = cc.Director.prototype;
      var recursiveChild = function(node) {
        if (node && node._renderCmd) {
          node._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
          var i, children = node._children;
          for (i = 0; i < children.length; i++) recursiveChild(children[i]);
        }
      };
      cc.Director._getInstance().on(cc.Director.EVENT_PROJECTION_CHANGED, (function() {
        var stack = cc.director._scenesStack;
        for (var i = 0; i < stack.length; i++) recursiveChild(stack[i]);
      }));
      _p.setProjection = function(projection) {
        var _t = this;
        var size = _t._winSizeInPoints;
        _t.setViewport();
        var view = _t._openGLView, ox = view._viewPortRect.x / view._scaleX, oy = view._viewPortRect.y / view._scaleY;
        switch (projection) {
         case cc.Director.PROJECTION_2D:
          math.glMatrixMode(math.KM_GL_PROJECTION);
          math.glLoadIdentity();
          var orthoMatrix = math.Matrix4.createOrthographicProjection(0, size.width, 0, size.height, -1024, 1024);
          math.glMultMatrix(orthoMatrix);
          math.glMatrixMode(math.KM_GL_MODELVIEW);
          math.glLoadIdentity();
          break;

         case cc.Director.PROJECTION_3D:
          var zeye = _t.getZEye();
          var matrixPerspective = new math.Matrix4(), matrixLookup = new math.Matrix4();
          math.glMatrixMode(math.KM_GL_PROJECTION);
          math.glLoadIdentity();
          matrixPerspective = math.Matrix4.createPerspectiveProjection(60, size.width / size.height, .1, 2 * zeye);
          math.glMultMatrix(matrixPerspective);
          var eye = new math.Vec3(-ox + size.width / 2, -oy + size.height / 2, zeye);
          var center = new math.Vec3(-ox + size.width / 2, -oy + size.height / 2, 0);
          var up = new math.Vec3(0, 1, 0);
          matrixLookup.lookAt(eye, center, up);
          math.glMultMatrix(matrixLookup);
          math.glMatrixMode(math.KM_GL_MODELVIEW);
          math.glLoadIdentity();
          break;

         case cc.Director.PROJECTION_CUSTOM:
          _t._projectionDelegate && _t._projectionDelegate.updateProjection();
          break;

         default:
          cc.logID(1201);
        }
        _t._projection = projection;
        _t.emit(cc.Director.EVENT_PROJECTION_CHANGED, _t);
        cc.gl.setProjectionMatrixDirty();
        cc.renderer.childrenOrderDirty = true;
      };
      _p.setDepthTest = function(on) {
        cc.renderer.setDepthTest(on);
      };
      _p.setClearColor = function(clearColor) {
        var locClearColor = cc.renderer._clearColor;
        locClearColor.r = clearColor.r / 255;
        locClearColor.g = clearColor.g / 255;
        locClearColor.b = clearColor.b / 255;
        locClearColor.a = clearColor.a / 255;
      };
      _p.setOpenGLView = function(openGLView) {
        var _t = this;
        _t._winSizeInPoints.width = cc._canvas.width;
        _t._winSizeInPoints.height = cc._canvas.height;
        _t._openGLView = openGLView || cc.view;
        var conf = cc.configuration;
        conf.gatherGPUInfo();
        _t.setGLDefaultValues();
        cc.eventManager && cc.eventManager.setEnabled(true);
      };
      _p.getVisibleSize = function() {
        return this._openGLView.getVisibleSize();
      };
      _p.getVisibleOrigin = function() {
        return this._openGLView.getVisibleOrigin();
      };
      _p.getZEye = function() {
        return this._winSizeInPoints.height / 1.1566;
      };
      _p.setViewport = function() {
        var view = this._openGLView;
        if (view) {
          var locWinSizeInPoints = this._winSizeInPoints;
          view.setViewPortInPoints(-view._viewPortRect.x / view._scaleX, -view._viewPortRect.y / view._scaleY, locWinSizeInPoints.width, locWinSizeInPoints.height);
        }
      };
      _p.getOpenGLView = function() {
        return this._openGLView;
      };
      _p.getProjection = function() {
        return this._projection;
      };
      _p.setAlphaBlending = function(on) {
        on ? cc.gl.blendFunc(cc.macro.BLEND_SRC, cc.macro.BLEND_DST) : cc.gl.blendFunc(cc.macro.ONE, cc.macro.ZERO);
      };
      _p.setGLDefaultValues = function() {
        var _t = this;
        _t.setAlphaBlending(true);
        _t.setProjection(_t._projection);
        cc._renderContext.clearColor(0, 0, 0, 0);
      };
    }));
  }), {
    "../kazmath": 246,
    "./CCDirector": 33,
    "./CCGame": 39
  } ],
  36: [ (function(require, module, exports) {
    var game = require("./CCGame");
    cc._drawingUtil = null;
    game.once(game.EVENT_RENDERER_INITED, (function() {
      cc._renderType === game.RENDER_TYPE_WEBGL ? cc._drawingUtil = new (require("./CCDrawingPrimitivesWebGL"))(cc._renderContext) : cc._drawingUtil = new (require("./CCDrawingPrimitivesCanvas"))(cc._renderContext);
    }));
  }), {
    "./CCDrawingPrimitivesCanvas": 37,
    "./CCDrawingPrimitivesWebGL": 38,
    "./CCGame": 39
  } ],
  37: [ (function(require, module, exports) {
    var DrawingPrimitiveCanvas = cc._Class.extend({
      _cacheArray: [],
      ctor: function(renderContext) {
        this._renderContext = renderContext;
      },
      drawPoint: function(point, size) {
        size || (size = 1);
        var locScaleX = cc.view.getScaleX(), locScaleY = cc.view.getScaleY();
        var newPoint = cc.p(point.x * locScaleX, point.y * locScaleY);
        var ctx = this._renderContext.getContext();
        ctx.beginPath();
        ctx.arc(newPoint.x, -newPoint.y, size * locScaleX, 0, 2 * Math.PI, false);
        ctx.closePath();
        ctx.fill();
      },
      drawPoints: function(points, numberOfPoints, size) {
        if (null == points) return;
        size || (size = 1);
        var locContext = this._renderContext.getContext(), locScaleX = cc.view.getScaleX(), locScaleY = cc.view.getScaleY();
        locContext.beginPath();
        for (var i = 0, len = points.length; i < len; i++) locContext.arc(points[i].x * locScaleX, -points[i].y * locScaleY, size * locScaleX, 0, 2 * Math.PI, false);
        locContext.closePath();
        locContext.fill();
      },
      drawLine: function(origin, destination) {
        var locContext = this._renderContext.getContext(), locScaleX = cc.view.getScaleX(), locScaleY = cc.view.getScaleY();
        locContext.beginPath();
        locContext.moveTo(origin.x * locScaleX, -origin.y * locScaleY);
        locContext.lineTo(destination.x * locScaleX, -destination.y * locScaleY);
        locContext.closePath();
        locContext.stroke();
      },
      drawRect: function(origin, destination) {
        this.drawLine(cc.p(origin.x, origin.y), cc.p(destination.x, origin.y));
        this.drawLine(cc.p(destination.x, origin.y), cc.p(destination.x, destination.y));
        this.drawLine(cc.p(destination.x, destination.y), cc.p(origin.x, destination.y));
        this.drawLine(cc.p(origin.x, destination.y), cc.p(origin.x, origin.y));
      },
      drawSolidRect: function(origin, destination, color) {
        var vertices = [ origin, cc.p(destination.x, origin.y), destination, cc.p(origin.x, destination.y) ];
        this.drawSolidPoly(vertices, 4, color);
      },
      drawPoly: function(vertices, numOfVertices, closePolygon, fill) {
        fill = fill || false;
        if (null == vertices) return;
        if (vertices.length < 3) throw new Error("Polygon's point must greater than 2");
        var firstPoint = vertices[0], locContext = this._renderContext.getContext();
        var locScaleX = cc.view.getScaleX(), locScaleY = cc.view.getScaleY();
        locContext.beginPath();
        locContext.moveTo(firstPoint.x * locScaleX, -firstPoint.y * locScaleY);
        for (var i = 1, len = vertices.length; i < len; i++) locContext.lineTo(vertices[i].x * locScaleX, -vertices[i].y * locScaleY);
        closePolygon && locContext.closePath();
        fill ? locContext.fill() : locContext.stroke();
      },
      drawSolidPoly: function(polygons, numberOfPoints, color) {
        this.setDrawColor(color.r, color.g, color.b, color.a);
        this.drawPoly(polygons, numberOfPoints, true, true);
      },
      drawCircle: function(center, radius, angle, segments, drawLineToCenter) {
        drawLineToCenter = drawLineToCenter || false;
        var locContext = this._renderContext.getContext();
        var locScaleX = cc.view.getScaleX(), locScaleY = cc.view.getScaleY();
        locContext.beginPath();
        var endAngle = angle - 2 * Math.PI;
        locContext.arc(0 | center.x * locScaleX, 0 | -center.y * locScaleY, radius * locScaleX, -angle, -endAngle, false);
        drawLineToCenter && locContext.lineTo(0 | center.x * locScaleX, 0 | -center.y * locScaleY);
        locContext.stroke();
      },
      drawQuadBezier: function(origin, control, destination, segments) {
        var vertices = this._cacheArray;
        vertices.length = 0;
        var t = 0;
        for (var i = 0; i < segments; i++) {
          var x = Math.pow(1 - t, 2) * origin.x + 2 * (1 - t) * t * control.x + t * t * destination.x;
          var y = Math.pow(1 - t, 2) * origin.y + 2 * (1 - t) * t * control.y + t * t * destination.y;
          vertices.push(cc.p(x, y));
          t += 1 / segments;
        }
        vertices.push(cc.p(destination.x, destination.y));
        this.drawPoly(vertices, segments + 1, false, false);
      },
      drawCubicBezier: function(origin, control1, control2, destination, segments) {
        var vertices = this._cacheArray;
        vertices.length = 0;
        var t = 0;
        for (var i = 0; i < segments; i++) {
          var x = Math.pow(1 - t, 3) * origin.x + 3 * Math.pow(1 - t, 2) * t * control1.x + 3 * (1 - t) * t * t * control2.x + t * t * t * destination.x;
          var y = Math.pow(1 - t, 3) * origin.y + 3 * Math.pow(1 - t, 2) * t * control1.y + 3 * (1 - t) * t * t * control2.y + t * t * t * destination.y;
          vertices.push(cc.p(x, y));
          t += 1 / segments;
        }
        vertices.push(cc.p(destination.x, destination.y));
        this.drawPoly(vertices, segments + 1, false, false);
      },
      drawCatmullRom: function(points, segments) {
        this.drawCardinalSpline(points, .5, segments);
      },
      drawCardinalSpline: function(config, tension, segments) {
        cc._renderContext.setStrokeStyle("rgba(255,255,255,1)");
        var points = this._cacheArray;
        points.length = 0;
        var p, lt;
        var deltaT = 1 / config.length;
        for (var i = 0; i < segments + 1; i++) {
          var dt = i / segments;
          if (1 === dt) {
            p = config.length - 1;
            lt = 1;
          } else {
            p = 0 | dt / deltaT;
            lt = (dt - deltaT * p) / deltaT;
          }
          var newPos = cc.cardinalSplineAt(cc.getControlPointAt(config, p - 1), cc.getControlPointAt(config, p - 0), cc.getControlPointAt(config, p + 1), cc.getControlPointAt(config, p + 2), tension, lt);
          points.push(newPos);
        }
        this.drawPoly(points, segments + 1, false, false);
      },
      drawImage: function(image, sourcePoint, sourceSize, destPoint, destSize) {
        var len = arguments.length;
        var ctx = this._renderContext.getContext();
        switch (len) {
         case 2:
          var height = image.height;
          ctx.drawImage(image, sourcePoint.x, -(sourcePoint.y + height));
          break;

         case 3:
          ctx.drawImage(image, sourcePoint.x, -(sourcePoint.y + sourceSize.height), sourceSize.width, sourceSize.height);
          break;

         case 5:
          ctx.drawImage(image, sourcePoint.x, sourcePoint.y, sourceSize.width, sourceSize.height, destPoint.x, -(destPoint.y + destSize.height), destSize.width, destSize.height);
          break;

         default:
          throw new Error("Argument must be non-nil");
        }
      },
      drawStar: function(ctx, radius, color) {
        var wrapper = ctx || this._renderContext;
        var context = wrapper.getContext();
        radius *= cc.view.getScaleX();
        var colorStr = "rgba(" + (0 | color.r) + "," + (0 | color.g) + "," + (0 | color.b);
        wrapper.setFillStyle(colorStr + ",1)");
        var subRadius = radius / 10;
        context.beginPath();
        context.moveTo(-radius, radius);
        context.lineTo(0, subRadius);
        context.lineTo(radius, radius);
        context.lineTo(subRadius, 0);
        context.lineTo(radius, -radius);
        context.lineTo(0, -subRadius);
        context.lineTo(-radius, -radius);
        context.lineTo(-subRadius, 0);
        context.lineTo(-radius, radius);
        context.closePath();
        context.fill();
        var rg = context.createRadialGradient(0, 0, subRadius, 0, 0, radius);
        rg.addColorStop(0, colorStr + ", 1)");
        rg.addColorStop(.3, colorStr + ", 0.8)");
        rg.addColorStop(1, colorStr + ", 0.0)");
        wrapper.setFillStyle(rg);
        context.beginPath();
        var startAngle_1 = 0;
        var endAngle_1 = cc.macro.PI2;
        context.arc(0, 0, radius - subRadius, startAngle_1, endAngle_1, false);
        context.closePath();
        context.fill();
      },
      drawColorBall: function(ctx, radius, color) {
        var wrapper = ctx || this._renderContext;
        var context = wrapper.getContext();
        radius *= cc.view.getScaleX();
        var colorStr = "rgba(" + (0 | color.r) + "," + (0 | color.g) + "," + (0 | color.b);
        var subRadius = radius / 10;
        var g1 = context.createRadialGradient(0, 0, subRadius, 0, 0, radius);
        g1.addColorStop(0, colorStr + ", 1)");
        g1.addColorStop(.3, colorStr + ", 0.8)");
        g1.addColorStop(.6, colorStr + ", 0.4)");
        g1.addColorStop(1, colorStr + ", 0.0)");
        wrapper.setFillStyle(g1);
        context.beginPath();
        var startAngle_1 = 0;
        var endAngle_1 = cc.macro.PI2;
        context.arc(0, 0, radius, startAngle_1, endAngle_1, false);
        context.closePath();
        context.fill();
      },
      fillText: function(strText, x, y) {
        this._renderContext.getContext().fillText(strText, x, -y);
      },
      setDrawColor: function(r, g, b, a) {
        this._renderContext.setFillStyle("rgba(" + r + "," + g + "," + b + "," + a / 255 + ")");
        this._renderContext.setStrokeStyle("rgba(" + r + "," + g + "," + b + "," + a / 255 + ")");
      },
      setPointSize: function(pointSize) {},
      setLineWidth: function(width) {
        this._renderContext.getContext().lineWidth = width * cc.view.getScaleX();
      }
    });
    module.exports = DrawingPrimitiveCanvas;
  }), {} ],
  38: [ (function(require, module, exports) {
    var macro = cc.macro;
    var DrawingPrimitiveWebGL = cc._Class.extend({
      _initialized: false,
      _shader: null,
      _colorLocation: "u_color",
      _pointSizeLocation: "u_pointSize",
      _pointSize: -1,
      ctor: function(ctx) {
        if (cc.sys.platform !== cc.sys.WECHAT_GAME && !ctx instanceof WebGLRenderingContext) throw new Error("Can't initialise DrawingPrimitiveWebGL. context need is WebGLRenderingContext");
        this._renderContext = ctx;
        this._colorArray = new Float32Array([ 1, 1, 1, 1 ]);
      },
      lazy_init: function() {
        var _t = this;
        if (!_t._initialized) {
          _t._shader = cc.shaderCache.programForKey(macro.SHADER_POSITION_UCOLOR);
          _t._shader._addUniformLocation(_t._colorLocation);
          _t._shader._addUniformLocation(_t._pointSizeLocation);
          _t._initialized = true;
        }
      },
      drawInit: function() {
        this._initialized = false;
      },
      drawPoint: function(point) {
        this.lazy_init();
        var glContext = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        glContext.enableVertexAttribArray(macro.VERTEX_ATTRIB_POSITION);
        this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
        this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
        var pointBuffer = glContext.createBuffer();
        glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
        glContext.bufferData(glContext.ARRAY_BUFFER, new Float32Array([ point.x, point.y ]), glContext.STATIC_DRAW);
        glContext.vertexAttribPointer(macro.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
        glContext.drawArrays(glContext.POINTS, 0, 1);
        glContext.deleteBuffer(pointBuffer);
        cc.incrementGLDraws(1);
      },
      drawPoints: function(points, numberOfPoints) {
        if (!points || 0 === points.length) return;
        this.lazy_init();
        var glContext = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        glContext.enableVertexAttribArray(macro.VERTEX_ATTRIB_POSITION);
        this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
        this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
        var pointBuffer = glContext.createBuffer();
        glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
        glContext.bufferData(glContext.ARRAY_BUFFER, this._pointsToTypeArray(points), glContext.STATIC_DRAW);
        glContext.vertexAttribPointer(macro.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
        glContext.drawArrays(glContext.POINTS, 0, points.length);
        glContext.deleteBuffer(pointBuffer);
        cc.incrementGLDraws(1);
      },
      _pointsToTypeArray: function(points) {
        var typeArr = new Float32Array(2 * points.length);
        for (var i = 0; i < points.length; i++) {
          typeArr[2 * i] = points[i].x;
          typeArr[2 * i + 1] = points[i].y;
        }
        return typeArr;
      },
      drawLine: function(origin, destination) {
        this.lazy_init();
        var glContext = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        glContext.enableVertexAttribArray(macro.VERTEX_ATTRIB_POSITION);
        this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
        var pointBuffer = glContext.createBuffer();
        glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
        glContext.bufferData(glContext.ARRAY_BUFFER, this._pointsToTypeArray([ origin, destination ]), glContext.STATIC_DRAW);
        glContext.vertexAttribPointer(macro.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
        glContext.drawArrays(glContext.LINES, 0, 2);
        glContext.deleteBuffer(pointBuffer);
        cc.incrementGLDraws(1);
      },
      drawRect: function(origin, destination) {
        this.drawLine(cc.p(origin.x, origin.y), cc.p(destination.x, origin.y));
        this.drawLine(cc.p(destination.x, origin.y), cc.p(destination.x, destination.y));
        this.drawLine(cc.p(destination.x, destination.y), cc.p(origin.x, destination.y));
        this.drawLine(cc.p(origin.x, destination.y), cc.p(origin.x, origin.y));
      },
      drawSolidRect: function(origin, destination, color) {
        var vertices = [ origin, cc.p(destination.x, origin.y), destination, cc.p(origin.x, destination.y) ];
        this.drawSolidPoly(vertices, 4, color);
      },
      drawPoly: function(vertices, numOfVertices, closePolygon) {
        this.lazy_init();
        var glContext = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        glContext.enableVertexAttribArray(macro.VERTEX_ATTRIB_POSITION);
        this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
        var pointBuffer = glContext.createBuffer();
        glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
        glContext.bufferData(glContext.ARRAY_BUFFER, this._pointsToTypeArray(vertices), glContext.STATIC_DRAW);
        glContext.vertexAttribPointer(macro.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
        closePolygon ? glContext.drawArrays(glContext.LINE_LOOP, 0, vertices.length) : glContext.drawArrays(glContext.LINE_STRIP, 0, vertices.length);
        glContext.deleteBuffer(pointBuffer);
        cc.incrementGLDraws(1);
      },
      drawSolidPoly: function(poli, numberOfPoints, color) {
        this.lazy_init();
        color && this.setDrawColor(color.r, color.g, color.b, color.a);
        var glContext = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        glContext.enableVertexAttribArray(macro.VERTEX_ATTRIB_POSITION);
        this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
        var pointBuffer = glContext.createBuffer();
        glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
        glContext.bufferData(glContext.ARRAY_BUFFER, this._pointsToTypeArray(poli), glContext.STATIC_DRAW);
        glContext.vertexAttribPointer(macro.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
        glContext.drawArrays(glContext.TRIANGLE_FAN, 0, poli.length);
        glContext.deleteBuffer(pointBuffer);
        cc.incrementGLDraws(1);
      },
      drawCircle: function(center, radius, angle, segments, drawLineToCenter) {
        this.lazy_init();
        var additionalSegment = 1;
        drawLineToCenter && additionalSegment++;
        var coef = 2 * Math.PI / segments;
        var vertices = new Float32Array(2 * (segments + 2));
        if (!vertices) return;
        for (var i = 0; i <= segments; i++) {
          var rads = i * coef;
          var j = radius * Math.cos(rads + angle) + center.x;
          var k = radius * Math.sin(rads + angle) + center.y;
          vertices[2 * i] = j;
          vertices[2 * i + 1] = k;
        }
        vertices[2 * (segments + 1)] = center.x;
        vertices[2 * (segments + 1) + 1] = center.y;
        var glContext = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        glContext.enableVertexAttribArray(macro.VERTEX_ATTRIB_POSITION);
        this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
        var pointBuffer = glContext.createBuffer();
        glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
        glContext.bufferData(glContext.ARRAY_BUFFER, vertices, glContext.STATIC_DRAW);
        glContext.vertexAttribPointer(macro.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
        glContext.drawArrays(glContext.LINE_STRIP, 0, segments + additionalSegment);
        glContext.deleteBuffer(pointBuffer);
        cc.incrementGLDraws(1);
      },
      drawQuadBezier: function(origin, control, destination, segments) {
        this.lazy_init();
        var vertices = new Float32Array(2 * (segments + 1));
        var t = 0;
        for (var i = 0; i < segments; i++) {
          vertices[2 * i] = Math.pow(1 - t, 2) * origin.x + 2 * (1 - t) * t * control.x + t * t * destination.x;
          vertices[2 * i + 1] = Math.pow(1 - t, 2) * origin.y + 2 * (1 - t) * t * control.y + t * t * destination.y;
          t += 1 / segments;
        }
        vertices[2 * segments] = destination.x;
        vertices[2 * segments + 1] = destination.y;
        var glContext = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        glContext.enableVertexAttribArray(macro.VERTEX_ATTRIB_POSITION);
        this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
        var pointBuffer = glContext.createBuffer();
        glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
        glContext.bufferData(glContext.ARRAY_BUFFER, vertices, glContext.STATIC_DRAW);
        glContext.vertexAttribPointer(macro.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
        glContext.drawArrays(glContext.LINE_STRIP, 0, segments + 1);
        glContext.deleteBuffer(pointBuffer);
        cc.incrementGLDraws(1);
      },
      drawCubicBezier: function(origin, control1, control2, destination, segments) {
        this.lazy_init();
        var vertices = new Float32Array(2 * (segments + 1));
        var t = 0;
        for (var i = 0; i < segments; i++) {
          vertices[2 * i] = Math.pow(1 - t, 3) * origin.x + 3 * Math.pow(1 - t, 2) * t * control1.x + 3 * (1 - t) * t * t * control2.x + t * t * t * destination.x;
          vertices[2 * i + 1] = Math.pow(1 - t, 3) * origin.y + 3 * Math.pow(1 - t, 2) * t * control1.y + 3 * (1 - t) * t * t * control2.y + t * t * t * destination.y;
          t += 1 / segments;
        }
        vertices[2 * segments] = destination.x;
        vertices[2 * segments + 1] = destination.y;
        var glContext = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        glContext.enableVertexAttribArray(macro.VERTEX_ATTRIB_POSITION);
        this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
        var pointBuffer = glContext.createBuffer();
        glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
        glContext.bufferData(glContext.ARRAY_BUFFER, vertices, glContext.STATIC_DRAW);
        glContext.vertexAttribPointer(macro.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
        glContext.drawArrays(glContext.LINE_STRIP, 0, segments + 1);
        glContext.deleteBuffer(pointBuffer);
        cc.incrementGLDraws(1);
      },
      drawCatmullRom: function(points, segments) {
        this.drawCardinalSpline(points, .5, segments);
      },
      drawCardinalSpline: function(config, tension, segments) {
        this.lazy_init();
        var vertices = new Float32Array(2 * (segments + 1));
        var p, lt, deltaT = 1 / config.length;
        for (var i = 0; i < segments + 1; i++) {
          var dt = i / segments;
          if (1 === dt) {
            p = config.length - 1;
            lt = 1;
          } else {
            p = 0 | dt / deltaT;
            lt = (dt - deltaT * p) / deltaT;
          }
          var newPos = cc.cardinalSplineAt(cc.getControlPointAt(config, p - 1), cc.getControlPointAt(config, p), cc.getControlPointAt(config, p + 1), cc.getControlPointAt(config, p + 2), tension, lt);
          vertices[2 * i] = newPos.x;
          vertices[2 * i + 1] = newPos.y;
        }
        var glContext = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        glContext.enableVertexAttribArray(macro.VERTEX_ATTRIB_POSITION);
        this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
        var pointBuffer = glContext.createBuffer();
        glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
        glContext.bufferData(glContext.ARRAY_BUFFER, vertices, glContext.STATIC_DRAW);
        glContext.vertexAttribPointer(macro.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
        glContext.drawArrays(glContext.LINE_STRIP, 0, segments + 1);
        glContext.deleteBuffer(pointBuffer);
        cc.incrementGLDraws(1);
      },
      setDrawColor: function(r, g, b, a) {
        this._colorArray[0] = r / 255;
        this._colorArray[1] = g / 255;
        this._colorArray[2] = b / 255;
        this._colorArray[3] = a / 255;
      },
      setPointSize: function(pointSize) {
        this._pointSize = pointSize;
      },
      setLineWidth: function(width) {
        this._renderContext.lineWidth && this._renderContext.lineWidth(width);
      }
    });
    module.exports = DrawingPrimitiveWebGL;
  }), {} ],
  39: [ (function(require, module, exports) {
    var EventTarget = require("./event/event-target");
    var View;
    true;
    View = require("./platform/CCView");
    require("../audio/CCAudioEngine");
    var inputManager = require("./platform/CCInputManager");
    var game = {
      EVENT_HIDE: "game_on_hide",
      EVENT_SHOW: "game_on_show",
      EVENT_GAME_INITED: "game_inited",
      EVENT_RENDERER_INITED: "renderer_inited",
      RENDER_TYPE_CANVAS: 0,
      RENDER_TYPE_WEBGL: 1,
      RENDER_TYPE_OPENGL: 2,
      _persistRootNodes: {},
      _ignoreRemovePersistNode: null,
      CONFIG_KEY: {
        width: "width",
        height: "height",
        debugMode: "debugMode",
        exposeClassName: "exposeClassName",
        showFPS: "showFPS",
        frameRate: "frameRate",
        id: "id",
        renderMode: "renderMode",
        registerSystemEvent: "registerSystemEvent",
        jsList: "jsList",
        scenes: "scenes"
      },
      _paused: true,
      _configLoaded: false,
      _isCloning: false,
      _prepareCalled: false,
      _prepared: false,
      _rendererInitialized: false,
      _renderContext: null,
      _intervalId: null,
      _lastTime: null,
      _frameTime: null,
      _sceneInfos: [],
      frame: null,
      container: null,
      canvas: null,
      config: null,
      onStart: null,
      setFrameRate: function(frameRate) {
        var self = this, config = self.config, CONFIG_KEY = self.CONFIG_KEY;
        config[CONFIG_KEY.frameRate] = frameRate;
        self._intervalId && window.cancelAnimFrame(self._intervalId);
        self._intervalId = 0;
        self._paused = true;
        self._setAnimFrame();
        self._runMainLoop();
      },
      step: function() {
        cc.director.mainLoop();
      },
      pause: function() {
        if (this._paused) return;
        this._paused = true;
        cc.audioEngine && cc.audioEngine._break();
        this._intervalId && window.cancelAnimFrame(this._intervalId);
        this._intervalId = 0;
      },
      resume: function() {
        if (!this._paused) return;
        this._paused = false;
        cc.audioEngine && cc.audioEngine._restore();
        this._runMainLoop();
      },
      isPaused: function() {
        return this._paused;
      },
      restart: function() {
        cc.director.once(cc.Director.EVENT_AFTER_DRAW, (function() {
          for (var id in game._persistRootNodes) game.removePersistRootNode(game._persistRootNodes[id]);
          cc.director.getScene().destroy();
          cc.Object._deferredDestroy();
          cc.director.purgeDirector();
          cc.audioEngine && cc.audioEngine.uncacheAll();
          cc.director.reset();
          game.onStart();
        }));
      },
      end: function() {
        close();
      },
      prepare: function(cb) {
        var self = this, config = self.config, CONFIG_KEY = self.CONFIG_KEY;
        if (!this._configLoaded) {
          this._loadConfig((function() {
            self.prepare(cb);
          }));
          return;
        }
        if (this._prepared) {
          cb && cb();
          return;
        }
        if (this._prepareCalled) return;
        if (cc._engineLoaded) {
          this._prepareCalled = true;
          this._initRenderer(config[CONFIG_KEY.width], config[CONFIG_KEY.height]);
          cc.view = View ? View._getInstance() : null;
          cc.director = cc.Director._getInstance();
          cc.director.setOpenGLView && cc.director.setOpenGLView(cc.view);
          cc.winSize = cc.director.getWinSize();
          true;
          this._initEvents();
          this._setAnimFrame();
          this._runMainLoop();
          var jsList = config[CONFIG_KEY.jsList];
          if (jsList && jsList.length > 0) cc.loader.load(jsList, (function(err) {
            if (err) throw new Error(JSON.stringify(err));
            self._prepared = true;
            cb && cb();
            self.emit(self.EVENT_GAME_INITED);
          })); else {
            cb && cb();
            self.emit(self.EVENT_GAME_INITED);
          }
          return;
        }
        cc.initEngine(this.config, (function() {
          self.prepare(cb);
        }));
      },
      run: function(config, onStart) {
        if ("function" === typeof config) game.onStart = config; else {
          config && (game.config = config);
          "function" === typeof onStart && (game.onStart = onStart);
        }
        this.prepare(game.onStart && game.onStart.bind(game));
      },
      addPersistRootNode: function(node) {
        if (!cc.Node.isNode(node) || !node.uuid) {
          cc.warnID(3800);
          return;
        }
        var id = node.uuid;
        if (!this._persistRootNodes[id]) {
          var scene = cc.director._scene;
          if (cc.isValid(scene)) {
            if (node.parent) {
              if (!(node.parent instanceof cc.Scene)) {
                cc.warnID(3801);
                return;
              }
              if (node.parent !== scene) {
                cc.warnID(3802);
                return;
              }
            } else node.parent = scene;
            this._persistRootNodes[id] = node;
            node._persistNode = true;
          }
        }
      },
      removePersistRootNode: function(node) {
        if (node !== this._ignoreRemovePersistNode) {
          var id = node.uuid || "";
          if (node === this._persistRootNodes[id]) {
            delete this._persistRootNodes[id];
            node._persistNode = false;
          }
        }
      },
      isPersistRootNode: function(node) {
        return node._persistNode;
      },
      _setAnimFrame: function() {
        this._lastTime = new Date();
        var frameRate = game.config[game.CONFIG_KEY.frameRate];
        this._frameTime = 1e3 / frameRate;
        if (60 !== frameRate && 30 !== frameRate) {
          window.requestAnimFrame = this._stTime;
          window.cancelAnimFrame = this._ctTime;
        } else {
          window.requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || this._stTime;
          window.cancelAnimFrame = window.cancelAnimationFrame || window.cancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.oCancelAnimationFrame || this._ctTime;
        }
      },
      _stTime: function(callback) {
        var currTime = new Date().getTime();
        var timeToCall = Math.max(0, game._frameTime - (currTime - game._lastTime));
        var id = window.setTimeout((function() {
          callback();
        }), timeToCall);
        game._lastTime = currTime + timeToCall;
        return id;
      },
      _ctTime: function(id) {
        window.clearTimeout(id);
      },
      _runMainLoop: function() {
        var self = this, callback, config = self.config, CONFIG_KEY = self.CONFIG_KEY, director = cc.director, skip = true, frameRate = config[CONFIG_KEY.frameRate];
        director.setDisplayStats(config[CONFIG_KEY.showFPS]);
        callback = function() {
          if (!self._paused) {
            self._intervalId = window.requestAnimFrame(callback);
            if (30 === frameRate && (skip = !skip)) return;
            director.mainLoop();
          }
        };
        self._intervalId = window.requestAnimFrame(callback);
        self._paused = false;
      },
      _loadConfig: function(cb) {
        if (this.config) {
          this._initConfig(this.config);
          cb && cb();
          return;
        }
        if (document["ccConfig"]) {
          this._initConfig(document["ccConfig"]);
          cb && cb();
          return;
        }
        var self = this;
        cc.loader.load("project.json", (function(err, data) {
          err && cc.logID(3818);
          self._initConfig(data || {});
          cb && cb();
        }));
      },
      _initConfig: function(config) {
        var CONFIG_KEY = this.CONFIG_KEY;
        "number" !== typeof config[CONFIG_KEY.debugMode] && (config[CONFIG_KEY.debugMode] = 0);
        config[CONFIG_KEY.exposeClassName] = !!config[CONFIG_KEY.exposeClassName];
        "number" !== typeof config[CONFIG_KEY.frameRate] && (config[CONFIG_KEY.frameRate] = 60);
        "number" !== typeof config[CONFIG_KEY.renderMode] && (config[CONFIG_KEY.renderMode] = 0);
        "boolean" !== typeof config[CONFIG_KEY.registerSystemEvent] && (config[CONFIG_KEY.registerSystemEvent] = true);
        config[CONFIG_KEY.showFPS] = !(CONFIG_KEY.showFPS in config) || !!config[CONFIG_KEY.showFPS];
        this._sceneInfos = config[CONFIG_KEY.scenes] || [];
        this.collisionMatrix = config.collisionMatrix || [];
        this.groupList = config.groupList || [];
        cc._initDebugSetting(config[CONFIG_KEY.debugMode]);
        this.config = config;
        this._configLoaded = true;
      },
      _initRenderer: function(width, height) {
        if (this._rendererInitialized) return;
        if (!cc._supportRender) throw new Error("The renderer doesn't support the renderMode " + this.config[this.CONFIG_KEY.renderMode]);
        var el = this.config[game.CONFIG_KEY.id], win = window, localCanvas, localContainer, isWeChatGame = cc.sys.platform === cc.sys.WECHAT_GAME;
        if (isWeChatGame) {
          this.container = cc.container = localContainer = document.createElement("DIV");
          this.frame = localContainer.parentNode === document.body ? document.documentElement : localContainer.parentNode;
          this.canvas = cc._canvas = localCanvas = canvas;
        } else {
          var element = el instanceof HTMLElement ? el : document.querySelector(el) || document.querySelector("#" + el);
          if ("CANVAS" === element.tagName) {
            width = width || element.width;
            height = height || element.height;
            this.canvas = cc._canvas = localCanvas = element;
            this.container = cc.container = localContainer = document.createElement("DIV");
            localCanvas.parentNode && localCanvas.parentNode.insertBefore(localContainer, localCanvas);
          } else {
            "DIV" !== element.tagName && cc.warnID(3819);
            width = width || element.clientWidth;
            height = height || element.clientHeight;
            this.canvas = cc._canvas = localCanvas = document.createElement("CANVAS");
            this.container = cc.container = localContainer = document.createElement("DIV");
            element.appendChild(localContainer);
          }
          localContainer.setAttribute("id", "Cocos2dGameContainer");
          localContainer.appendChild(localCanvas);
          this.frame = localContainer.parentNode === document.body ? document.documentElement : localContainer.parentNode;
          function addClass(element, name) {
            var hasClass = (" " + element.className + " ").indexOf(" " + name + " ") > -1;
            if (!hasClass) {
              element.className && (element.className += " ");
              element.className += name;
            }
          }
          addClass(localCanvas, "gameCanvas");
          localCanvas.setAttribute("width", width || 480);
          localCanvas.setAttribute("height", height || 320);
          localCanvas.setAttribute("tabindex", 99);
        }
        if (cc._renderType === game.RENDER_TYPE_WEBGL) {
          var opts = {
            stencil: true,
            alpha: cc.macro.ENABLE_TRANSPARENT_CANVAS
          };
          isWeChatGame && (opts["preserveDrawingBuffer"] = true);
          this._renderContext = cc._renderContext = cc.webglContext = cc.create3DContext(localCanvas, opts);
        }
        if (this._renderContext) {
          cc.renderer = cc.rendererWebGL;
          win.gl = this._renderContext;
          cc.renderer.init();
        } else {
          cc._renderType = game.RENDER_TYPE_CANVAS;
          cc.renderer = cc.rendererCanvas;
          cc.renderer.init();
          this._renderContext = cc._renderContext = new cc.CanvasContextWrapper(localCanvas.getContext("2d"));
        }
        cc._gameDiv = localContainer;
        game.canvas.oncontextmenu = function() {
          if (!cc._isContextMenuEnable) return false;
        };
        this.emit(this.EVENT_RENDERER_INITED, true);
        this._rendererInitialized = true;
      },
      _initEvents: function() {
        var win = window, hidden, visibilityChange, _undef = "undefined";
        this.config[this.CONFIG_KEY.registerSystemEvent] && inputManager.registerSystemEvent(this.canvas);
        "undefined" !== typeof document.hidden ? hidden = "hidden" : "undefined" !== typeof document.mozHidden ? hidden = "mozHidden" : "undefined" !== typeof document.msHidden ? hidden = "msHidden" : "undefined" !== typeof document.webkitHidden && (hidden = "webkitHidden");
        var changeList = [ "visibilitychange", "mozvisibilitychange", "msvisibilitychange", "webkitvisibilitychange", "qbrowserVisibilityChange" ];
        var onHidden = function() {
          game.emit(game.EVENT_HIDE, game);
        };
        var onShow = function() {
          game.emit(game.EVENT_SHOW, game);
        };
        if (hidden) for (var i = 0; i < changeList.length; i++) document.addEventListener(changeList[i], (function(event) {
          var visible = document[hidden];
          visible = visible || event["hidden"];
          visible ? onHidden() : onShow();
        }), false); else {
          win.addEventListener("blur", onHidden, false);
          win.addEventListener("focus", onShow, false);
        }
        navigator.userAgent.indexOf("MicroMessenger") > -1 && (win.onfocus = function() {
          onShow();
        });
        false;
        if ("onpageshow" in window && "onpagehide" in window) {
          win.addEventListener("pagehide", onHidden, false);
          win.addEventListener("pageshow", onShow, false);
        }
        this.on(game.EVENT_HIDE, (function() {
          game.pause();
        }));
        this.on(game.EVENT_SHOW, (function() {
          game.resume();
        }));
      }
    };
    EventTarget.call(game);
    cc.js.addon(game, EventTarget.prototype);
    cc.game = module.exports = game;
  }), {
    "../audio/CCAudioEngine": 23,
    "./event/event-target": 113,
    "./platform/CCInputManager": 179,
    "./platform/CCView": 185
  } ],
  40: [ (function(require, module, exports) {
    "use strict";
    var PrefabHelper = require("./utils/prefab-helper");
    var SgHelper = require("./utils/scene-graph-helper");
    var Flags = cc.Object.Flags;
    var Destroying = Flags.Destroying;
    var POSITION_CHANGED = "position-changed";
    var SIZE_CHANGED = "size-changed";
    var ANCHOR_CHANGED = "anchor-changed";
    var ROTATION_CHANGED = "rotation-changed";
    var SCALE_CHANGED = "scale-changed";
    var CHILD_REORDER = "child-reorder";
    var ERR_INVALID_NUMBER = false;
    var Misc = require("./utils/misc");
    var Event = require("./event/event");
    var ActionManagerExist = !!cc.ActionManager;
    var emptyFunc = function() {};
    var EventType = cc.Enum({
      TOUCH_START: "touchstart",
      TOUCH_MOVE: "touchmove",
      TOUCH_END: "touchend",
      TOUCH_CANCEL: "touchcancel",
      MOUSE_DOWN: "mousedown",
      MOUSE_MOVE: "mousemove",
      MOUSE_ENTER: "mouseenter",
      MOUSE_LEAVE: "mouseleave",
      MOUSE_UP: "mouseup",
      MOUSE_WHEEL: "mousewheel"
    });
    var _touchEvents = [ EventType.TOUCH_START, EventType.TOUCH_MOVE, EventType.TOUCH_END, EventType.TOUCH_CANCEL ];
    var _mouseEvents = [ EventType.MOUSE_DOWN, EventType.MOUSE_ENTER, EventType.MOUSE_MOVE, EventType.MOUSE_LEAVE, EventType.MOUSE_UP, EventType.MOUSE_WHEEL ];
    var _currentHovered = null;
    var _touchStartHandler = function(touch, event) {
      var pos = touch.getLocation();
      var node = this.owner;
      if (node._hitTest(pos, this)) {
        false;
        event.type = EventType.TOUCH_START;
        event.touch = touch;
        event.bubbles = true;
        node.dispatchEvent(event);
        false;
        return true;
      }
      return false;
    };
    var _touchMoveHandler = function(touch, event) {
      false;
      var node = this.owner;
      event.type = EventType.TOUCH_MOVE;
      event.touch = touch;
      event.bubbles = true;
      node.dispatchEvent(event);
      false;
    };
    var _touchEndHandler = function(touch, event) {
      false;
      var pos = touch.getLocation();
      var node = this.owner;
      node._hitTest(pos, this) ? event.type = EventType.TOUCH_END : event.type = EventType.TOUCH_CANCEL;
      event.touch = touch;
      event.bubbles = true;
      node.dispatchEvent(event);
      false;
    };
    var _mouseDownHandler = function(event) {
      var pos = event.getLocation();
      var node = this.owner;
      if (node._hitTest(pos, this)) {
        false;
        event.type = EventType.MOUSE_DOWN;
        event.bubbles = true;
        node.dispatchEvent(event);
        false;
        event.stopPropagation();
      }
    };
    var _mouseMoveHandler = function(event) {
      var pos = event.getLocation();
      var node = this.owner;
      var hit = node._hitTest(pos, this);
      false;
      if (hit) {
        if (!this._previousIn) {
          if (_currentHovered) {
            event.type = EventType.MOUSE_LEAVE;
            _currentHovered.dispatchEvent(event);
            _currentHovered._mouseListener._previousIn = false;
          }
          _currentHovered = this.owner;
          event.type = EventType.MOUSE_ENTER;
          node.dispatchEvent(event);
          this._previousIn = true;
        }
        event.type = EventType.MOUSE_MOVE;
        event.bubbles = true;
        node.dispatchEvent(event);
      } else {
        if (!this._previousIn) return;
        event.type = EventType.MOUSE_LEAVE;
        node.dispatchEvent(event);
        this._previousIn = false;
        _currentHovered = null;
      }
      false;
      event.stopPropagation();
    };
    var _mouseUpHandler = function(event) {
      var pos = event.getLocation();
      var node = this.owner;
      if (node._hitTest(pos, this)) {
        false;
        event.type = EventType.MOUSE_UP;
        event.bubbles = true;
        node.dispatchEvent(event);
        false;
        event.stopPropagation();
      }
    };
    var _mouseWheelHandler = function(event) {
      var pos = event.getLocation();
      var node = this.owner;
      if (node._hitTest(pos, this)) {
        false;
        event.type = EventType.MOUSE_WHEEL;
        event.bubbles = true;
        node.dispatchEvent(event);
        false;
        event.stopPropagation();
      }
    };
    function _searchMaskInParent(node) {
      var Mask = cc.Mask;
      if (Mask) {
        var index = 0;
        for (var curr = node; curr && cc.Node.isNode(curr); curr = curr._parent, ++index) if (curr.getComponent(Mask)) return {
          index: index,
          node: curr
        };
      }
      return null;
    }
    function updateOrder(node) {
      node._parent._delaySort();
      true;
      cc.eventManager._setDirtyForNode(node);
    }
    var Node = cc.Class({
      name: "cc.Node",
      extends: require("./utils/base-node"),
      properties: {
        _opacity: 255,
        _color: cc.Color.WHITE,
        _cascadeOpacityEnabled: true,
        _anchorPoint: cc.p(.5, .5),
        _contentSize: cc.size(0, 0),
        _rotationX: 0,
        _rotationY: 0,
        _scaleX: 1,
        _scaleY: 1,
        _position: cc.p(0, 0),
        _skewX: 0,
        _skewY: 0,
        _localZOrder: 0,
        _globalZOrder: 0,
        _opacityModifyRGB: false,
        groupIndex: {
          default: 0,
          type: cc.Integer
        },
        group: {
          get: function() {
            return cc.game.groupList[this.groupIndex] || "";
          },
          set: function(value) {
            this.groupIndex = cc.game.groupList.indexOf(value);
            this.emit("group-changed");
          }
        },
        x: {
          get: function() {
            return this._position.x;
          },
          set: function(value) {
            var localPosition = this._position;
            if (value !== localPosition.x) {
              true;
              var oldValue;
              false;
              localPosition.x = value;
              this._sgNode.setPositionX(value);
              var cache = this._hasListenerCache;
              if (cache && cache[POSITION_CHANGED]) {
                false;
                this.emit(POSITION_CHANGED);
              }
            }
          }
        },
        y: {
          get: function() {
            return this._position.y;
          },
          set: function(value) {
            var localPosition = this._position;
            if (value !== localPosition.y) {
              true;
              var oldValue;
              false;
              localPosition.y = value;
              this._sgNode.setPositionY(value);
              var cache = this._hasListenerCache;
              if (cache && cache[POSITION_CHANGED]) {
                false;
                this.emit(POSITION_CHANGED);
              }
            }
          }
        },
        rotation: {
          get: function() {
            this._rotationX !== this._rotationY && cc.logID(1602);
            return this._rotationX;
          },
          set: function(value) {
            if (this._rotationX !== value || this._rotationY !== value) {
              this._rotationX = this._rotationY = value;
              this._sgNode.rotation = value;
              var cache = this._hasListenerCache;
              cache && cache[ROTATION_CHANGED] && this.emit(ROTATION_CHANGED);
            }
          }
        },
        rotationX: {
          get: function() {
            return this._rotationX;
          },
          set: function(value) {
            if (this._rotationX !== value) {
              this._rotationX = value;
              this._sgNode.rotationX = value;
              var cache = this._hasListenerCache;
              cache && cache[ROTATION_CHANGED] && this.emit(ROTATION_CHANGED);
            }
          }
        },
        rotationY: {
          get: function() {
            return this._rotationY;
          },
          set: function(value) {
            if (this._rotationY !== value) {
              this._rotationY = value;
              this._sgNode.rotationY = value;
              var cache = this._hasListenerCache;
              cache && cache[ROTATION_CHANGED] && this.emit(ROTATION_CHANGED);
            }
          }
        },
        scaleX: {
          get: function() {
            return this._scaleX;
          },
          set: function(value) {
            if (this._scaleX !== value) {
              this._scaleX = value;
              this._sgNode.scaleX = value;
              var cache = this._hasListenerCache;
              cache && cache[SCALE_CHANGED] && this.emit(SCALE_CHANGED);
            }
          }
        },
        scaleY: {
          get: function() {
            return this._scaleY;
          },
          set: function(value) {
            if (this._scaleY !== value) {
              this._scaleY = value;
              this._sgNode.scaleY = value;
              var cache = this._hasListenerCache;
              cache && cache[SCALE_CHANGED] && this.emit(SCALE_CHANGED);
            }
          }
        },
        skewX: {
          get: function() {
            return this._skewX;
          },
          set: function(value) {
            this._skewX = value;
            this._sgNode.skewX = value;
          }
        },
        skewY: {
          get: function() {
            return this._skewY;
          },
          set: function(value) {
            this._skewY = value;
            this._sgNode.skewY = value;
          }
        },
        opacity: {
          get: function() {
            return this._opacity;
          },
          set: function(value) {
            if (this._opacity !== value) {
              this._opacity = value;
              this._sgNode.setOpacity(value);
              if (!this._cascadeOpacityEnabled) {
                var sizeProvider = this._sizeProvider;
                sizeProvider instanceof _ccsg.Node && sizeProvider !== this._sgNode && sizeProvider.setOpacity(value);
              }
            }
          },
          range: [ 0, 255 ]
        },
        cascadeOpacity: {
          get: function() {
            return this._cascadeOpacityEnabled;
          },
          set: function(value) {
            if (this._cascadeOpacityEnabled !== value) {
              this._cascadeOpacityEnabled = value;
              this._sgNode.cascadeOpacity = value;
              var opacity = value ? 255 : this._opacity;
              var sizeProvider = this._sizeProvider;
              sizeProvider instanceof _ccsg.Node && sizeProvider.setOpacity(opacity);
            }
          }
        },
        color: {
          get: function() {
            return this._color.clone();
          },
          set: function(value) {
            if (!this._color.equals(value)) {
              this._color.fromColor(value);
              (true, 255 !== value.a) && cc.warnID(1626);
              this._sizeProvider instanceof _ccsg.Node && this._sizeProvider.setColor(value);
            }
          }
        },
        anchorX: {
          get: function() {
            return this._anchorPoint.x;
          },
          set: function(value) {
            var anchorPoint = this._anchorPoint;
            if (anchorPoint.x !== value) {
              anchorPoint.x = value;
              var sizeProvider = this._sizeProvider;
              sizeProvider instanceof _ccsg.Node && sizeProvider.setAnchorPoint(anchorPoint);
              this.emit(ANCHOR_CHANGED);
            }
          }
        },
        anchorY: {
          get: function() {
            return this._anchorPoint.y;
          },
          set: function(value) {
            var anchorPoint = this._anchorPoint;
            if (anchorPoint.y !== value) {
              anchorPoint.y = value;
              var sizeProvider = this._sizeProvider;
              sizeProvider instanceof _ccsg.Node && sizeProvider.setAnchorPoint(anchorPoint);
              this.emit(ANCHOR_CHANGED);
            }
          }
        },
        width: {
          get: function() {
            if (this._sizeProvider) {
              var w = this._sizeProvider._getWidth();
              this._contentSize.width = w;
              return w;
            }
            return this._contentSize.width;
          },
          set: function(value) {
            if (value !== this._contentSize.width) {
              var sizeProvider = this._sizeProvider;
              sizeProvider && sizeProvider.setContentSize(value, sizeProvider._getHeight());
              var clone;
              false;
              this._contentSize.width = value;
              false;
              this.emit(SIZE_CHANGED);
            }
          }
        },
        height: {
          get: function() {
            if (this._sizeProvider) {
              var h = this._sizeProvider._getHeight();
              this._contentSize.height = h;
              return h;
            }
            return this._contentSize.height;
          },
          set: function(value) {
            if (value !== this._contentSize.height) {
              var sizeProvider = this._sizeProvider;
              sizeProvider && sizeProvider.setContentSize(sizeProvider._getWidth(), value);
              var clone;
              false;
              this._contentSize.height = value;
              false;
              this.emit(SIZE_CHANGED);
            }
          }
        },
        zIndex: {
          get: function() {
            return this._localZOrder;
          },
          set: function(value) {
            if (this._localZOrder !== value) {
              this._localZOrder = value;
              this._sgNode.zIndex = value;
              this._parent && updateOrder(this);
            }
          }
        }
      },
      ctor: function(name) {
        var sgNode = this._sgNode = new _ccsg.Node();
        false;
        cc.game._isCloning || (sgNode.cascadeOpacity = true);
        this._sizeProvider = null;
        this._reorderChildDirty = false;
        this._widget = null;
        this._touchListener = null;
        this._mouseListener = null;
        false;
      },
      statics: {
        isNode: function(obj) {
          return obj instanceof Node && (obj.constructor === Node || !(obj instanceof cc.Scene));
        }
      },
      _onSetParent: function(value) {
        var sgNode = this._sgNode;
        sgNode.parent && sgNode.parent.removeChild(sgNode, false);
        if (value) {
          value._sgNode.addChild(sgNode);
          value._delaySort();
        }
      },
      _onSiblingIndexChanged: function(index) {
        var parent = this._parent;
        var siblings = parent._children;
        var i = 0, len = siblings.length, sibling;
        var zOrder;
        var nextSibling;
        var oldZOrder;
        false;
        for (;i < len; i++) {
          sibling = siblings[i]._sgNode;
          sibling._arrivalOrder = i;
          cc.eventManager._setDirtyForNode(sibling);
        }
        cc.renderer.childrenOrderDirty = true;
        parent._sgNode._reorderChildDirty = true;
        parent._delaySort();
      },
      _onPreDestroy: function() {
        var destroyByParent = this._onPreDestroyBase();
        ActionManagerExist && cc.director.getActionManager().removeAllActionsFromTarget(this);
        _currentHovered === this && (_currentHovered = null);
        false;
        this._reorderChildDirty && cc.director.__fastOff(cc.Director.EVENT_AFTER_UPDATE, this.sortAllChildren, this);
        cc.eventManager.removeListeners(this);
        if (destroyByParent) false; else {
          this._removeSgNode();
          false;
        }
      },
      _onPostActivated: function(active) {
        var actionManager = ActionManagerExist ? cc.director.getActionManager() : null;
        if (active) {
          actionManager && actionManager.resumeTarget(this);
          cc.eventManager.resumeTarget(this);
          if (this._touchListener) {
            var mask = this._touchListener.mask = _searchMaskInParent(this);
            this._mouseListener && (this._mouseListener.mask = mask);
          } else this._mouseListener && (this._mouseListener.mask = _searchMaskInParent(this));
        } else {
          actionManager && actionManager.pauseTarget(this);
          cc.eventManager.pauseTarget(this);
        }
      },
      _onHierarchyChanged: function(oldParent) {
        this._onHierarchyChangedBase(oldParent);
        cc._widgetManager._nodesOrderDirty = true;
      },
      _onBatchCreated: function() {
        var prefabInfo = this._prefab;
        prefabInfo && prefabInfo.sync && !prefabInfo._synced && prefabInfo.root === this && PrefabHelper.syncWithPrefab(this);
        this._updateDummySgNode();
        this._parent && this._parent._sgNode.addChild(this._sgNode);
        if (!this._activeInHierarchy) {
          ActionManagerExist && cc.director.getActionManager().pauseTarget(this);
          cc.eventManager.pauseTarget(this);
        }
        var children = this._children;
        for (var i = 0, len = children.length; i < len; i++) children[i]._onBatchCreated();
      },
      on: function(type, callback, target, useCapture) {
        var newAdded = false;
        if (-1 !== _touchEvents.indexOf(type)) {
          if (!this._touchListener) {
            this._touchListener = cc.EventListener.create({
              event: cc.EventListener.TOUCH_ONE_BY_ONE,
              swallowTouches: true,
              owner: this,
              mask: _searchMaskInParent(this),
              onTouchBegan: _touchStartHandler,
              onTouchMoved: _touchMoveHandler,
              onTouchEnded: _touchEndHandler
            });
            false;
            cc.eventManager.addListener(this._touchListener, this);
            newAdded = true;
          }
        } else if (-1 !== _mouseEvents.indexOf(type) && !this._mouseListener) {
          this._mouseListener = cc.EventListener.create({
            event: cc.EventListener.MOUSE,
            _previousIn: false,
            owner: this,
            mask: _searchMaskInParent(this),
            onMouseDown: _mouseDownHandler,
            onMouseMove: _mouseMoveHandler,
            onMouseUp: _mouseUpHandler,
            onMouseScroll: _mouseWheelHandler
          });
          false;
          cc.eventManager.addListener(this._mouseListener, this);
          newAdded = true;
        }
        newAdded && !this._activeInHierarchy && cc.director.getScheduler().schedule((function() {
          this._activeInHierarchy || cc.eventManager.pauseTarget(this);
        }), this, 0, 0, 0, false);
        return this._EventTargetOn(type, callback, target, useCapture);
      },
      off: function(type, callback, target, useCapture) {
        this._EventTargetOff(type, callback, target, useCapture);
        -1 !== _touchEvents.indexOf(type) ? this._checkTouchListeners() : -1 !== _mouseEvents.indexOf(type) && this._checkMouseListeners();
      },
      targetOff: function(target) {
        this._EventTargetTargetOff(target);
        this._checkTouchListeners();
        this._checkMouseListeners();
      },
      pauseSystemEvents: function(recursive) {
        cc.eventManager.pauseTarget(this, recursive);
      },
      resumeSystemEvents: function(recursive) {
        cc.eventManager.resumeTarget(this, recursive);
      },
      _checkTouchListeners: function() {
        if (!(this._objFlags & Destroying) && this._touchListener) {
          var i = 0;
          if (this._bubblingListeners) for (;i < _touchEvents.length; ++i) if (this._bubblingListeners.has(_touchEvents[i])) return;
          if (this._capturingListeners) for (;i < _touchEvents.length; ++i) if (this._capturingListeners.has(_touchEvents[i])) return;
          cc.eventManager.removeListener(this._touchListener);
          this._touchListener = null;
        }
      },
      _checkMouseListeners: function() {
        if (!(this._objFlags & Destroying) && this._mouseListener) {
          var i = 0;
          if (this._bubblingListeners) for (;i < _mouseEvents.length; ++i) if (this._bubblingListeners.has(_mouseEvents[i])) return;
          if (this._capturingListeners) for (;i < _mouseEvents.length; ++i) if (this._capturingListeners.has(_mouseEvents[i])) return;
          _currentHovered === this && (_currentHovered = null);
          cc.eventManager.removeListener(this._mouseListener);
          this._mouseListener = null;
        }
      },
      _hitTest: function(point, listener) {
        var w = this.width, h = this.height;
        var rect = cc.rect(0, 0, w, h);
        var Camera = cc.Camera;
        Camera && Camera.main && Camera.main.containsNode(this) && (point = Camera.main.getCameraToWorldPoint(point));
        var trans = this.getNodeToWorldTransform();
        cc._rectApplyAffineTransformIn(rect, trans);
        var left = point.x - rect.x, right = rect.x + rect.width - point.x, bottom = point.y - rect.y, top = rect.y + rect.height - point.y;
        if (left >= 0 && right >= 0 && top >= 0 && bottom >= 0) {
          if (listener && listener.mask) {
            var mask = listener.mask;
            var parent = this;
            for (var i = 0; parent && i < mask.index; ++i, parent = parent.parent) ;
            if (parent === mask.node) {
              var comp = parent.getComponent(cc.Mask);
              return !comp || !comp.enabledInHierarchy || comp._hitTest(point);
            }
            listener.mask = null;
            return true;
          }
          return true;
        }
        return false;
      },
      _getCapturingTargets: function(type, array) {
        var parent = this.parent;
        while (parent) {
          parent.hasEventListener(type, true) && array.push(parent);
          parent = parent.parent;
        }
      },
      _getBubblingTargets: function(type, array) {
        var parent = this.parent;
        while (parent) {
          parent.hasEventListener(type) && array.push(parent);
          parent = parent.parent;
        }
      },
      isRunning: function() {
        return this._activeInHierarchy;
      },
      runAction: ActionManagerExist ? function(action) {
        if (!this.active) return;
        cc.assertID(action, 1618);
        cc.macro.ENABLE_GC_FOR_NATIVE_OBJECTS || this._retainAction(action);
        false;
        cc.director.getActionManager().addAction(action, this, false);
        return action;
      } : emptyFunc,
      pauseAllActions: ActionManagerExist ? function() {
        cc.director.getActionManager().pauseTarget(this);
      } : emptyFunc,
      resumeAllActions: ActionManagerExist ? function() {
        cc.director.getActionManager().resumeTarget(this);
      } : emptyFunc,
      stopAllActions: ActionManagerExist ? function() {
        cc.director.getActionManager().removeAllActionsFromTarget(this);
      } : emptyFunc,
      stopAction: ActionManagerExist ? function(action) {
        cc.director.getActionManager().removeAction(action);
      } : emptyFunc,
      stopActionByTag: ActionManagerExist ? function(tag) {
        if (tag === cc.Action.TAG_INVALID) {
          cc.logID(1612);
          return;
        }
        cc.director.getActionManager().removeActionByTag(tag, this);
      } : emptyFunc,
      getActionByTag: ActionManagerExist ? function(tag) {
        if (tag === cc.Action.TAG_INVALID) {
          cc.logID(1613);
          return null;
        }
        return cc.director.getActionManager().getActionByTag(tag, this);
      } : function() {
        return null;
      },
      getNumberOfRunningActions: ActionManagerExist ? function() {
        return cc.director.getActionManager().getNumberOfRunningActionsInTarget(this);
      } : function() {
        return 0;
      },
      _retainAction: function(action) {
        false;
      },
      _releaseAllActions: function() {
        var i;
        false;
      },
      setTag: function(value) {
        this._tag = value;
        this._sgNode.tag = value;
      },
      getPosition: function() {
        return new cc.Vec2(this._position);
      },
      setPosition: function(newPosOrX, y) {
        var x;
        if ("undefined" === typeof y) {
          x = newPosOrX.x;
          y = newPosOrX.y;
        } else x = newPosOrX;
        var locPosition = this._position;
        if (locPosition.x === x && locPosition.y === y) return;
        var oldPosition;
        false;
        true;
        locPosition.x = x;
        true;
        locPosition.y = y;
        this._sgNode.setPosition(x, y);
        var cache = this._hasListenerCache;
        if (cache && cache[POSITION_CHANGED]) {
          false;
          this.emit(POSITION_CHANGED);
        }
      },
      getScale: function() {
        this._scaleX !== this._scaleY && cc.logID(1603);
        return this._scaleX;
      },
      setScale: function(scaleX, scaleY) {
        if ("object" === typeof scaleX) {
          scaleY = scaleX.y;
          scaleX = scaleX.x;
        } else scaleY = scaleY || 0 === scaleY ? scaleY : scaleX;
        if (this._scaleX !== scaleX || this._scaleY !== scaleY) {
          this._scaleX = scaleX;
          this._scaleY = scaleY;
          this._sgNode.setScale(scaleX, scaleY);
          var cache = this._hasListenerCache;
          cache && cache[SCALE_CHANGED] && this.emit(SCALE_CHANGED);
        }
      },
      getContentSize: function(ignoreSizeProvider) {
        if (this._sizeProvider && !ignoreSizeProvider) {
          var size = this._sizeProvider.getContentSize();
          this._contentSize = size;
          return cc.size(size);
        }
        return cc.size(this._contentSize);
      },
      setContentSize: function(size, height) {
        var locContentSize = this._contentSize;
        var clone;
        if (void 0 === height) {
          if (size.width === locContentSize.width && size.height === locContentSize.height) return;
          false;
          locContentSize.width = size.width;
          locContentSize.height = size.height;
        } else {
          if (size === locContentSize.width && height === locContentSize.height) return;
          false;
          locContentSize.width = size;
          locContentSize.height = height;
        }
        this._sizeProvider && this._sizeProvider.setContentSize(locContentSize);
        false;
        this.emit(SIZE_CHANGED);
      },
      setOpacityModifyRGB: function(opacityValue) {
        if (this._opacityModifyRGB !== opacityValue) {
          this._opacityModifyRGB = opacityValue;
          this._sgNode.setOpacityModifyRGB(opacityValue);
          var sizeProvider = this._sizeProvider;
          sizeProvider instanceof _ccsg.Node && sizeProvider !== this._sgNode && sizeProvider.setOpacityModifyRGB(opacityValue);
        }
      },
      isOpacityModifyRGB: function() {
        return this._opacityModifyRGB;
      },
      setGlobalZOrder: function(globalZOrder) {
        this._globalZOrder = globalZOrder;
        this._sgNode.setGlobalZOrder(globalZOrder);
      },
      getGlobalZOrder: function() {
        this._globalZOrder = this._sgNode.getGlobalZOrder();
        return this._globalZOrder;
      },
      getAnchorPoint: function() {
        return cc.p(this._anchorPoint);
      },
      setAnchorPoint: function(point, y) {
        var locAnchorPoint = this._anchorPoint;
        if (void 0 === y) {
          if (point.x === locAnchorPoint.x && point.y === locAnchorPoint.y) return;
          locAnchorPoint.x = point.x;
          locAnchorPoint.y = point.y;
        } else {
          if (point === locAnchorPoint.x && y === locAnchorPoint.y) return;
          locAnchorPoint.x = point;
          locAnchorPoint.y = y;
        }
        var sizeProvider = this._sizeProvider;
        sizeProvider instanceof _ccsg.Node && sizeProvider.setAnchorPoint(locAnchorPoint);
        this.emit(ANCHOR_CHANGED);
      },
      getAnchorPointInPoints: function() {
        return this._sgNode.getAnchorPointInPoints();
      },
      getDisplayedOpacity: function() {
        return this._sgNode.getDisplayedOpacity();
      },
      _updateDisplayedOpacity: function(parentOpacity) {
        this._sgNode.updateDisplayedOpacity(parentOpacity);
      },
      getDisplayedColor: function() {
        return this._sgNode.getDisplayedColor();
      },
      getNodeToParentTransformAR: function() {
        var contentSize = this.getContentSize();
        var mat = this._sgNode.getNodeToParentTransform();
        if (!this._isSgTransformArToMe(contentSize)) {
          var tx = this._anchorPoint.x * contentSize.width;
          var ty = this._anchorPoint.y * contentSize.height;
          var offset = cc.affineTransformMake(1, 0, 0, 1, tx, ty);
          mat = cc.affineTransformConcatIn(offset, mat);
        }
        return mat;
      },
      getBoundingBox: function() {
        var size = this.getContentSize();
        var rect = cc.rect(0, 0, size.width, size.height);
        return cc._rectApplyAffineTransformIn(rect, this.getNodeToParentTransform());
      },
      getBoundingBoxToWorld: function() {
        var trans;
        this.parent && (trans = this.parent.getNodeToWorldTransformAR());
        return this._getBoundingBoxTo(trans);
      },
      _getBoundingBoxTo: function(parentTransformAR) {
        var size = this.getContentSize();
        var width = size.width;
        var height = size.height;
        var rect = cc.rect(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
        var transAR = cc.affineTransformConcat(this.getNodeToParentTransformAR(), parentTransformAR);
        cc._rectApplyAffineTransformIn(rect, transAR);
        if (!this._children) return rect;
        var locChildren = this._children;
        for (var i = 0; i < locChildren.length; i++) {
          var child = locChildren[i];
          if (child && child.active) {
            var childRect = child._getBoundingBoxTo(transAR);
            childRect && (rect = cc.rectUnion(rect, childRect));
          }
        }
        return rect;
      },
      getNodeToParentTransform: function() {
        var contentSize = this.getContentSize();
        var mat = this._sgNode.getNodeToParentTransform();
        if (this._isSgTransformArToMe(contentSize)) {
          var tx = -this._anchorPoint.x * contentSize.width;
          var ty = -this._anchorPoint.y * contentSize.height;
          var offset = cc.affineTransformMake(1, 0, 0, 1, tx, ty);
          mat = cc.affineTransformConcatIn(offset, mat);
        }
        return mat;
      },
      getNodeToWorldTransform: function() {
        var contentSize = this.getContentSize();
        cc._renderType === cc.game.RENDER_TYPE_CANVAS && cc.director._visitScene();
        var mat = this._sgNode.getNodeToWorldTransform();
        if (this._isSgTransformArToMe(contentSize)) {
          var tx = -this._anchorPoint.x * contentSize.width;
          var ty = -this._anchorPoint.y * contentSize.height;
          var offset = cc.affineTransformMake(1, 0, 0, 1, tx, ty);
          mat = cc.affineTransformConcatIn(offset, mat);
        }
        return mat;
      },
      getNodeToWorldTransformAR: function() {
        var contentSize = this.getContentSize();
        cc._renderType === cc.game.RENDER_TYPE_CANVAS && cc.director._visitScene();
        var mat = this._sgNode.getNodeToWorldTransform();
        if (!this._isSgTransformArToMe(contentSize)) {
          var tx = this._anchorPoint.x * contentSize.width;
          var ty = this._anchorPoint.y * contentSize.height;
          var offset = cc.affineTransformMake(1, 0, 0, 1, tx, ty);
          mat = cc.affineTransformConcatIn(offset, mat);
        }
        return mat;
      },
      getParentToNodeTransform: function() {
        return this._sgNode.getParentToNodeTransform();
      },
      getWorldToNodeTransform: function() {
        cc._renderType === cc.game.RENDER_TYPE_CANVAS && cc.director._visitScene();
        return this._sgNode.getWorldToNodeTransform();
      },
      _isSgTransformArToMe: function(myContentSize) {
        var renderSize = this._sgNode.getContentSize();
        if (0 === renderSize.width && 0 === renderSize.height && (0 !== myContentSize.width || 0 !== myContentSize.height)) return true;
        if (this._sgNode.isIgnoreAnchorPointForPosition()) return true;
        return false;
      },
      convertToNodeSpace: function(worldPoint) {
        cc._renderType === cc.game.RENDER_TYPE_CANVAS && cc.director._visitScene();
        var nodePositionIgnoreAnchorPoint = this._sgNode.convertToNodeSpace(worldPoint);
        return cc.pAdd(nodePositionIgnoreAnchorPoint, cc.p(this._anchorPoint.x * this._contentSize.width, this._anchorPoint.y * this._contentSize.height));
      },
      convertToWorldSpace: function(nodePoint) {
        cc._renderType === cc.game.RENDER_TYPE_CANVAS && cc.director._visitScene();
        var x = nodePoint.x - this._anchorPoint.x * this._contentSize.width;
        var y = nodePoint.y - this._anchorPoint.y * this._contentSize.height;
        return cc.v2(this._sgNode.convertToWorldSpace(cc.v2(x, y)));
      },
      convertToNodeSpaceAR: function(worldPoint) {
        cc._renderType === cc.game.RENDER_TYPE_CANVAS && cc.director._visitScene();
        return this._sgNode.isIgnoreAnchorPointForPosition() ? cc.v2(this._sgNode.convertToNodeSpace(worldPoint)) : this._sgNode.convertToNodeSpaceAR(worldPoint);
      },
      convertToWorldSpaceAR: function(nodePoint) {
        cc._renderType === cc.game.RENDER_TYPE_CANVAS && cc.director._visitScene();
        return this._sgNode.isIgnoreAnchorPointForPosition() ? cc.v2(this._sgNode.convertToWorldSpace(nodePoint)) : cc.v2(this._sgNode.convertToWorldSpaceAR(nodePoint));
      },
      convertTouchToNodeSpace: function(touch) {
        return this.convertToNodeSpace(touch.getLocation());
      },
      convertTouchToNodeSpaceAR: function(touch) {
        return this.convertToNodeSpaceAR(touch.getLocation());
      },
      setNodeDirty: function() {
        this._sgNode.setNodeDirty();
      },
      addChild: function(child, localZOrder, tag) {
        localZOrder = void 0 === localZOrder ? child._localZOrder : localZOrder;
        var name, setTag = false;
        if ("undefined" === typeof tag) {
          tag = void 0;
          name = child._name;
        } else if (cc.js.isString(tag)) {
          name = tag;
          tag = void 0;
        } else if (cc.js.isNumber(tag)) {
          setTag = true;
          name = "";
        }
        if (true, !cc.Node.isNode(child)) return cc.errorID(1634, cc.js.getClassName(child));
        cc.assertID(child, 1606);
        cc.assertID(null === child._parent, 1605);
        child.parent = this;
        child.zIndex = localZOrder;
        setTag ? child.setTag(tag) : child.setName(name);
      },
      cleanup: function() {
        ActionManagerExist && cc.director.getActionManager().removeAllActionsFromTarget(this);
        cc.eventManager.removeListeners(this);
        var i, len = this._children.length, node;
        for (i = 0; i < len; ++i) {
          node = this._children[i];
          node && node.cleanup();
        }
      },
      sortAllChildren: function() {
        if (this._reorderChildDirty) {
          this._reorderChildDirty = false;
          var _children = this._children;
          if (_children.length > 1) {
            var len = _children.length, i, j, child;
            for (i = 1; i < len; i++) {
              child = _children[i];
              j = i - 1;
              while (j >= 0) {
                if (child._localZOrder < _children[j]._localZOrder) _children[j + 1] = _children[j]; else {
                  if (!(child._localZOrder === _children[j]._localZOrder && child._sgNode._arrivalOrder < _children[j]._sgNode._arrivalOrder)) break;
                  _children[j + 1] = _children[j];
                }
                j--;
              }
              _children[j + 1] = child;
            }
            this.emit(CHILD_REORDER);
          }
          cc.director.__fastOff(cc.Director.EVENT_AFTER_UPDATE, this.sortAllChildren, this);
        }
      },
      _delaySort: function() {
        if (!this._reorderChildDirty) {
          this._reorderChildDirty = true;
          cc.director.__fastOn(cc.Director.EVENT_AFTER_UPDATE, this.sortAllChildren, this);
        }
      },
      _updateDummySgNode: function() {
        var self = this;
        var sgNode = self._sgNode;
        sgNode.setPosition(self._position);
        sgNode.setRotationX(self._rotationX);
        sgNode.setRotationY(self._rotationY);
        sgNode.setScale(self._scaleX, self._scaleY);
        sgNode.setSkewX(self._skewX);
        sgNode.setSkewY(self._skewY);
        var arrivalOrder = sgNode._arrivalOrder;
        sgNode.setLocalZOrder(self._localZOrder);
        sgNode._arrivalOrder = arrivalOrder;
        sgNode.setGlobalZOrder(self._globalZOrder);
        false;
        sgNode.setOpacity(self._opacity);
        sgNode.setOpacityModifyRGB(self._opacityModifyRGB);
        sgNode.setCascadeOpacityEnabled(self._cascadeOpacityEnabled);
        sgNode.setTag(self._tag);
      },
      _updateSgNode: function() {
        this._updateDummySgNode();
        var sgNode = this._sgNode;
        sgNode.setAnchorPoint(this._anchorPoint);
        sgNode.setVisible(this._active);
        sgNode.setColor(this._color);
        var actionManager = ActionManagerExist ? cc.director.getActionManager() : null;
        if (this._activeInHierarchy) {
          actionManager && actionManager.resumeTarget(this);
          cc.eventManager.resumeTarget(this);
        } else {
          actionManager && actionManager.pauseTarget(this);
          cc.eventManager.pauseTarget(this);
        }
      },
      _removeSgNode: SgHelper.removeSgNode,
      onRestore: false
    });
    var updateListeners;
    false;
    var SameNameGetSets = [ "parent", "tag", "skewX", "skewY", "position", "rotation", "rotationX", "rotationY", "scale", "scaleX", "scaleY", "opacity", "color" ];
    var DiffNameGetSets = {
      x: [ "getPositionX", "setPositionX" ],
      y: [ "getPositionY", "setPositionY" ],
      zIndex: [ "getLocalZOrder", "setLocalZOrder" ],
      opacityModifyRGB: [ "isOpacityModifyRGB", "setOpacityModifyRGB" ],
      cascadeOpacity: [ "isCascadeOpacityEnabled", "setCascadeOpacityEnabled" ]
    };
    Misc.propertyDefine(Node, SameNameGetSets, DiffNameGetSets);
    Node.EventType = EventType;
    cc.Node = module.exports = Node;
  }), {
    "./event/event": 114,
    "./utils/base-node": 220,
    "./utils/misc": 225,
    "./utils/prefab-helper": 227,
    "./utils/scene-graph-helper": 228
  } ],
  41: [ (function(require, module, exports) {
    var NIL = function() {};
    cc.Scene = cc.Class({
      name: "cc.Scene",
      extends: require("./CCNode"),
      properties: {
        autoReleaseAssets: void 0
      },
      ctor: function() {
        var sgNode = this._sgNode = new _ccsg.Scene();
        false;
        sgNode.setAnchorPoint(0, 0);
        this._anchorPoint.x = 0;
        this._anchorPoint.y = 0;
        this._activeInHierarchy = false;
        this._inited = !cc.game._isCloning;
        this.dependAssets = null;
      },
      destroy: function() {
        this._super();
        this._activeInHierarchy = false;
      },
      _onHierarchyChanged: NIL,
      _instantiate: null,
      _load: function() {
        if (!this._inited) {
          false;
          this._onBatchCreated();
          this._inited = true;
        }
      },
      _activate: function(active) {
        active = false !== active;
        false, false;
        cc.director._nodeActivator.activateNode(this, active);
      }
    });
    module.exports = cc.Scene;
  }), {
    "./CCNode": 40
  } ],
  42: [ (function(require, module, exports) {
    var MAX_POOL_SIZE = 20;
    var ListEntry = function(prev, next, callback, target, priority, paused, markedForDeletion) {
      this.prev = prev;
      this.next = next;
      this.callback = callback;
      this.target = target;
      this.priority = priority;
      this.paused = paused;
      this.markedForDeletion = markedForDeletion;
      this.isUpdate = !callback;
    };
    var _listEntries = [];
    ListEntry.get = function(prev, next, callback, target, priority, paused, markedForDeletion) {
      var result = _listEntries.pop();
      if (result) {
        result.prev = prev;
        result.next = next;
        result.callback = callback;
        result.target = target;
        result.priority = priority;
        result.paused = paused;
        result.markedForDeletion = markedForDeletion;
        result.isUpdate = !callback;
      } else result = new ListEntry(prev, next, callback, target, priority, paused, markedForDeletion);
      return result;
    };
    ListEntry.put = function(entry) {
      if (_listEntries.length < MAX_POOL_SIZE) {
        entry.prev = entry.next = entry.callback = entry.target = null;
        _listEntries.push(entry);
      }
    };
    var HashUpdateEntry = function(list, entry, target, callback) {
      this.list = list;
      this.entry = entry;
      this.target = target;
      this.callback = callback;
    };
    var _hashUpdateEntries = [];
    HashUpdateEntry.get = function(list, entry, target, callback) {
      var result = _hashUpdateEntries.pop();
      if (result) {
        result.list = list;
        result.entry = entry;
        result.target = target;
        result.callback = callback;
      } else result = new HashUpdateEntry(list, entry, target, callback);
      return result;
    };
    HashUpdateEntry.put = function(entry) {
      if (_hashUpdateEntries.length < MAX_POOL_SIZE) {
        entry.list = entry.entry = entry.target = entry.callback = null;
        _hashUpdateEntries.push(entry);
      }
    };
    var HashTimerEntry = function(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) {
      var _t = this;
      _t.timers = timers;
      _t.target = target;
      _t.timerIndex = timerIndex;
      _t.currentTimer = currentTimer;
      _t.currentTimerSalvaged = currentTimerSalvaged;
      _t.paused = paused;
    };
    var _hashTimerEntries = [];
    HashTimerEntry.get = function(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) {
      var result = _hashTimerEntries.pop();
      if (result) {
        result.timers = timers;
        result.target = target;
        result.timerIndex = timerIndex;
        result.currentTimer = currentTimer;
        result.currentTimerSalvaged = currentTimerSalvaged;
        result.paused = paused;
      } else result = new HashTimerEntry(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused);
      return result;
    };
    HashTimerEntry.put = function(entry) {
      if (_hashTimerEntries.length < MAX_POOL_SIZE) {
        entry.timers = entry.target = entry.currentTimer = null;
        _hashTimerEntries.push(entry);
      }
    };
    function CallbackTimer() {
      this._scheduler = null;
      this._elapsed = -1;
      this._runForever = false;
      this._useDelay = false;
      this._timesExecuted = 0;
      this._repeat = 0;
      this._delay = 0;
      this._interval = 0;
      this._target = null;
      this._callback = null;
    }
    var proto = CallbackTimer.prototype;
    proto.initWithCallback = function(scheduler, callback, target, seconds, repeat, delay) {
      this._scheduler = scheduler;
      this._target = target;
      this._callback = callback;
      this._elapsed = -1;
      this._interval = seconds;
      this._delay = delay;
      this._useDelay = this._delay > 0;
      this._repeat = repeat;
      this._runForever = this._repeat === cc.macro.REPEAT_FOREVER;
      return true;
    };
    proto.getInterval = function() {
      return this._interval;
    };
    proto.setInterval = function(interval) {
      this._interval = interval;
    };
    proto.update = function(dt) {
      if (-1 === this._elapsed) {
        this._elapsed = 0;
        this._timesExecuted = 0;
      } else {
        this._elapsed += dt;
        if (this._runForever && !this._useDelay) {
          if (this._elapsed >= this._interval) {
            this.trigger();
            this._elapsed = 0;
          }
        } else {
          if (this._useDelay) {
            if (this._elapsed >= this._delay) {
              this.trigger();
              this._elapsed -= this._delay;
              this._timesExecuted += 1;
              this._useDelay = false;
            }
          } else if (this._elapsed >= this._interval) {
            this.trigger();
            this._elapsed = 0;
            this._timesExecuted += 1;
          }
          this._callback && !this._runForever && this._timesExecuted > this._repeat && this.cancel();
        }
      }
    };
    proto.getCallback = function() {
      return this._callback;
    };
    proto.trigger = function() {
      this._target && this._callback && this._callback.call(this._target, this._elapsed);
    };
    proto.cancel = function() {
      this._scheduler.unschedule(this._callback, this._target);
    };
    var _timers = [];
    CallbackTimer.get = function() {
      return _timers.pop() || new CallbackTimer();
    };
    CallbackTimer.put = function(timer) {
      if (_timers.length < MAX_POOL_SIZE) {
        timer._scheduler = timer._target = timer._callback = null;
        _timers.push(timer);
      }
    };
    var getTargetId = function(target) {
      return target.__instanceId || target.uuid;
    };
    cc.Scheduler = cc._Class.extend({
      ctor: function() {
        this._timeScale = 1;
        this._updatesNegList = [];
        this._updates0List = [];
        this._updatesPosList = [];
        this._hashForUpdates = {};
        this._hashForTimers = {};
        this._currentTarget = null;
        this._currentTargetSalvaged = false;
        this._updateHashLocked = false;
        this._arrayForTimers = [];
      },
      _removeHashElement: function(element) {
        delete this._hashForTimers[getTargetId(element.target)];
        var arr = this._arrayForTimers;
        for (var i = 0, l = arr.length; i < l; i++) if (arr[i] === element) {
          arr.splice(i, 1);
          break;
        }
        HashTimerEntry.put(element);
      },
      _removeUpdateFromHash: function(entry) {
        var targetId = getTargetId(entry.target);
        var self = this, element = self._hashForUpdates[targetId];
        if (element) {
          var list = element.list, listEntry = element.entry;
          for (var i = 0, l = list.length; i < l; i++) if (list[i] === listEntry) {
            list.splice(i, 1);
            break;
          }
          delete self._hashForUpdates[targetId];
          ListEntry.put(listEntry);
          HashUpdateEntry.put(element);
        }
      },
      _priorityIn: function(ppList, listElement, priority) {
        for (var i = 0; i < ppList.length; i++) if (priority < ppList[i].priority) {
          ppList.splice(i, 0, listElement);
          return;
        }
        ppList.push(listElement);
      },
      _appendIn: function(ppList, listElement) {
        ppList.push(listElement);
      },
      setTimeScale: function(timeScale) {
        this._timeScale = timeScale;
      },
      getTimeScale: function() {
        return this._timeScale;
      },
      update: function(dt) {
        this._updateHashLocked = true;
        1 !== this._timeScale && (dt *= this._timeScale);
        var i, list, len, entry;
        for (i = 0, list = this._updatesNegList, len = list.length; i < len; i++) {
          entry = list[i];
          entry.paused || entry.markedForDeletion || (entry.isUpdate ? entry.target.update(dt) : entry.callback.call(entry.target, dt));
        }
        for (i = 0, list = this._updates0List, len = list.length; i < len; i++) {
          entry = list[i];
          entry.paused || entry.markedForDeletion || (entry.isUpdate ? entry.target.update(dt) : entry.callback.call(entry.target, dt));
        }
        for (i = 0, list = this._updatesPosList, len = list.length; i < len; i++) {
          entry = list[i];
          entry.paused || entry.markedForDeletion || (entry.isUpdate ? entry.target.update(dt) : entry.callback.call(entry.target, dt));
        }
        var elt, arr = this._arrayForTimers;
        for (i = 0; i < arr.length; i++) {
          elt = arr[i];
          this._currentTarget = elt;
          this._currentTargetSalvaged = false;
          if (!elt.paused) for (elt.timerIndex = 0; elt.timerIndex < elt.timers.length; ++elt.timerIndex) {
            elt.currentTimer = elt.timers[elt.timerIndex];
            elt.currentTimerSalvaged = false;
            elt.currentTimer.update(dt);
            elt.currentTimer = null;
          }
          if (this._currentTargetSalvaged && 0 === this._currentTarget.timers.length) {
            this._removeHashElement(this._currentTarget);
            --i;
          }
        }
        for (i = 0, list = this._updatesNegList; i < list.length; ) {
          entry = list[i];
          entry.markedForDeletion ? this._removeUpdateFromHash(entry) : i++;
        }
        for (i = 0, list = this._updates0List; i < list.length; ) {
          entry = list[i];
          entry.markedForDeletion ? this._removeUpdateFromHash(entry) : i++;
        }
        for (i = 0, list = this._updatesPosList; i < list.length; ) {
          entry = list[i];
          entry.markedForDeletion ? this._removeUpdateFromHash(entry) : i++;
        }
        this._updateHashLocked = false;
        this._currentTarget = null;
      },
      scheduleCallbackForTarget: function(target, callback_fn, interval, repeat, delay, paused) {
        this.schedule(callback_fn, target, interval, repeat, delay, paused);
      },
      schedule: function(callback, target, interval, repeat, delay, paused) {
        "use strict";
        if ("function" !== typeof callback) {
          var tmp = callback;
          callback = target;
          target = tmp;
        }
        if (4 === arguments.length || 5 === arguments.length) {
          paused = !!repeat;
          repeat = cc.macro.REPEAT_FOREVER;
          delay = 0;
        }
        cc.assertID(target, 1502);
        var instanceId = getTargetId(target);
        cc.assertID(instanceId, 1510);
        var element = this._hashForTimers[instanceId];
        if (element) element.paused !== paused && cc.warnID(1511); else {
          element = HashTimerEntry.get(null, target, 0, null, null, paused);
          this._arrayForTimers.push(element);
          this._hashForTimers[instanceId] = element;
        }
        var timer, i;
        if (null == element.timers) element.timers = []; else for (i = 0; i < element.timers.length; ++i) {
          timer = element.timers[i];
          if (timer && callback === timer._callback) {
            cc.logID(1507, timer.getInterval(), interval);
            timer._interval = interval;
            return;
          }
        }
        timer = CallbackTimer.get();
        timer.initWithCallback(this, callback, target, interval, repeat, delay);
        element.timers.push(timer);
      },
      scheduleUpdate: function(target, priority, paused, updateFunc) {
        var targetId = getTargetId(target);
        cc.assertID(targetId, 1510);
        var hashElement = this._hashForUpdates[targetId];
        if (hashElement && hashElement.entry) {
          if (hashElement.entry.priority === priority) {
            hashElement.entry.markedForDeletion = false;
            hashElement.entry.paused = paused;
            return;
          }
          if (this._updateHashLocked) {
            cc.logID(1506);
            hashElement.entry.markedForDeletion = false;
            hashElement.entry.paused = paused;
            return;
          }
          this.unscheduleUpdate(target);
        }
        var listElement = ListEntry.get(null, null, updateFunc, target, priority, paused, false);
        var ppList;
        if (0 === priority) {
          ppList = this._updates0List;
          this._appendIn(ppList, listElement);
        } else {
          ppList = priority < 0 ? this._updatesNegList : this._updatesPosList;
          this._priorityIn(ppList, listElement, priority);
        }
        this._hashForUpdates[targetId] = HashUpdateEntry.get(ppList, listElement, target, null);
      },
      unschedule: function(callback, target) {
        if (!target || !callback) return;
        var targetId = getTargetId(target);
        cc.assertID(targetId, 1510);
        var self = this, element = self._hashForTimers[targetId];
        if (element) {
          var timers = element.timers;
          for (var i = 0, li = timers.length; i < li; i++) {
            var timer = timers[i];
            if (callback === timer._callback) {
              timer !== element.currentTimer || element.currentTimerSalvaged || (element.currentTimerSalvaged = true);
              timers.splice(i, 1);
              CallbackTimer.put(timer);
              element.timerIndex >= i && element.timerIndex--;
              0 === timers.length && (self._currentTarget === element ? self._currentTargetSalvaged = true : self._removeHashElement(element));
              return;
            }
          }
        }
      },
      unscheduleUpdate: function(target) {
        if (!target) return;
        var targetId = getTargetId(target);
        cc.assertID(targetId, 1510);
        var element = this._hashForUpdates[targetId];
        element && (this._updateHashLocked ? element.entry.markedForDeletion = true : this._removeUpdateFromHash(element.entry));
      },
      unscheduleAllForTarget: function(target) {
        if (!target) return;
        var targetId = getTargetId(target);
        cc.assertID(targetId, 1510);
        var element = this._hashForTimers[targetId];
        if (element) {
          var timers = element.timers;
          timers.indexOf(element.currentTimer) > -1 && !element.currentTimerSalvaged && (element.currentTimerSalvaged = true);
          for (var i = 0, l = timers.length; i < l; i++) CallbackTimer.put(timers[i]);
          timers.length = 0;
          this._currentTarget === element ? this._currentTargetSalvaged = true : this._removeHashElement(element);
        }
        this.unscheduleUpdate(target);
      },
      unscheduleAll: function() {
        this.unscheduleAllWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
      },
      unscheduleAllWithMinPriority: function(minPriority) {
        var i, element, arr = this._arrayForTimers;
        for (i = arr.length - 1; i >= 0; i--) {
          element = arr[i];
          this.unscheduleAllForTarget(element.target);
        }
        var entry;
        var temp_length = 0;
        if (minPriority < 0) for (i = 0; i < this._updatesNegList.length; ) {
          temp_length = this._updatesNegList.length;
          entry = this._updatesNegList[i];
          entry && entry.priority >= minPriority && this.unscheduleUpdate(entry.target);
          temp_length == this._updatesNegList.length && i++;
        }
        if (minPriority <= 0) for (i = 0; i < this._updates0List.length; ) {
          temp_length = this._updates0List.length;
          entry = this._updates0List[i];
          entry && this.unscheduleUpdate(entry.target);
          temp_length == this._updates0List.length && i++;
        }
        for (i = 0; i < this._updatesPosList.length; ) {
          temp_length = this._updatesPosList.length;
          entry = this._updatesPosList[i];
          entry && entry.priority >= minPriority && this.unscheduleUpdate(entry.target);
          temp_length == this._updatesPosList.length && i++;
        }
      },
      isScheduled: function(callback, target) {
        cc.assertID(callback, 1508);
        cc.assertID(target, 1509);
        var targetId = getTargetId(target);
        cc.assertID(targetId, 1510);
        var element = this._hashForTimers[targetId];
        if (!element) return false;
        if (null == element.timers) return false;
        var timers = element.timers;
        for (var i = 0; i < timers.length; ++i) {
          var timer = timers[i];
          if (callback === timer._callback) return true;
        }
        return false;
      },
      pauseAllTargets: function() {
        return this.pauseAllTargetsWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
      },
      pauseAllTargetsWithMinPriority: function(minPriority) {
        var idsWithSelectors = [];
        var self = this, element, locArrayForTimers = self._arrayForTimers;
        var i, li;
        for (i = 0, li = locArrayForTimers.length; i < li; i++) {
          element = locArrayForTimers[i];
          if (element) {
            element.paused = true;
            idsWithSelectors.push(element.target);
          }
        }
        var entry;
        if (minPriority < 0) for (i = 0; i < this._updatesNegList.length; i++) {
          entry = this._updatesNegList[i];
          if (entry && entry.priority >= minPriority) {
            entry.paused = true;
            idsWithSelectors.push(entry.target);
          }
        }
        if (minPriority <= 0) for (i = 0; i < this._updates0List.length; i++) {
          entry = this._updates0List[i];
          if (entry) {
            entry.paused = true;
            idsWithSelectors.push(entry.target);
          }
        }
        for (i = 0; i < this._updatesPosList.length; i++) {
          entry = this._updatesPosList[i];
          if (entry && entry.priority >= minPriority) {
            entry.paused = true;
            idsWithSelectors.push(entry.target);
          }
        }
        return idsWithSelectors;
      },
      resumeTargets: function(targetsToResume) {
        if (!targetsToResume) return;
        for (var i = 0; i < targetsToResume.length; i++) this.resumeTarget(targetsToResume[i]);
      },
      pauseTarget: function(target) {
        cc.assertID(target, 1503);
        var targetId = getTargetId(target);
        cc.assertID(targetId, 1510);
        var self = this, element = self._hashForTimers[targetId];
        element && (element.paused = true);
        var elementUpdate = self._hashForUpdates[targetId];
        elementUpdate && (elementUpdate.entry.paused = true);
      },
      resumeTarget: function(target) {
        cc.assertID(target, 1504);
        var targetId = getTargetId(target);
        cc.assertID(targetId, 1510);
        var self = this, element = self._hashForTimers[targetId];
        element && (element.paused = false);
        var elementUpdate = self._hashForUpdates[targetId];
        elementUpdate && (elementUpdate.entry.paused = false);
      },
      isTargetPaused: function(target) {
        cc.assertID(target, 1505);
        var targetId = getTargetId(target);
        cc.assertID(targetId, 1510);
        var element = this._hashForTimers[targetId];
        if (element) return element.paused;
        var elementUpdate = this._hashForUpdates[targetId];
        if (elementUpdate) return elementUpdate.entry.paused;
        return false;
      },
      scheduleUpdateForTarget: function(target, priority, paused) {
        this.scheduleUpdate(target, priority, paused);
      },
      unscheduleCallbackForTarget: function(target, callback) {
        this.unschedule(callback, target);
      },
      unscheduleUpdateForTarget: function(target) {
        this.unscheduleUpdate(target);
      },
      unscheduleAllCallbacksForTarget: function(target) {
        this.unscheduleAllForTarget(target);
      },
      unscheduleAllCallbacks: function() {
        this.unscheduleAllWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
      },
      unscheduleAllCallbacksWithMinPriority: function(minPriority) {
        this.unscheduleAllWithMinPriority(minPriority);
      }
    });
    cc.Scheduler.PRIORITY_SYSTEM = 1 << 31;
    cc.Scheduler.PRIORITY_NON_SYSTEM = cc.Scheduler.PRIORITY_SYSTEM + 1;
  }), {} ],
  43: [ (function(require, module, exports) {
    var RawAsset = require("./CCRawAsset");
    cc.Asset = cc.Class({
      name: "cc.Asset",
      extends: RawAsset,
      properties: {
        rawUrl: {
          get: function() {
            if (this._rawFiles) {
              if (cc.AssetLibrary) return cc.AssetLibrary.getLibUrlNoExt(this._uuid) + "/" + this._rawFiles[0];
              cc.errorID(6400);
            }
            return "";
          },
          visible: false
        },
        rawUrls: {
          get: function() {
            if (this._rawFiles) {
              if (cc.AssetLibrary) {
                var dir = cc.AssetLibrary.getLibUrlNoExt(this._uuid) + "/";
                return this._rawFiles.map((function(filename) {
                  return dir + filename;
                }));
              }
              cc.errorID(6401);
            }
            return [];
          },
          visible: false
        },
        _rawFiles: null
      },
      statics: {
        deserialize: function(data) {
          return cc.deserialize(data);
        },
        preventDeferredLoadDependents: false
      },
      serialize: function() {
        return Editor.serialize(this);
      },
      createNode: null,
      _setRawFiles: function(rawFiles) {
        this._rawFiles = rawFiles.length > 0 ? rawFiles : null;
      },
      _preloadRawFiles: null
    });
    module.exports = cc.Asset;
  }), {
    "./CCRawAsset": 49
  } ],
  44: [ (function(require, module, exports) {
    var AudioClip = cc.Class({
      name: "cc.AudioClip",
      extends: cc.RawAsset
    });
    cc.AudioClip = AudioClip;
    module.exports = AudioClip;
  }), {} ],
  45: [ (function(require, module, exports) {
    var BitmapFont = cc.Class({
      name: "cc.BitmapFont",
      extends: cc.Font,
      properties: {
        fntDataStr: {
          default: ""
        },
        spriteFrame: {
          default: null,
          type: cc.SpriteFrame
        },
        fontSize: {
          default: -1
        },
        _fntConfig: null
      }
    });
    cc.BitmapFont = BitmapFont;
    module.exports = BitmapFont;
  }), {} ],
  46: [ (function(require, module, exports) {
    var Font = cc.Class({
      name: "cc.Font",
      extends: cc.Asset
    });
    cc.Font = Font;
    module.exports = Font;
  }), {} ],
  47: [ (function(require, module, exports) {
    var LabelAtlas = cc.Class({
      name: "cc.LabelAtlas",
      extends: cc.BitmapFont
    });
    cc.LabelAtlas = LabelAtlas;
    module.exports = LabelAtlas;
  }), {} ],
  48: [ (function(require, module, exports) {
    var Prefab = cc.Class({
      name: "cc.Prefab",
      extends: cc.Asset,
      properties: {
        data: null,
        asyncLoadAssets: void 0,
        _createFunction: {
          default: null,
          serializable: false
        }
      },
      createNode: false,
      compileCreateFunction: function() {
        var jit = require("../platform/instantiate-jit");
        this._createFunction = jit.compile(this.data);
      },
      _doInstantiate: function(rootToRedirect) {
        this.data._prefab ? this.data._prefab._synced = true : cc.warnID(3700);
        this._createFunction || this.compileCreateFunction();
        return this._createFunction(rootToRedirect);
      },
      _instantiate: function() {
        var node;
        true;
        node = this._doInstantiate();
        this.data._instantiate(node);
        false, false;
        return node;
      }
    });
    cc.Prefab = module.exports = Prefab;
    cc.js.obsolete(cc, "cc._Prefab", "Prefab");
  }), {
    "../platform/instantiate-jit": 194
  } ],
  49: [ (function(require, module, exports) {
    var CCObject = require("../platform/CCObject");
    cc.RawAsset = cc.Class({
      name: "cc.RawAsset",
      extends: CCObject,
      ctor: function() {
        Object.defineProperty(this, "_uuid", {
          value: "",
          writable: true
        });
      },
      statics: {
        createNodeByInfo: null
      }
    });
    Object.defineProperty(cc.RawAsset, "isRawAssetType", {
      value: function(ctor) {
        return cc.isChildClassOf(ctor, cc.RawAsset) && !cc.isChildClassOf(ctor, cc.Asset);
      }
    });
    module.exports = cc.RawAsset;
  }), {
    "../platform/CCObject": 181
  } ],
  50: [ (function(require, module, exports) {
    var Scene = cc.Class({
      name: "cc.SceneAsset",
      extends: cc.Asset,
      properties: {
        scene: null,
        asyncLoadAssets: void 0
      }
    });
    cc.SceneAsset = Scene;
    module.exports = Scene;
  }), {} ],
  51: [ (function(require, module, exports) {
    var Script = cc.Class({
      name: "cc.Script",
      extends: cc.Asset
    });
    cc._Script = Script;
    var JavaScript = cc.Class({
      name: "cc.JavaScript",
      extends: Script
    });
    cc._JavaScript = JavaScript;
    var CoffeeScript = cc.Class({
      name: "cc.CoffeeScript",
      extends: Script
    });
    cc._CoffeeScript = CoffeeScript;
    var TypeScript = cc.Class({
      name: "cc.TypeScript",
      extends: Script
    });
    cc._TypeScript = TypeScript;
  }), {} ],
  52: [ (function(require, module, exports) {
    var SpriteAtlas = cc.Class({
      name: "cc.SpriteAtlas",
      extends: cc.Asset,
      properties: {
        _spriteFrames: {
          default: {}
        }
      },
      getTexture: function() {
        var keys = Object.keys(this._spriteFrames);
        if (keys.length > 0) {
          var spriteFrame = this._spriteFrames[keys[0]];
          return spriteFrame ? spriteFrame.getTexture() : null;
        }
        return null;
      },
      getSpriteFrame: function(key) {
        return this._spriteFrames[key];
      },
      getSpriteFrames: function() {
        var frames = [];
        var spriteFrames = this._spriteFrames;
        for (var key in spriteFrames) frames.push(spriteFrames[key]);
        return frames;
      }
    });
    cc.SpriteAtlas = SpriteAtlas;
    module.exports = SpriteAtlas;
  }), {} ],
  53: [ (function(require, module, exports) {
    var TTFFont = cc.Class({
      name: "cc.TTFFont",
      extends: cc.Font
    });
    cc.TTFFont = TTFFont;
    module.exports = TTFFont;
  }), {} ],
  54: [ (function(require, module, exports) {
    require("./CCRawAsset");
    require("./CCAsset");
    require("./CCFont");
    require("./CCPrefab");
    require("./CCAudioClip");
    require("./CCScripts");
    require("./CCSceneAsset");
    require("../sprites/CCSpriteFrame");
    require("../textures/CCTexture2D");
    require("./CCTTFFont");
    require("./CCSpriteAtlas");
    require("./CCBitmapFont");
    require("./CCLabelAtlas");
  }), {
    "../sprites/CCSpriteFrame": 214,
    "../textures/CCTexture2D": 215,
    "./CCAsset": 43,
    "./CCAudioClip": 44,
    "./CCBitmapFont": 45,
    "./CCFont": 46,
    "./CCLabelAtlas": 47,
    "./CCPrefab": 48,
    "./CCRawAsset": 49,
    "./CCSceneAsset": 50,
    "./CCScripts": 51,
    "./CCSpriteAtlas": 52,
    "./CCTTFFont": 53
  } ],
  55: [ (function(require, module, exports) {
    var Misc = require("../utils/misc");
    var ActionManagerExist = !!cc.ActionManager;
    var emptyFunc = function() {};
    cc.s_globalOrderOfArrival = 1;
    _ccsg.Node = cc.Class({
      name: "ccsg.Node",
      properties: {
        _running: false,
        _localZOrder: 0,
        _globalZOrder: 0,
        _arrivalOrder: 0,
        _reorderChildDirty: false,
        _vertexZ: 0,
        _customZ: void 0,
        _rotationX: 0,
        _rotationY: 0,
        _scaleX: 1,
        _scaleY: 1,
        _position: cc.p(0, 0),
        _skewX: 0,
        _skewY: 0,
        _children: [],
        _visible: true,
        _anchorPoint: cc.p(0, 0),
        _contentSize: cc.size(0, 0),
        _parent: null,
        _ignoreAnchorPointForPosition: false,
        tag: cc.macro.NODE_TAG_INVALID,
        _name: "",
        _realOpacity: 255,
        _realColor: cc.Color.WHITE,
        _cascadeColorEnabled: false,
        _cascadeOpacityEnabled: false,
        _isTransitionFinished: false,
        _actionManager: null,
        _scheduler: null,
        _renderCmd: null
      },
      ctor: function() {
        this.__instanceId = cc.ClassManager.getNewInstanceId();
        this._renderCmd = this._createRenderCmd();
      },
      init: function() {
        return true;
      },
      attr: function(attrs) {
        for (var key in attrs) this[key] = attrs[key];
      },
      getSkewX: function() {
        return this._skewX;
      },
      setSkewX: function(newSkewX) {
        this._skewX = newSkewX;
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
      },
      getSkewY: function() {
        return this._skewY;
      },
      setSkewY: function(newSkewY) {
        this._skewY = newSkewY;
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
      },
      setLocalZOrder: function(localZOrder) {
        this._parent ? this._parent.reorderChild(this, localZOrder) : this._localZOrder = localZOrder;
        cc.eventManager._setDirtyForNode(this);
      },
      _setLocalZOrder: function(localZOrder) {
        this._localZOrder = localZOrder;
      },
      getLocalZOrder: function() {
        return this._localZOrder;
      },
      getZOrder: function() {
        cc.logID(1600);
        return this.getLocalZOrder();
      },
      setZOrder: function(z) {
        cc.logID(1601);
        this.setLocalZOrder(z);
      },
      setGlobalZOrder: function(globalZOrder) {
        if (this._globalZOrder !== globalZOrder) {
          this._globalZOrder = globalZOrder;
          cc.eventManager._setDirtyForNode(this);
        }
      },
      getGlobalZOrder: function() {
        return this._globalZOrder;
      },
      getVertexZ: function() {
        return this._vertexZ;
      },
      setVertexZ: function(Var) {
        this._customZ = this._vertexZ = Var;
      },
      getRotation: function() {
        this._rotationX !== this._rotationY && cc.logID(1602);
        return this._rotationX;
      },
      setRotation: function(newRotation) {
        this._rotationX = this._rotationY = newRotation;
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
      },
      getRotationX: function() {
        return this._rotationX;
      },
      setRotationX: function(rotationX) {
        this._rotationX = rotationX;
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
      },
      getRotationY: function() {
        return this._rotationY;
      },
      setRotationY: function(rotationY) {
        this._rotationY = rotationY;
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
      },
      getScale: function() {
        this._scaleX !== this._scaleY && cc.logID(1603);
        return this._scaleX;
      },
      setScale: function(scale, scaleY) {
        this._scaleX = scale;
        this._scaleY = scaleY || 0 === scaleY ? scaleY : scale;
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
      },
      getScaleX: function() {
        return this._scaleX;
      },
      setScaleX: function(newScaleX) {
        this._scaleX = newScaleX;
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
      },
      getScaleY: function() {
        return this._scaleY;
      },
      setScaleY: function(newScaleY) {
        this._scaleY = newScaleY;
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
      },
      setPosition: function(newPosOrxValue, yValue) {
        var locPosition = this._position;
        if (void 0 === yValue) {
          if (locPosition.x === newPosOrxValue.x && locPosition.y === newPosOrxValue.y) return;
          locPosition.x = newPosOrxValue.x;
          locPosition.y = newPosOrxValue.y;
        } else {
          if (locPosition.x === newPosOrxValue && locPosition.y === yValue) return;
          locPosition.x = newPosOrxValue;
          locPosition.y = yValue;
        }
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
      },
      getPosition: function() {
        return cc.p(this._position);
      },
      getPositionX: function() {
        return this._position.x;
      },
      setPositionX: function(x) {
        this._position.x = x;
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
      },
      getPositionY: function() {
        return this._position.y;
      },
      setPositionY: function(y) {
        this._position.y = y;
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
      },
      getChildrenCount: function() {
        return this._children.length;
      },
      getChildren: function() {
        return this._children;
      },
      isVisible: function() {
        return this._visible;
      },
      setVisible: function(visible) {
        if (this._visible !== visible) {
          this._visible = visible;
          this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
          cc.renderer.childrenOrderDirty = true;
        }
      },
      getAnchorPoint: function() {
        return cc.p(this._anchorPoint);
      },
      setAnchorPoint: function(point, y) {
        var locAnchorPoint = this._anchorPoint;
        if (void 0 === y) {
          if (point.x === locAnchorPoint.x && point.y === locAnchorPoint.y) return;
          locAnchorPoint.x = point.x;
          locAnchorPoint.y = point.y;
        } else {
          if (point === locAnchorPoint.x && y === locAnchorPoint.y) return;
          locAnchorPoint.x = point;
          locAnchorPoint.y = y;
        }
        this._renderCmd._updateAnchorPointInPoint();
      },
      _getAnchorX: function() {
        return this._anchorPoint.x;
      },
      _setAnchorX: function(x) {
        if (this._anchorPoint.x === x) return;
        this._anchorPoint.x = x;
        this._renderCmd._updateAnchorPointInPoint();
      },
      _getAnchorY: function() {
        return this._anchorPoint.y;
      },
      _setAnchorY: function(y) {
        if (this._anchorPoint.y === y) return;
        this._anchorPoint.y = y;
        this._renderCmd._updateAnchorPointInPoint();
      },
      getAnchorPointInPoints: function() {
        return this._renderCmd.getAnchorPointInPoints();
      },
      _getWidth: function() {
        return this._contentSize.width;
      },
      _setWidth: function(width) {
        this._contentSize.width = width;
        this._renderCmd._updateAnchorPointInPoint();
      },
      _getHeight: function() {
        return this._contentSize.height;
      },
      _setHeight: function(height) {
        this._contentSize.height = height;
        this._renderCmd._updateAnchorPointInPoint();
      },
      getContentSize: function() {
        return cc.size(this._contentSize);
      },
      setContentSize: function(size, height) {
        var locContentSize = this._contentSize;
        if (void 0 === height) {
          if (size.width === locContentSize.width && size.height === locContentSize.height) return;
          locContentSize.width = size.width;
          locContentSize.height = size.height;
        } else {
          if (size === locContentSize.width && height === locContentSize.height) return;
          locContentSize.width = size;
          locContentSize.height = height;
        }
        this._renderCmd._updateAnchorPointInPoint();
      },
      isRunning: function() {
        return this._running;
      },
      getParent: function() {
        return this._parent;
      },
      setParent: function(parent) {
        this._parent = parent;
        var dirtyFlags = _ccsg.Node._dirtyFlags;
        this._renderCmd.setDirtyFlag(dirtyFlags.transformDirty | dirtyFlags.opacityDirty);
      },
      isIgnoreAnchorPointForPosition: function() {
        return this._ignoreAnchorPointForPosition;
      },
      setIgnoreAnchorPointForPosition: function(newValue) {
        if (newValue !== this._ignoreAnchorPointForPosition) {
          this._ignoreAnchorPointForPosition = newValue;
          this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
        }
      },
      getTag: function() {
        return this.tag;
      },
      setTag: function(tag) {
        this.tag = tag;
      },
      setName: function(name) {
        this._name = name;
      },
      getName: function() {
        return this._name;
      },
      updateOrderOfArrival: function() {
        this._arrivalOrder = ++cc.s_globalOrderOfArrival;
      },
      getScheduler: function() {
        return this._scheduler || cc.director.getScheduler();
      },
      setScheduler: function(scheduler) {
        if (this._scheduler !== scheduler) {
          this.unscheduleAllCallbacks();
          this._scheduler = scheduler;
        }
      },
      boundingBox: function() {
        cc.logID(1608);
        return this.getBoundingBox();
      },
      getBoundingBox: function() {
        var rect = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        return cc._rectApplyAffineTransformIn(rect, this.getNodeToParentTransform());
      },
      cleanup: function() {
        this.stopAllActions();
        this.unscheduleAllCallbacks();
        cc.eventManager.removeListeners(this);
      },
      getChildByTag: function(aTag) {
        var __children = this._children;
        if (null !== __children) for (var i = 0; i < __children.length; i++) {
          var node = __children[i];
          if (node && node.tag === aTag) return node;
        }
        return null;
      },
      getChildByName: function(name) {
        if (!name) {
          cc.log("Invalid name");
          return null;
        }
        var locChildren = this._children;
        for (var i = 0, len = locChildren.length; i < len; i++) if (locChildren[i]._name === name) return locChildren[i];
        return null;
      },
      addChild: function(child, localZOrder, tag) {
        localZOrder = void 0 === localZOrder ? child._localZOrder : localZOrder;
        var name, setTag = false;
        if (void 0 === tag) name = child._name; else if ("string" === typeof tag) {
          name = tag;
          tag = void 0;
        } else if ("number" === typeof tag) {
          setTag = true;
          name = "";
        }
        cc.assertID(child, 1606);
        cc.assertID(null === child._parent, 1605);
        this._addChildHelper(child, localZOrder, tag, name, setTag);
      },
      _addChildHelper: function(child, localZOrder, tag, name, setTag) {
        this._children || (this._children = []);
        this._insertChild(child, localZOrder);
        setTag ? child.setTag(tag) : child.setName(name);
        child.setParent(this);
        child.updateOrderOfArrival();
        if (this._running) {
          child.performRecursive(_ccsg.Node.performType.onEnter);
          this._isTransitionFinished && child.performRecursive(_ccsg.Node.performType.onEnterTransitionDidFinish);
        }
        child._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
        this._cascadeColorEnabled && child._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.colorDirty);
        this._cascadeOpacityEnabled && child._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.opacityDirty);
      },
      removeFromParent: function(cleanup) {
        if (this._parent) {
          void 0 === cleanup && (cleanup = true);
          this._parent.removeChild(this, cleanup);
        }
      },
      removeFromParentAndCleanup: function(cleanup) {
        cc.logID(1607);
        this.removeFromParent(cleanup);
      },
      removeChild: function(child, cleanup) {
        if (0 === this._children.length) return;
        void 0 === cleanup && (cleanup = true);
        this._children.indexOf(child) > -1 && this._detachChild(child, cleanup);
        cc.renderer.childrenOrderDirty = true;
      },
      removeChildByTag: function(tag, cleanup) {
        tag === cc.macro.NODE_TAG_INVALID && cc.logID(1609);
        var child = this.getChildByTag(tag);
        child ? this.removeChild(child, cleanup) : cc.logID(1610, tag);
      },
      removeAllChildrenWithCleanup: function(cleanup) {
        this.removeAllChildren(cleanup);
      },
      removeAllChildren: function(cleanup) {
        var __children = this._children;
        if (null !== __children) {
          void 0 === cleanup && (cleanup = true);
          for (var i = 0; i < __children.length; i++) {
            var node = __children[i];
            if (node) {
              if (this._running) {
                node.performRecursive(_ccsg.Node.performType.onExitTransitionDidStart);
                node.performRecursive(_ccsg.Node.performType.onExit);
              }
              cleanup && node.performRecursive(_ccsg.Node.performType.cleanup);
              node.parent = null;
              node._renderCmd.detachFromParent();
            }
          }
          this._children.length = 0;
          cc.renderer.childrenOrderDirty = true;
        }
      },
      _detachChild: function(child, doCleanup) {
        if (this._running) {
          child.performRecursive(_ccsg.Node.performType.onExitTransitionDidStart);
          child.performRecursive(_ccsg.Node.performType.onExit);
        }
        doCleanup && child.performRecursive(_ccsg.Node.performType.cleanup);
        child.parent = null;
        child._renderCmd.detachFromParent();
        cc.js.array.remove(this._children, child);
      },
      _insertChild: function(child, z) {
        cc.renderer.childrenOrderDirty = this._reorderChildDirty = true;
        this._children.push(child);
        child._setLocalZOrder(z);
      },
      setNodeDirty: function() {
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
      },
      reorderChild: function(child, zOrder) {
        cc.assertID(child, 1617);
        if (-1 === this._children.indexOf(child)) {
          cc.logID(1635);
          return;
        }
        if (zOrder === child.zIndex) return;
        cc.renderer.childrenOrderDirty = this._reorderChildDirty = true;
        child.updateOrderOfArrival();
        child._setLocalZOrder(zOrder);
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.orderDirty);
      },
      sortAllChildren: function() {
        if (this._reorderChildDirty) {
          var _children = this._children;
          var len = _children.length, i, j, tmp;
          for (i = 1; i < len; i++) {
            tmp = _children[i];
            j = i - 1;
            while (j >= 0) {
              if (tmp._localZOrder < _children[j]._localZOrder) _children[j + 1] = _children[j]; else {
                if (!(tmp._localZOrder === _children[j]._localZOrder && tmp._arrivalOrder < _children[j]._arrivalOrder)) break;
                _children[j + 1] = _children[j];
              }
              j--;
            }
            _children[j + 1] = tmp;
          }
          this._reorderChildDirty = false;
        }
      },
      draw: function(ctx) {},
      transformAncestors: function() {
        if (null !== this._parent) {
          this._parent.transformAncestors();
          this._parent.transform();
        }
      },
      onEnter: function() {
        this._isTransitionFinished = false;
        this._running = true;
        this.resume();
      },
      performRecursive: function(callbackType) {
        var nodeCallbackType = _ccsg.Node.performType;
        if (callbackType >= nodeCallbackType.max) return;
        var index = 0;
        var children, child, curr, i, len;
        var stack = _ccsg.Node._performStacks[_ccsg.Node._performing];
        if (!stack) {
          stack = [];
          _ccsg.Node._performStacks.push(stack);
        }
        stack.length = 0;
        _ccsg.Node._performing++;
        curr = stack[0] = this;
        while (curr) {
          children = curr._children;
          if (children && children.length > 0) for (i = 0, len = children.length; i < len; ++i) {
            child = children[i];
            stack.push(child);
          }
          index++;
          curr = stack[index];
        }
        switch (callbackType) {
         case nodeCallbackType.onEnter:
          for (i = stack.length - 1; i >= 0; --i) {
            curr = stack[i];
            stack[i] = null;
            if (!curr) continue;
            curr.onEnter();
          }
          break;

         case nodeCallbackType.onExit:
          for (i = stack.length - 1; i >= 0; --i) {
            curr = stack[i];
            stack[i] = null;
            if (!curr) continue;
            curr.onExit();
          }
          break;

         case nodeCallbackType.onEnterTransitionDidFinish:
          for (i = stack.length - 1; i >= 0; --i) {
            curr = stack[i];
            stack[i] = null;
            if (!curr) continue;
            curr.onEnterTransitionDidFinish();
          }
          break;

         case nodeCallbackType.cleanup:
          for (i = stack.length - 1; i >= 0; --i) {
            curr = stack[i];
            stack[i] = null;
            if (!curr) continue;
            curr.cleanup();
          }
          break;

         case nodeCallbackType.onExitTransitionDidStart:
          for (i = stack.length - 1; i >= 0; --i) {
            curr = stack[i];
            stack[i] = null;
            if (!curr) continue;
            curr.onExitTransitionDidStart();
          }
        }
        _ccsg.Node._performing--;
      },
      onEnterTransitionDidFinish: function() {
        this._isTransitionFinished = true;
      },
      onExitTransitionDidStart: function() {},
      onExit: function() {
        this._running = false;
        this.pause();
      },
      runAction: ActionManagerExist ? function(action) {
        cc.assertID(action, 1618);
        cc.director.getActionManager().addAction(action, this, !this._running);
        return action;
      } : emptyFunc,
      stopAllActions: ActionManagerExist ? function() {
        cc.director.getActionManager().removeAllActionsFromTarget(this);
      } : emptyFunc,
      stopAction: ActionManagerExist ? function(action) {
        cc.director.getActionManager().removeAction(action);
      } : emptyFunc,
      stopActionByTag: ActionManagerExist ? function(tag) {
        if (tag === cc.Action.TAG_INVALID) {
          cc.logID(1612);
          return;
        }
        cc.director.getActionManager().removeActionByTag(tag, this);
      } : emptyFunc,
      getActionByTag: ActionManagerExist ? function(tag) {
        if (tag === cc.Action.TAG_INVALID) {
          cc.logID(1613);
          return null;
        }
        return cc.director.getActionManager().getActionByTag(tag, this);
      } : function() {
        return null;
      },
      getNumberOfRunningActions: ActionManagerExist ? function() {
        return cc.director.getActionManager().getNumberOfRunningActionsInTarget(this);
      } : function() {
        return 0;
      },
      scheduleUpdate: function() {
        this.scheduleUpdateWithPriority(0);
      },
      scheduleUpdateWithPriority: function(priority) {
        this.scheduler.scheduleUpdate(this, priority, !this._running);
      },
      unscheduleUpdate: function() {
        this.scheduler.unscheduleUpdate(this);
      },
      schedule: function(callback, interval, repeat, delay, key) {
        var len = arguments.length;
        if ("function" === typeof callback) if (1 === len) {
          interval = 0;
          repeat = cc.macro.REPEAT_FOREVER;
          delay = 0;
          key = this.__instanceId;
        } else if (2 === len) if ("number" === typeof interval) {
          repeat = cc.macro.REPEAT_FOREVER;
          delay = 0;
          key = this.__instanceId;
        } else {
          key = interval;
          interval = 0;
          repeat = cc.macro.REPEAT_FOREVER;
          delay = 0;
        } else if (3 === len) {
          if ("string" === typeof repeat) {
            key = repeat;
            repeat = cc.macro.REPEAT_FOREVER;
          } else key = this.__instanceId;
          delay = 0;
        } else 4 === len && (key = this.__instanceId); else if (1 === len) {
          interval = 0;
          repeat = cc.macro.REPEAT_FOREVER;
          delay = 0;
        } else if (2 === len) {
          repeat = cc.macro.REPEAT_FOREVER;
          delay = 0;
        }
        cc.assertID(callback, 1619);
        cc.assertID(interval >= 0, 1620);
        interval = interval || 0;
        repeat = isNaN(repeat) ? cc.macro.REPEAT_FOREVER : repeat;
        delay = delay || 0;
        this.scheduler.schedule(callback, this, interval, repeat, delay, !this._running, key);
      },
      scheduleOnce: function(callback, delay, key) {
        void 0 === key && (key = this.__instanceId);
        this.schedule(callback, 0, 0, delay, key);
      },
      unschedule: function(callback_fn) {
        if (!callback_fn) return;
        this.scheduler.unschedule(callback_fn, this);
      },
      unscheduleAllCallbacks: function() {
        this.scheduler.unscheduleAllForTarget(this);
      },
      resumeSchedulerAndActions: function() {
        cc.logID(1614);
        this.resume();
      },
      resume: function() {
        this.scheduler.resumeTarget(this);
        ActionManagerExist && cc.director.getActionManager().resumeTarget(this);
        cc.eventManager.resumeTarget(this);
      },
      pauseSchedulerAndActions: function() {
        cc.logID(1615);
        this.pause();
      },
      pause: function() {
        this.scheduler.pauseTarget(this);
        ActionManagerExist && cc.director.getActionManager().pauseTarget(this);
        cc.eventManager.pauseTarget(this);
      },
      getParentToNodeTransform: function() {
        return this._renderCmd.getParentToNodeTransform();
      },
      parentToNodeTransform: function() {
        return this.getParentToNodeTransform();
      },
      getNodeToWorldTransform: function() {
        var t = this.getNodeToParentTransform();
        for (var p = this._parent; null !== p; p = p.parent) t = cc.affineTransformConcat(t, p.getNodeToParentTransform());
        return t;
      },
      nodeToWorldTransform: function() {
        return this.getNodeToWorldTransform();
      },
      getWorldToNodeTransform: function() {
        return cc.affineTransformInvert(this.getNodeToWorldTransform());
      },
      worldToNodeTransform: function() {
        return this.getWorldToNodeTransform();
      },
      convertToNodeSpace: function(worldPoint) {
        return cc.pointApplyAffineTransform(worldPoint, this.getWorldToNodeTransform());
      },
      convertToWorldSpace: function(nodePoint) {
        nodePoint = nodePoint || cc.v2(0, 0);
        return cc.pointApplyAffineTransform(nodePoint, this.getNodeToWorldTransform());
      },
      convertToNodeSpaceAR: function(worldPoint) {
        return cc.pSub(this.convertToNodeSpace(worldPoint), this._renderCmd.getAnchorPointInPoints());
      },
      convertToWorldSpaceAR: function(nodePoint) {
        nodePoint = nodePoint || cc.v2(0, 0);
        var pt = cc.pAdd(nodePoint, this._renderCmd.getAnchorPointInPoints());
        return this.convertToWorldSpace(pt);
      },
      _convertToWindowSpace: function(nodePoint) {
        var worldPoint = this.convertToWorldSpace(nodePoint);
        return cc.director.convertToUI(worldPoint);
      },
      convertTouchToNodeSpace: function(touch) {
        var point = touch.getLocation();
        return this.convertToNodeSpace(point);
      },
      convertTouchToNodeSpaceAR: function(touch) {
        var point = cc.director.convertToGL(touch.getLocation());
        return this.convertToNodeSpaceAR(point);
      },
      updateTransform: function() {
        var children = this._children, node;
        for (var i = 0; i < children.length; i++) {
          var node = children[i];
          node && node.updateTransform();
        }
      },
      retain: function() {},
      release: function() {},
      visit: function(parent) {
        var cmd = this._renderCmd, parentCmd = parent ? parent._renderCmd : null;
        if (!this._visible) {
          cmd._propagateFlagsDown(parentCmd);
          return;
        }
        var renderer = cc.renderer;
        cmd.visit(parentCmd);
        var i, children = this._children, len = children.length, child;
        if (len > 0) {
          this._reorderChildDirty && this.sortAllChildren();
          for (i = 0; i < len; i++) {
            child = children[i];
            if (!(child._localZOrder < 0)) break;
            child.visit(this);
          }
          renderer.pushRenderCommand(cmd);
          for (;i < len; i++) children[i].visit(this);
        } else renderer.pushRenderCommand(cmd);
        cmd._dirtyFlag = 0;
      },
      transform: function(parentCmd, recursive) {
        this._renderCmd.transform(parentCmd, recursive);
      },
      nodeToParentTransform: function() {
        return this.getNodeToParentTransform();
      },
      getNodeToParentTransform: function(ancestor) {
        var t = this._renderCmd.getNodeToParentTransform();
        if (ancestor) {
          var T = {
            a: t.a,
            b: t.b,
            c: t.c,
            d: t.d,
            tx: t.tx,
            ty: t.ty
          };
          for (var p = this._parent; null != p && p != ancestor; p = p.getParent()) cc.affineTransformConcatIn(T, p.getNodeToParentTransform());
          return T;
        }
        return t;
      },
      getNodeToParentAffineTransform: function(ancestor) {
        return this.getNodeToParentTransform(ancestor);
      },
      getShaderProgram: function() {
        return this._renderCmd.getShaderProgram();
      },
      setShaderProgram: function(newShaderProgram) {
        this._renderCmd.setShaderProgram(newShaderProgram);
      },
      getGLServerState: function() {
        return 0;
      },
      setGLServerState: function(state) {},
      getBoundingBoxToWorld: function() {
        var rect = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        var trans = this.getNodeToWorldTransform();
        cc._rectApplyAffineTransformIn(rect, trans);
        if (!this._children) return rect;
        var locChildren = this._children;
        for (var i = 0; i < locChildren.length; i++) {
          var child = locChildren[i];
          if (child && child._visible) {
            var childRect = child._getBoundingBoxToCurrentNode(trans);
            childRect && (rect = cc.rectUnion(rect, childRect));
          }
        }
        return rect;
      },
      _getBoundingBoxToCurrentNode: function(parentTransform) {
        var rect = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        var trans = void 0 === parentTransform ? this.getNodeToParentTransform() : cc.affineTransformConcat(this.getNodeToParentTransform(), parentTransform);
        cc._rectApplyAffineTransformIn(rect, trans);
        if (!this._children) return rect;
        var locChildren = this._children;
        for (var i = 0; i < locChildren.length; i++) {
          var child = locChildren[i];
          if (child && child._visible) {
            var childRect = child._getBoundingBoxToCurrentNode(trans);
            childRect && (rect = cc.rectUnion(rect, childRect));
          }
        }
        return rect;
      },
      getOpacity: function() {
        return this._realOpacity;
      },
      getDisplayedOpacity: function() {
        return this._renderCmd.getDisplayedOpacity();
      },
      setOpacity: function(opacity) {
        this._realOpacity = opacity;
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.opacityDirty);
      },
      updateDisplayedOpacity: function(parentOpacity) {
        this._renderCmd._updateDisplayOpacity(parentOpacity);
      },
      isCascadeOpacityEnabled: function() {
        return this._cascadeOpacityEnabled;
      },
      setCascadeOpacityEnabled: function(cascadeOpacityEnabled) {
        if (this._cascadeOpacityEnabled === cascadeOpacityEnabled) return;
        this._cascadeOpacityEnabled = cascadeOpacityEnabled;
        this._renderCmd.setCascadeOpacityEnabledDirty();
      },
      getColor: function() {
        var locRealColor = this._realColor;
        return cc.color(locRealColor.r, locRealColor.g, locRealColor.b, locRealColor.a);
      },
      getDisplayedColor: function() {
        return this._renderCmd.getDisplayedColor();
      },
      setColor: function(color) {
        var locRealColor = this._realColor;
        locRealColor.r = color.r;
        locRealColor.g = color.g;
        locRealColor.b = color.b;
        this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.colorDirty);
      },
      updateDisplayedColor: function(parentColor) {
        this._renderCmd._updateDisplayColor(parentColor);
      },
      isCascadeColorEnabled: function() {
        return this._cascadeColorEnabled;
      },
      setCascadeColorEnabled: function(cascadeColorEnabled) {
        if (this._cascadeColorEnabled === cascadeColorEnabled) return;
        this._cascadeColorEnabled = cascadeColorEnabled;
        this._renderCmd.setCascadeColorEnabledDirty();
      },
      setOpacityModifyRGB: function(opacityValue) {},
      isOpacityModifyRGB: function() {
        return false;
      },
      _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new _ccsg.Node.CanvasRenderCmd(this) : new _ccsg.Node.WebGLRenderCmd(this);
      }
    });
    _ccsg.Node.extend = cc._Class.extend;
    _ccsg.Node.prototype.ctor = _ccsg.Node;
    _ccsg.Node.performType = {
      onEnter: 1,
      onExit: 2,
      cleanup: 3,
      onEnterTransitionDidFinish: 4,
      onExitTransitionDidStart: 5,
      max: 6
    };
    _ccsg.Node._performStacks = [ [] ];
    _ccsg.Node._performing = 0;
    var SameNameGetSets = [ "skewX", "skewY", "vertexZ", "rotation", "rotationX", "rotationY", "scale", "scaleX", "scaleY", "children", "childrenCount", "parent", "scheduler", "shaderProgram", "opacity", "color" ];
    var DiffNameGetSets = {
      x: [ "getPositionX", "setPositionX" ],
      y: [ "getPositionY", "setPositionY" ],
      width: [ "_getWidth", "_setWidth" ],
      height: [ "_getHeight", "_setHeight" ],
      anchorX: [ "_getAnchorX", "_setAnchorX" ],
      anchorY: [ "_getAnchorY", "_setAnchorY" ],
      zIndex: [ "getLocalZOrder", "setLocalZOrder" ],
      visible: [ "isVisible", "setVisible" ],
      running: [ "isRunning" ],
      ignoreAnchor: [ "isIgnoreAnchorPointForPosition", "setIgnoreAnchorPointForPosition" ],
      opacityModifyRGB: [ "isOpacityModifyRGB", "setOpacityModifyRGB" ],
      cascadeOpacity: [ "isCascadeOpacityEnabled", "setCascadeOpacityEnabled" ],
      cascadeColor: [ "isCascadeColorEnabled", "setCascadeColorEnabled" ]
    };
    Misc.propertyDefine(_ccsg.Node, SameNameGetSets, DiffNameGetSets);
  }), {
    "../utils/misc": 225
  } ],
  56: [ (function(require, module, exports) {
    cc.CustomRenderCmd = function(target, func) {
      this._needDraw = true;
      this._target = target;
      this._callback = func;
    };
    cc.CustomRenderCmd.prototype.rendering = function(ctx, scaleX, scaleY) {
      if (!this._callback) return;
      this._callback.call(this._target, ctx, scaleX, scaleY);
    };
    var dirtyFlags = _ccsg.Node._dirtyFlags = {
      transformDirty: 1,
      visibleDirty: 2,
      colorDirty: 4,
      opacityDirty: 8,
      cacheDirty: 16,
      orderDirty: 32,
      textDirty: 64,
      gradientDirty: 128,
      textureDirty: 256,
      contentDirty: 512,
      cullingDirty: 1024,
      COUNT: 9
    };
    cc.js.get(dirtyFlags, "all", (function() {
      var count = dirtyFlags.COUNT;
      return (1 << count) - 1;
    }), false);
    _ccsg.Node._requestDirtyFlag = function(key) {
      cc.assertID(!dirtyFlags[key], 1622, key);
      var count = dirtyFlags.COUNT;
      var value = 1 << count;
      dirtyFlags[key] = value;
      dirtyFlags.COUNT++;
      return value;
    };
    var ONE_DEGREE = Math.PI / 180;
    function walkChildTree(root, funcName) {
      var index = 1;
      var children, child, curr, parentCmd, i, len;
      var stack = _ccsg.Node._performStacks[_ccsg.Node._performing];
      if (!stack) {
        stack = [];
        _ccsg.Node._performStacks.push(stack);
      }
      stack.length = 0;
      _ccsg.Node._performing++;
      stack[0] = root;
      var childChildren;
      while (index) {
        index--;
        curr = stack[index];
        stack[index] = null;
        if (!curr) continue;
        children = curr._children;
        if (children && children.length > 0) {
          parentCmd = curr._renderCmd;
          for (i = 0, len = children.length; i < len; ++i) {
            child = children[i];
            stack[index] = child;
            index++;
            child._renderCmd[funcName](parentCmd);
          }
        }
      }
      _ccsg.Node._performing--;
    }
    _ccsg.Node.RenderCmd = function(renderable) {
      this._node = renderable;
      this._anchorPointInPoints = new cc.Vec2(0, 0);
      this._needDraw = false;
      this._dirtyFlag = 1;
      this._curLevel = -1;
      this._cameraFlag = 0;
      this._displayedColor = new cc.Color(255, 255, 255, 255);
      this._displayedOpacity = 255;
      this._cascadeColorEnabledDirty = false;
      this._cascadeOpacityEnabledDirty = false;
      this._transform = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
      };
      this._worldTransform = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
      };
      this._inverse = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
      };
      this._transformUpdated = false;
      cc.renderer.pushDirtyNode(this);
    };
    _ccsg.Node.RenderCmd.prototype = {
      constructor: _ccsg.Node.RenderCmd,
      _ctor: _ccsg.Node.RenderCmd,
      getAnchorPointInPoints: function() {
        return cc.p(this._anchorPointInPoints);
      },
      getDisplayedColor: function() {
        var tmpColor = this._displayedColor;
        return cc.color(tmpColor.r, tmpColor.g, tmpColor.b, tmpColor.a);
      },
      getDisplayedOpacity: function() {
        return this._displayedOpacity;
      },
      setCascadeColorEnabledDirty: function() {
        this._cascadeColorEnabledDirty = true;
        this.setDirtyFlag(dirtyFlags.colorDirty);
      },
      setCascadeOpacityEnabledDirty: function() {
        this._cascadeOpacityEnabledDirty = true;
        this.setDirtyFlag(dirtyFlags.opacityDirty);
      },
      getParentToNodeTransform: function() {
        this._dirtyFlag & dirtyFlags.transformDirty && cc.affineTransformInvertOut(this.getNodeToParentTransform(), this._inverse);
        return this._inverse;
      },
      detachFromParent: function() {},
      _updateAnchorPointInPoint: function() {
        var locAPP = this._anchorPointInPoints, locSize = this._node._contentSize, locAnchorPoint = this._node._anchorPoint;
        locAPP.x = locSize.width * locAnchorPoint.x;
        locAPP.y = locSize.height * locAnchorPoint.y;
        this.setDirtyFlag(dirtyFlags.transformDirty);
      },
      setDirtyFlag: function(dirtyFlag) {
        0 === this._dirtyFlag && 0 !== dirtyFlag && cc.renderer.pushDirtyNode(this);
        this._dirtyFlag |= dirtyFlag;
      },
      getParentRenderCmd: function() {
        if (this._node && this._node._parent && this._node._parent._renderCmd) return this._node._parent._renderCmd;
        return null;
      },
      updateTransform: function(parentCmd, recursive) {
        var node = this._node, pt = parentCmd ? parentCmd._worldTransform : null, t = this._transform, wt = this._worldTransform;
        if (!this._transformUpdated) {
          var hasRotation = node._rotationX || node._rotationY;
          var hasSkew = node._skewX || node._skewY;
          var sx = node._scaleX, sy = node._scaleY;
          var appX = this._anchorPointInPoints.x, appY = this._anchorPointInPoints.y;
          var a = 1, b = 0, c = 0, d = 1;
          if (hasRotation || hasSkew) {
            t.tx = node._position.x;
            t.ty = node._position.y;
            if (hasRotation) {
              var rotationRadiansX = node._rotationX * ONE_DEGREE;
              c = Math.sin(rotationRadiansX);
              d = Math.cos(rotationRadiansX);
              if (node._rotationY === node._rotationX) {
                a = d;
                b = -c;
              } else {
                var rotationRadiansY = node._rotationY * ONE_DEGREE;
                a = Math.cos(rotationRadiansY);
                b = -Math.sin(rotationRadiansY);
              }
            }
            t.a = a *= sx;
            t.b = b *= sx;
            t.c = c *= sy;
            t.d = d *= sy;
            if (hasSkew) {
              var skx = Math.tan(node._skewX * ONE_DEGREE);
              var sky = Math.tan(node._skewY * ONE_DEGREE);
              Infinity === skx && (skx = 99999999);
              Infinity === sky && (sky = 99999999);
              t.a = a + c * sky;
              t.b = b + d * sky;
              t.c = c + a * skx;
              t.d = d + b * skx;
            }
            if (appX || appY) {
              t.tx -= t.a * appX + t.c * appY;
              t.ty -= t.b * appX + t.d * appY;
              if (node._ignoreAnchorPointForPosition) {
                t.tx += appX;
                t.ty += appY;
              }
            }
          } else {
            t.a = sx;
            t.b = 0;
            t.c = 0;
            t.d = sy;
            t.tx = node._position.x;
            t.ty = node._position.y;
            if (appX || appY) {
              t.tx -= t.a * appX;
              t.ty -= t.d * appY;
              if (node._ignoreAnchorPointForPosition) {
                t.tx += appX;
                t.ty += appY;
              }
            }
          }
        }
        if (pt) {
          wt.a = t.a * pt.a + t.b * pt.c;
          wt.b = t.a * pt.b + t.b * pt.d;
          wt.c = t.c * pt.a + t.d * pt.c;
          wt.d = t.c * pt.b + t.d * pt.d;
          wt.tx = t.tx * pt.a + t.ty * pt.c + pt.tx;
          wt.ty = t.tx * pt.b + t.ty * pt.d + pt.ty;
        } else {
          wt.a = t.a;
          wt.b = t.b;
          wt.c = t.c;
          wt.d = t.d;
          wt.tx = t.tx;
          wt.ty = t.ty;
        }
      },
      transform: function(parentCmd, recursive) {
        this.updateTransform(parentCmd);
        if (this._currentRegion) {
          this._updateCurrentRegions();
          this._notifyRegionStatus && this._notifyRegionStatus(_ccsg.Node.CanvasRenderCmd.RegionStatus.DirtyDouble);
        }
        if (cc.macro.ENABLE_CULLING) {
          this._updateCameraFlag(parentCmd);
          this._doCulling && this._doCulling();
        } else this._doCulling && (this._needDraw = true);
        recursive && walkChildTree(this._node, "transform");
      },
      _updateCameraFlag: function(parentCmd) {
        var Camera = cc.Camera;
        cc._renderType === cc.game.RENDER_TYPE_WEBGL && Camera && parentCmd && this._cameraFlag != Camera.flags.InCamera && (this._cameraFlag = parentCmd._cameraFlag > 0 ? Camera.flags.ParentInCamera : 0);
      },
      culling: function(parentCmd, recursive) {
        if (!cc.macro.ENABLE_CULLING) {
          this._doCulling && (this._needDraw = true);
          return;
        }
        this._updateCameraFlag(parentCmd);
        this._doCulling && this._doCulling();
        recursive && walkChildTree(this._node, "culling");
      },
      getNodeToParentTransform: function() {
        this._dirtyFlag & dirtyFlags.transformDirty && this.transform();
        return this._transform;
      },
      setNodeToParentTransform: function(transform) {
        if (transform) {
          this._transform = transform;
          this._transformUpdated = true;
        } else this._transformUpdated = false;
        this.setDirtyFlag(dirtyFlags.transformDirty);
      },
      _propagateFlagsDown: function(parentCmd) {
        if (!parentCmd) return;
        var locFlag = this._dirtyFlag;
        var parentNode = parentCmd._node;
        var parentFlag = parentCmd._dirtyFlag;
        parentNode._cascadeColorEnabled && parentFlag & dirtyFlags.colorDirty && (locFlag |= dirtyFlags.colorDirty);
        parentNode._cascadeOpacityEnabled && parentFlag & dirtyFlags.opacityDirty && (locFlag |= dirtyFlags.opacityDirty);
        parentFlag & dirtyFlags.transformDirty && (locFlag |= dirtyFlags.transformDirty);
        parentFlag & dirtyFlags.cullingDirty && (locFlag |= dirtyFlags.cullingDirty);
        this._dirtyFlag = locFlag;
      },
      visit: function(parentCmd) {
        var node = this._node, renderer = cc.renderer;
        parentCmd && (this._curLevel = parentCmd._curLevel + 1);
        this._propagateFlagsDown(parentCmd);
        if (isNaN(node._customZ)) {
          node._vertexZ = renderer.assignedZ;
          renderer.assignedZ += renderer.assignedZStep;
        }
        this._syncStatus(parentCmd);
      },
      _updateDisplayColor: function(parentColor) {
        var node = this._node;
        var locDispColor = this._displayedColor, locRealColor = node._realColor;
        var i, len, selChildren, item;
        this._notifyRegionStatus && this._notifyRegionStatus(_ccsg.Node.CanvasRenderCmd.RegionStatus.Dirty);
        if (this._cascadeColorEnabledDirty && !node._cascadeColorEnabled) {
          locDispColor.r = locRealColor.r;
          locDispColor.g = locRealColor.g;
          locDispColor.b = locRealColor.b;
          var whiteColor = new cc.Color(255, 255, 255, 255);
          selChildren = node._children;
          for (i = 0, len = selChildren.length; i < len; i++) {
            item = selChildren[i];
            item && item._renderCmd && item._renderCmd._updateDisplayColor(whiteColor);
          }
          this._cascadeColorEnabledDirty = false;
        } else {
          if (void 0 === parentColor) {
            var locParent = node._parent;
            parentColor = locParent && locParent._cascadeColorEnabled ? locParent.getDisplayedColor() : cc.Color.WHITE;
          }
          locDispColor.r = 0 | locRealColor.r * parentColor.r / 255;
          locDispColor.g = 0 | locRealColor.g * parentColor.g / 255;
          locDispColor.b = 0 | locRealColor.b * parentColor.b / 255;
          if (node._cascadeColorEnabled) {
            selChildren = node._children;
            for (i = 0, len = selChildren.length; i < len; i++) {
              item = selChildren[i];
              if (item && item._renderCmd) {
                item._renderCmd._updateDisplayColor(locDispColor);
                item._renderCmd._updateColor();
              }
            }
          }
        }
        this._dirtyFlag &= ~dirtyFlags.colorDirty;
      },
      _updateDisplayOpacity: function(parentOpacity) {
        var node = this._node;
        var i, len, selChildren, item;
        this._notifyRegionStatus && this._notifyRegionStatus(_ccsg.Node.CanvasRenderCmd.RegionStatus.Dirty);
        if (this._cascadeOpacityEnabledDirty && !node._cascadeOpacityEnabled) {
          this._displayedOpacity = node._realOpacity;
          selChildren = node._children;
          for (i = 0, len = selChildren.length; i < len; i++) {
            item = selChildren[i];
            item && item._renderCmd && item._renderCmd._updateDisplayOpacity(255);
          }
          this._cascadeOpacityEnabledDirty = false;
        } else {
          if (void 0 === parentOpacity) {
            var locParent = node._parent;
            parentOpacity = 255;
            locParent && locParent._cascadeOpacityEnabled && (parentOpacity = locParent.getDisplayedOpacity());
          }
          this._displayedOpacity = node._realOpacity * parentOpacity / 255;
          if (node._cascadeOpacityEnabled) {
            selChildren = node._children;
            for (i = 0, len = selChildren.length; i < len; i++) {
              item = selChildren[i];
              if (item && item._renderCmd) {
                item._renderCmd._updateDisplayOpacity(this._displayedOpacity);
                item._renderCmd._updateColor();
              }
            }
          }
        }
        this._dirtyFlag &= ~dirtyFlags.opacityDirty;
      },
      _syncDisplayColor: function(parentColor) {
        var node = this._node, locDispColor = this._displayedColor, locRealColor = node._realColor;
        if (void 0 === parentColor) {
          var locParent = node._parent;
          parentColor = locParent && locParent._cascadeColorEnabled ? locParent.getDisplayedColor() : cc.Color.WHITE;
        }
        locDispColor.r = 0 | locRealColor.r * parentColor.r / 255;
        locDispColor.g = 0 | locRealColor.g * parentColor.g / 255;
        locDispColor.b = 0 | locRealColor.b * parentColor.b / 255;
      },
      _syncDisplayOpacity: function(parentOpacity) {
        var node = this._node;
        if (void 0 === parentOpacity) {
          var locParent = node._parent;
          parentOpacity = 255;
          locParent && locParent._cascadeOpacityEnabled && (parentOpacity = locParent.getDisplayedOpacity());
        }
        this._displayedOpacity = node._realOpacity * parentOpacity / 255;
      },
      _updateColor: function() {},
      updateStatus: function() {
        var locFlag = this._dirtyFlag;
        var colorDirty = locFlag & dirtyFlags.colorDirty, opacityDirty = locFlag & dirtyFlags.opacityDirty;
        if (locFlag & dirtyFlags.contentDirty) {
          this._notifyRegionStatus && this._notifyRegionStatus(_ccsg.Node.CanvasRenderCmd.RegionStatus.Dirty);
          this._dirtyFlag &= ~dirtyFlags.contentDirty;
        }
        colorDirty && this._updateDisplayColor();
        opacityDirty && this._updateDisplayOpacity();
        (colorDirty || opacityDirty) && this._updateColor();
        if (locFlag & dirtyFlags.transformDirty) {
          var parentCmd = this.getParentRenderCmd();
          this.transform(parentCmd, true);
          this._dirtyFlag &= ~dirtyFlags.transformDirty;
          this._dirtyFlag &= ~dirtyFlags.cullingDirty;
        } else if (locFlag & dirtyFlags.cullingDirty) {
          this.culling(parentCmd, true);
          this._dirtyFlag &= ~dirtyFlags.cullingDirty;
        }
      },
      _syncStatus: function(parentCmd) {
        var locFlag = this._dirtyFlag;
        var colorDirty = locFlag & dirtyFlags.colorDirty, opacityDirty = locFlag & dirtyFlags.opacityDirty;
        colorDirty && this._syncDisplayColor();
        opacityDirty && this._syncDisplayOpacity();
        (colorDirty || opacityDirty) && this._updateColor();
        locFlag & dirtyFlags.transformDirty ? this.transform(parentCmd) : locFlag & dirtyFlags.cullingDirty && this.culling(parentCmd);
      }
    };
    _ccsg.Node.RenderCmd.prototype.originUpdateTransform = _ccsg.Node.RenderCmd.prototype.updateTransform;
    _ccsg.Node.RenderCmd.prototype.originTransform = _ccsg.Node.RenderCmd.prototype.transform;
    _ccsg.Node.RenderCmd.prototype.originCulling = _ccsg.Node.RenderCmd.prototype.culling;
    _ccsg.Node.RenderCmd.prototype.originUpdateStatus = _ccsg.Node.RenderCmd.prototype.updateStatus;
    _ccsg.Node.RenderCmd.prototype._originSyncStatus = _ccsg.Node.RenderCmd.prototype._syncStatus;
  }), {} ],
  57: [ (function(require, module, exports) {
    _ccsg.Node.CanvasRenderCmd = function(renderable) {
      this._ctor(renderable);
      this._currentRegion = new cc.Region();
      this._oldRegion = new cc.Region();
      this._regionFlag = 0;
    };
    _ccsg.Node.CanvasRenderCmd.RegionStatus = {
      NotDirty: 0,
      Dirty: 1,
      DirtyDouble: 2
    };
    var proto = _ccsg.Node.CanvasRenderCmd.prototype = Object.create(_ccsg.Node.RenderCmd.prototype);
    proto.constructor = _ccsg.Node.CanvasRenderCmd;
    proto._rootCtor = _ccsg.Node.CanvasRenderCmd;
    proto._notifyRegionStatus = function(status) {
      this._needDraw && this._regionFlag < status && (this._regionFlag = status);
    };
    var localBB = new cc.Rect();
    proto.getLocalBB = function() {
      var node = this._node;
      localBB.x = localBB.y = 0;
      localBB.width = node._contentSize.width;
      localBB.height = node._contentSize.height;
      return localBB;
    };
    proto._updateCurrentRegions = function() {
      var temp = this._currentRegion;
      this._currentRegion = this._oldRegion;
      this._oldRegion = temp;
      _ccsg.Node.CanvasRenderCmd.RegionStatus.DirtyDouble !== this._regionFlag || this._currentRegion.isEmpty() || this._oldRegion.union(this._currentRegion);
      this._currentRegion.updateRegion(this.getLocalBB(), this._worldTransform);
    };
    proto.detachFromParent = function() {
      var selChildren = this._node._children, item;
      for (var i = 0, len = selChildren.length; i < len; i++) {
        item = selChildren[i];
        item && item._renderCmd && item._renderCmd.detachFromParent();
      }
    };
    proto.setShaderProgram = function(shaderProgram) {};
    proto.getShaderProgram = function() {
      return null;
    };
    _ccsg.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc = function(blendFunc) {
      return blendFunc ? blendFunc.src === cc.macro.SRC_ALPHA && blendFunc.dst === cc.macro.ONE || blendFunc.src === cc.macro.ONE && blendFunc.dst === cc.macro.ONE ? "lighter" : blendFunc.src === cc.macro.ZERO && blendFunc.dst === cc.macro.SRC_ALPHA ? "destination-in" : blendFunc.src === cc.macro.ZERO && blendFunc.dst === cc.macro.ONE_MINUS_SRC_ALPHA ? "destination-out" : "source-over" : "source-over";
    };
  }), {} ],
  58: [ (function(require, module, exports) {
    _ccsg.Node.WebGLRenderCmd = function(renderable) {
      this._ctor(renderable);
      this._shaderProgram = null;
    };
    var proto = _ccsg.Node.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.RenderCmd.prototype);
    proto.constructor = _ccsg.Node.WebGLRenderCmd;
    proto._rootCtor = _ccsg.Node.WebGLRenderCmd;
    proto._updateColor = function() {};
    proto.setShaderProgram = function(shaderProgram) {
      this._shaderProgram = shaderProgram;
    };
    proto.getShaderProgram = function() {
      return this._shaderProgram;
    };
  }), {} ],
  59: [ (function(require, module, exports) {
    var TOP = 1;
    var MID = 2;
    var BOT = 4;
    var LEFT = 8;
    var CENTER = 16;
    var RIGHT = 32;
    var HORIZONTAL = LEFT | CENTER | RIGHT;
    var VERTICAL = TOP | MID | BOT;
    function getReadonlyNodeSize(parent) {
      return parent instanceof cc.Scene ? cc.visibleRect : !parent._sizeProvider || parent._sizeProvider instanceof _ccsg.Node ? parent._contentSize : parent.getContentSize();
    }
    function computeInverseTransForTarget(widgetNode, target, out_inverseTranslate, out_inverseScale) {
      var scaleX = widgetNode._parent._scaleX;
      var scaleY = widgetNode._parent._scaleY;
      var translateX = 0;
      var translateY = 0;
      for (var node = widgetNode._parent; ;) {
        var pos = node._position;
        translateX += pos.x;
        translateY += pos.y;
        node = node._parent;
        if (!node) {
          out_inverseTranslate.x = out_inverseTranslate.y = 0;
          out_inverseScale.x = out_inverseScale.y = 1;
          return;
        }
        if (node === target) break;
        var sx = node._scaleX;
        var sy = node._scaleY;
        translateX *= sx;
        translateY *= sy;
        scaleX *= sx;
        scaleY *= sy;
      }
      out_inverseScale.x = 0 !== scaleX ? 1 / scaleX : 1;
      out_inverseScale.y = 0 !== scaleY ? 1 / scaleY : 1;
      out_inverseTranslate.x = -translateX;
      out_inverseTranslate.y = -translateY;
    }
    var tInverseTranslate = cc.Vec2.ZERO;
    var tInverseScale = cc.Vec2.ONE;
    function align(node, widget) {
      var hasTarget = widget._target;
      var target;
      var inverseTranslate, inverseScale;
      if (hasTarget) {
        target = hasTarget;
        inverseTranslate = tInverseTranslate;
        inverseScale = tInverseScale;
        computeInverseTransForTarget(node, target, inverseTranslate, inverseScale);
      } else target = node._parent;
      var targetSize = getReadonlyNodeSize(target);
      var targetAnchor = target._anchorPoint;
      var isRoot = (true, target instanceof cc.Scene);
      var x = node._position.x, y = node._position.y;
      var anchor = node._anchorPoint;
      if (widget._alignFlags & HORIZONTAL) {
        var localLeft, localRight, targetWidth = targetSize.width;
        if (isRoot) {
          localLeft = cc.visibleRect.left.x;
          localRight = cc.visibleRect.right.x;
        } else {
          localLeft = -targetAnchor.x * targetWidth;
          localRight = localLeft + targetWidth;
        }
        localLeft += widget._isAbsLeft ? widget._left : widget._left * targetWidth;
        localRight -= widget._isAbsRight ? widget._right : widget._right * targetWidth;
        if (hasTarget) {
          localLeft += inverseTranslate.x;
          localLeft *= inverseScale.x;
          localRight += inverseTranslate.x;
          localRight *= inverseScale.x;
        }
        var width, anchorX = anchor.x, scaleX = node._scaleX;
        if (scaleX < 0) {
          anchorX = 1 - anchorX;
          scaleX = -scaleX;
        }
        if (widget.isStretchWidth) {
          width = localRight - localLeft;
          0 !== scaleX && (node.width = width / scaleX);
          x = localLeft + anchorX * width;
        } else {
          width = node.width * scaleX;
          if (widget.isAlignHorizontalCenter) {
            var localHorizontalCenter = widget._isAbsHorizontalCenter ? widget._horizontalCenter : widget._horizontalCenter * targetWidth;
            var targetCenter = (.5 - targetAnchor.x) * targetSize.width;
            if (hasTarget) {
              localHorizontalCenter *= inverseScale.x;
              targetCenter += inverseTranslate.x;
              targetCenter *= inverseScale.x;
            }
            x = targetCenter + (anchorX - .5) * width + localHorizontalCenter;
          } else x = widget.isAlignLeft ? localLeft + anchorX * width : localRight + (anchorX - 1) * width;
        }
      }
      if (widget._alignFlags & VERTICAL) {
        var localTop, localBottom, targetHeight = targetSize.height;
        if (isRoot) {
          localBottom = cc.visibleRect.bottom.y;
          localTop = cc.visibleRect.top.y;
        } else {
          localBottom = -targetAnchor.y * targetHeight;
          localTop = localBottom + targetHeight;
        }
        localBottom += widget._isAbsBottom ? widget._bottom : widget._bottom * targetHeight;
        localTop -= widget._isAbsTop ? widget._top : widget._top * targetHeight;
        if (hasTarget) {
          localBottom += inverseTranslate.y;
          localBottom *= inverseScale.y;
          localTop += inverseTranslate.y;
          localTop *= inverseScale.y;
        }
        var height, anchorY = anchor.y, scaleY = node._scaleY;
        if (scaleY < 0) {
          anchorY = 1 - anchorY;
          scaleY = -scaleY;
        }
        if (widget.isStretchHeight) {
          height = localTop - localBottom;
          0 !== scaleY && (node.height = height / scaleY);
          y = localBottom + anchorY * height;
        } else {
          height = node.height * scaleY;
          if (widget.isAlignVerticalCenter) {
            var localVerticalCenter = widget._isAbsVerticalCenter ? widget._verticalCenter : widget._verticalCenter * targetHeight;
            var targetMiddle = (.5 - targetAnchor.y) * targetSize.height;
            if (hasTarget) {
              localVerticalCenter *= inverseScale.y;
              targetMiddle += inverseTranslate.y;
              targetMiddle *= inverseScale.y;
            }
            y = targetMiddle + (anchorY - .5) * height + localVerticalCenter;
          } else y = widget.isAlignBottom ? localBottom + anchorY * height : localTop + (anchorY - 1) * height;
        }
      }
      node.setPosition(x, y);
    }
    function visitNode(node) {
      var widget = node._widget;
      if (widget) {
        true;
        var target = widget._target;
        if (target) {
          var isParent = node !== target && node.isChildOf(target);
          if (!isParent) {
            cc.errorID(6500);
            widget._target = null;
          }
        }
        align(node, widget);
        true, widget.isAlignOnce ? widget.enabled = false : activeWidgets.push(widget);
      }
      var children = node._children;
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        child._active && visitNode(child);
      }
    }
    var animationState;
    false;
    function refreshScene() {
      var nowPreviewing;
      false;
      var scene = cc.director.getScene();
      if (scene) {
        widgetManager.isAligning = true;
        if (widgetManager._nodesOrderDirty) {
          activeWidgets.length = 0;
          visitNode(scene);
          widgetManager._nodesOrderDirty = false;
        } else {
          var i, widget, iterator = widgetManager._activeWidgetsIterator;
          var editingNode;
          var node;
          false;
          for (iterator.i = 0; iterator.i < activeWidgets.length; ++iterator.i) {
            widget = activeWidgets[iterator.i];
            align(widget.node, widget);
          }
        }
        widgetManager.isAligning = false;
      }
      false;
    }
    var adjustWidgetToAllowMovingInEditor = false;
    var adjustWidgetToAllowResizingInEditor = false;
    var activeWidgets = [];
    function updateAlignment(node) {
      var parent = node._parent;
      cc.Node.isNode(parent) && updateAlignment(parent);
      var widget = node._widget || node.getComponent(cc.Widget);
      widget && align(node, widget);
    }
    var widgetManager = cc._widgetManager = module.exports = {
      _AlignFlags: {
        TOP: TOP,
        MID: MID,
        BOT: BOT,
        LEFT: LEFT,
        CENTER: CENTER,
        RIGHT: RIGHT
      },
      isAligning: false,
      _nodesOrderDirty: false,
      _activeWidgetsIterator: new cc.js.array.MutableForwardIterator(activeWidgets),
      init: function(director) {
        director.on(cc.Director.EVENT_BEFORE_VISIT, refreshScene);
      },
      add: function(widget) {
        widget.node._widget = widget;
        this._nodesOrderDirty = true;
        false;
      },
      remove: function(widget) {
        widget.node._widget = null;
        this._activeWidgetsIterator.remove(widget);
        false;
      },
      updateAlignment: updateAlignment
    };
    false;
  }), {} ],
  60: [ (function(require, module, exports) {
    var cullingDirtyFlag;
    true;
    cullingDirtyFlag = _ccsg.Node._dirtyFlags.cullingDirty;
    require("./CCSGCameraNode");
    var Camera = cc.Class({
      name: "cc.Camera",
      extends: cc._RendererUnderSG,
      ctor: function() {
        this.viewMatrix = cc.affineTransformMake();
        this.invertViewMatrix = cc.affineTransformMake();
        this._lastViewMatrix = cc.affineTransformMake();
        this._sgTarges = [];
        this._checkedTimes = 0;
        this.visibleRect = {
          left: cc.v2(),
          right: cc.v2(),
          top: cc.v2(),
          bottom: cc.v2()
        };
        this.viewPort = cc.rect();
      },
      editor: false,
      properties: {
        _targets: {
          default: [],
          type: cc.Node,
          visible: true
        },
        zoomRatio: 1
      },
      statics: {
        main: null
      },
      _createSgNode: function() {
        if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
          cc.errorID(8301);
          var sgNode = new _ccsg.Node();
          sgNode.setTransform = sgNode.addTarget = sgNode.removeTarget = function() {};
          return sgNode;
        }
        return new _ccsg.CameraNode();
      },
      _initSgNode: function() {
        this._sgNode.setContentSize(this.node.getContentSize(true));
      },
      _addSgTargetInSg: function(target) {
        var sgNode;
        target instanceof cc.Node ? sgNode = target._sgNode : target instanceof _ccsg.Node && (sgNode = target);
        if (!sgNode || sgNode._cameraInfo) return;
        sgNode._cameraInfo = {
          touched: this._checkedTimes
        };
        this._sgNode.addTarget(sgNode);
        this._sgTarges.push(sgNode);
        true;
        var cmd = sgNode._renderCmd;
        cmd.setDirtyFlag(cullingDirtyFlag);
        cmd._cameraFlag = Camera.flags.InCamera;
        cc.renderer.childrenOrderDirty = true;
      },
      _removeTargetInSg: function(target) {
        var sgNode;
        target instanceof cc.Node ? sgNode = target._sgNode : target instanceof _ccsg.Node && (sgNode = target);
        if (!sgNode || !sgNode._cameraInfo) return;
        this._sgNode.removeTarget(sgNode);
        delete sgNode._cameraInfo;
        cc.js.array.remove(this._sgTarges, sgNode);
        true;
        var cmd = sgNode._renderCmd;
        cmd.setDirtyFlag(cullingDirtyFlag);
        cmd._cameraFlag = 0;
        cc.renderer.childrenOrderDirty = true;
      },
      onEnable: function() {
        if (Camera.main) {
          cc.errorID(8300);
          return;
        }
        Camera.main = this;
        false;
        var targets = this._targets;
        for (var i = 0, l = targets.length; i < l; i++) this._addSgTargetInSg(targets[i]);
      },
      onDisable: function() {
        if (Camera.main !== this) return;
        Camera.main = null;
        false;
        var sgTargets = this._sgTarges;
        for (var i = sgTargets.length - 1; i >= 0; i--) this._removeTargetInSg(sgTargets[i]);
      },
      addTarget: function(target) {
        if (-1 !== this._targets.indexOf(target)) return;
        this._addSgTargetInSg(target);
        this._targets.push(target);
      },
      removeTarget: function(target) {
        if (-1 === this._targets.indexOf(target)) return;
        this._removeTargetInSg(target);
        cc.js.array.remove(this._targets, target);
      },
      getTargets: function() {
        return this._targets;
      },
      getNodeToCameraTransform: function(node) {
        var t = node.getNodeToWorldTransform();
        this.containsNode(node) && (t = cc.affineTransformConcatIn(t, cc.Camera.main.viewMatrix));
        return t;
      },
      getCameraToWorldPoint: function(point) {
        cc.Camera.main && (point = cc.pointApplyAffineTransform(point, cc.Camera.main.invertViewMatrix));
        return point;
      },
      containsNode: function(node) {
        node instanceof cc.Node && (node = node._sgNode);
        var targets = this._sgTarges;
        while (node) {
          if (-1 !== targets.indexOf(node)) return true;
          node = node.parent;
        }
        return false;
      },
      _setSgNodesCullingDirty: function() {
        var sgTarges = this._sgTarges;
        for (var i = 0; i < sgTarges.length; i++) {
          false;
          sgTarges[i]._renderCmd.setDirtyFlag(cullingDirtyFlag);
        }
      },
      _checkSgTargets: function() {
        var targets = this._targets;
        var sgTarges = this._sgTarges;
        var checkedTimes = ++this._checkedTimes;
        for (var i = 0, l = targets.length; i < l; i++) {
          var target = targets[i];
          var sgNode = target;
          if (target instanceof cc.Node) {
            sgNode = target._sgNode;
            sgNode && !sgNode._cameraInfo && this._addSgTargetInSg(sgNode);
          }
          sgNode && (sgNode._cameraInfo.touched = checkedTimes);
        }
        for (var _i = sgTarges.length - 1; _i >= 0; _i--) {
          var sgTarget = sgTarges[_i];
          sgTarget._cameraInfo.touched !== checkedTimes && this._removeTargetInSg(sgTarget);
        }
      },
      lateUpdate: (true, function() {
        this._checkSgTargets();
        var m = this.viewMatrix;
        var im = this.invertViewMatrix;
        var viewPort = this.viewPort;
        var visibleRect = cc.visibleRect;
        var selfVisibleRect = this.visibleRect;
        var node = this.node;
        var wt = node.getNodeToWorldTransformAR();
        var rotation = .5 * -(Math.atan2(wt.b, wt.a) + Math.atan2(-wt.c, wt.d));
        var a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0;
        if (rotation) {
          c = Math.sin(rotation);
          d = Math.cos(rotation);
          a = d;
          b = -c;
        }
        var zoomRatio = this.zoomRatio;
        a *= zoomRatio;
        b *= zoomRatio;
        c *= zoomRatio;
        d *= zoomRatio;
        m.a = a;
        m.b = b;
        m.c = c;
        m.d = d;
        var center = visibleRect.center;
        m.tx = center.x - (a * wt.tx + c * wt.ty);
        m.ty = center.y - (b * wt.tx + d * wt.ty);
        cc.affineTransformInvertOut(m, im);
        viewPort.x = visibleRect.bottomLeft.x;
        viewPort.y = visibleRect.bottomLeft.y;
        viewPort.width = visibleRect.width;
        viewPort.height = visibleRect.height;
        cc._rectApplyAffineTransformIn(viewPort, im);
        selfVisibleRect.left.x = viewPort.xMin;
        selfVisibleRect.right.x = viewPort.xMax;
        selfVisibleRect.bottom.y = viewPort.yMin;
        selfVisibleRect.top.y = viewPort.yMax;
        this._sgNode.setTransform(a, b, c, d, m.tx, m.ty);
        var lvm = this._lastViewMatrix;
        if (lvm.a !== m.a || lvm.b !== m.b || lvm.c !== m.c || lvm.d !== m.d || lvm.tx !== m.tx || lvm.ty !== m.ty) {
          this._setSgNodesCullingDirty();
          lvm.a = m.a;
          lvm.b = m.b;
          lvm.c = m.c;
          lvm.d = m.d;
          lvm.tx = m.tx;
          lvm.ty = m.ty;
        }
      })
    });
    Camera.flags = cc.Enum({
      InCamera: 1,
      ParentInCamera: 2
    });
    module.exports = cc.Camera = Camera;
  }), {
    "./CCSGCameraNode": 61
  } ],
  61: [ (function(require, module, exports) {
    var tempMat = new cc.math.Matrix4();
    var CameraNode = _ccsg.Node.extend({
      ctor: function() {
        this._super();
        this._mat = new cc.math.Matrix4();
        this._mat.identity();
        this._beforeVisitCmd = new cc.CustomRenderCmd(this, this._onBeforeVisit);
        this._afterVisitCmd = new cc.CustomRenderCmd(this, this._onAfterVisit);
      },
      setTransform: function(a, b, c, d, tx, ty) {
        var mat = this._mat.mat;
        mat[0] = a;
        mat[1] = b;
        mat[4] = c;
        mat[5] = d;
        mat[12] = tx;
        mat[13] = ty;
      },
      addTarget: function(target) {
        var info = target._cameraInfo;
        info.sgCameraNode = this;
        info.originVisit = target.visit;
        target.visit = this._visit;
      },
      removeTarget: function(target) {
        target.visit = target._cameraInfo.originVisit;
      },
      _visit: function(parent) {
        var info = this._cameraInfo;
        var sgCameraNode = info.sgCameraNode;
        cc.renderer.pushRenderCommand(sgCameraNode._beforeVisitCmd);
        info.originVisit.call(this, parent);
        cc.renderer.pushRenderCommand(sgCameraNode._afterVisitCmd);
      },
      _onBeforeVisit: function() {
        cc.renderer._breakBatch();
        cc.math.glMatrixMode(cc.math.KM_GL_PROJECTION);
        tempMat.assignFrom(cc.current_stack.top);
        tempMat.multiply(this._mat);
        cc.current_stack.push(tempMat);
      },
      _onAfterVisit: function() {
        cc.renderer._breakBatch();
        cc.math.glMatrixMode(cc.math.KM_GL_PROJECTION);
        cc.current_stack.pop();
      }
    });
    module.exports = _ccsg.CameraNode = CameraNode;
  }), {} ],
  62: [ (function(require, module, exports) {
    cc.Collider.Box = cc.Class({
      properties: {
        _offset: cc.v2(0, 0),
        _size: cc.size(100, 100),
        offset: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.offset"),
          get: function() {
            return this._offset;
          },
          set: function(value) {
            this._offset = value;
          },
          type: cc.Vec2
        },
        size: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.size"),
          get: function() {
            return this._size;
          },
          set: function(value) {
            this._size.width = value.width < 0 ? 0 : value.width;
            this._size.height = value.height < 0 ? 0 : value.height;
          },
          type: cc.Size
        }
      },
      resetInEditor: false
    });
    var BoxCollider = cc.Class({
      name: "cc.BoxCollider",
      extends: cc.Collider,
      mixins: [ cc.Collider.Box ],
      editor: false
    });
    cc.BoxCollider = module.exports = BoxCollider;
  }), {} ],
  63: [ (function(require, module, exports) {
    cc.Collider.Circle = cc.Class({
      properties: {
        _offset: cc.v2(0, 0),
        _radius: 50,
        offset: {
          get: function() {
            return this._offset;
          },
          set: function(value) {
            this._offset = value;
          },
          type: cc.Vec2
        },
        radius: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.radius"),
          get: function() {
            return this._radius;
          },
          set: function(value) {
            this._radius = value < 0 ? 0 : value;
          }
        }
      },
      resetInEditor: false
    });
    var CircleCollider = cc.Class({
      name: "cc.CircleCollider",
      extends: cc.Collider,
      mixins: [ cc.Collider.Circle ],
      editor: false
    });
    cc.CircleCollider = module.exports = CircleCollider;
  }), {} ],
  64: [ (function(require, module, exports) {
    var Collider = cc.Class({
      name: "cc.Collider",
      extends: cc.Component,
      properties: {
        editing: {
          default: false,
          serializable: false,
          tooltip: (true, "i18n:COMPONENT.collider.editing")
        },
        tag: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.tag"),
          default: 0,
          range: [ 0, 1e7 ],
          type: cc.Integer
        }
      },
      onDisable: function() {
        cc.director.getCollisionManager().removeCollider(this);
      },
      onEnable: function() {
        cc.director.getCollisionManager().addCollider(this);
      }
    });
    cc.Collider = module.exports = Collider;
  }), {} ],
  65: [ (function(require, module, exports) {
    var Contact = require("./CCContact");
    var CollisionType = Contact.CollisionType;
    var tempRect = cc.rect();
    var tempVec2 = cc.v2();
    var CollisionManager = cc.Class({
      mixins: [ cc.EventTarget ],
      properties: {
        enabled: false,
        enabledDrawBoundingBox: false
      },
      ctor: function() {
        this.__instanceId = cc.ClassManager.getNewInstanceId();
        this._contacts = [];
        this._colliders = [];
        this._debugDrawer = null;
        this._enabledDebugDraw = false;
      },
      update: function(dt) {
        if (!this.enabled) return;
        var i, l;
        var colliders = this._colliders;
        for (i = 0, l = colliders.length; i < l; i++) this.updateCollider(colliders[i]);
        var contacts = this._contacts;
        var results = [];
        for (i = 0, l = contacts.length; i < l; i++) {
          var collisionType = contacts[i].updateState();
          if (collisionType === CollisionType.None) continue;
          results.push([ collisionType, contacts[i] ]);
        }
        for (i = 0, l = results.length; i < l; i++) {
          var result = results[i];
          this._doCollide(result[0], result[1]);
        }
        this.drawColliders();
      },
      _doCollide: function(collisionType, contact) {
        var contactFunc;
        switch (collisionType) {
         case CollisionType.CollisionEnter:
          contactFunc = "onCollisionEnter";
          break;

         case CollisionType.CollisionStay:
          contactFunc = "onCollisionStay";
          break;

         case CollisionType.CollisionExit:
          contactFunc = "onCollisionExit";
        }
        var collider1 = contact.collider1;
        var collider2 = contact.collider2;
        var comps1 = collider1.node._components;
        var comps2 = collider2.node._components;
        var i, l, comp;
        for (i = 0, l = comps1.length; i < l; i++) {
          comp = comps1[i];
          comp[contactFunc] && comp[contactFunc](collider2, collider1);
        }
        for (i = 0, l = comps2.length; i < l; i++) {
          comp = comps2[i];
          comp[contactFunc] && comp[contactFunc](collider1, collider2);
        }
      },
      shouldCollide: function(c1, c2) {
        var node1 = c1.node, node2 = c2.node;
        var collisionMatrix = cc.game.collisionMatrix;
        return node1 !== node2 && collisionMatrix[node1.groupIndex][node2.groupIndex];
      },
      initCollider: function(collider) {
        if (!collider.world) {
          var world = collider.world = {};
          world.aabb = cc.rect();
          world.preAabb = cc.rect();
          world.radius = 0;
          if (collider instanceof cc.BoxCollider) {
            world.position = null;
            world.points = [ cc.v2(), cc.v2(), cc.v2(), cc.v2() ];
          } else if (collider instanceof cc.PolygonCollider) {
            world.position = null;
            world.points = collider.points.map((function(p) {
              return cc.v2(p.x, p.y);
            }));
          } else if (collider instanceof cc.CircleCollider) {
            world.position = cc.v2();
            world.points = null;
          }
        }
      },
      updateCollider: function(collider) {
        var offset = collider.offset;
        var world = collider.world;
        var aabb = world.aabb;
        var t = world.transform = collider.node.getNodeToWorldTransformAR();
        var preAabb = world.preAabb;
        preAabb.x = aabb.x;
        preAabb.y = aabb.y;
        preAabb.width = aabb.width;
        preAabb.height = aabb.height;
        if (collider instanceof cc.BoxCollider) {
          var size = collider.size;
          tempRect.x = offset.x - size.width / 2;
          tempRect.y = offset.y - size.height / 2;
          tempRect.width = size.width;
          tempRect.height = size.height;
          var wps = world.points;
          var wp0 = wps[0];
          var wp1 = wps[1];
          var wp2 = wps[2];
          var wp3 = wps[3];
          cc.obbApplyAffineTransform(tempRect, t, wp0, wp1, wp2, wp3);
          var minx = Math.min(wp0.x, wp1.x, wp2.x, wp3.x);
          var miny = Math.min(wp0.y, wp1.y, wp2.y, wp3.y);
          var maxx = Math.max(wp0.x, wp1.x, wp2.x, wp3.x);
          var maxy = Math.max(wp0.y, wp1.y, wp2.y, wp3.y);
          aabb.x = minx;
          aabb.y = miny;
          aabb.width = maxx - minx;
          aabb.height = maxy - miny;
        } else if (collider instanceof cc.CircleCollider) {
          var p = cc.pointApplyAffineTransform(collider.offset, t);
          world.position.x = p.x;
          world.position.y = p.y;
          t.tx = t.ty = 0;
          tempVec2.x = collider.radius;
          tempVec2.y = 0;
          var tempP = cc.pointApplyAffineTransform(tempVec2, t);
          var d = Math.sqrt(tempP.x * tempP.x + tempP.y * tempP.y);
          world.radius = d;
          aabb.x = p.x - d;
          aabb.y = p.y - d;
          aabb.width = 2 * d;
          aabb.height = 2 * d;
        } else if (collider instanceof cc.PolygonCollider) {
          var points = collider.points;
          var worldPoints = world.points;
          worldPoints.length = points.length;
          var minx = 1e6, miny = 1e6, maxx = -1e6, maxy = -1e6;
          for (var i = 0, l = points.length; i < l; i++) {
            worldPoints[i] || (worldPoints[i] = cc.v2());
            tempVec2.x = points[i].x + offset.x;
            tempVec2.y = points[i].y + offset.y;
            var p = cc.pointApplyAffineTransform(tempVec2, t);
            worldPoints[i].x = p.x;
            worldPoints[i].y = p.y;
            p.x > maxx && (maxx = p.x);
            p.x < minx && (minx = p.x);
            p.y > maxy && (maxy = p.y);
            p.y < miny && (miny = p.y);
          }
          aabb.x = minx;
          aabb.y = miny;
          aabb.width = maxx - minx;
          aabb.height = maxy - miny;
        }
      },
      addCollider: function(collider) {
        var colliders = this._colliders;
        var index = colliders.indexOf(collider);
        if (-1 === index) {
          for (var i = 0, l = colliders.length; i < l; i++) {
            var other = colliders[i];
            if (this.shouldCollide(collider, other)) {
              var contact = new Contact(collider, other);
              this._contacts.push(contact);
            }
          }
          colliders.push(collider);
          this.initCollider(collider);
        }
        collider.node.on("group-changed", this.onNodeGroupChanged, this);
      },
      removeCollider: function(collider) {
        var colliders = this._colliders;
        var index = colliders.indexOf(collider);
        if (index >= 0) {
          colliders.splice(index, 1);
          var contacts = this._contacts;
          for (var i = contacts.length - 1; i >= 0; i--) {
            var contact = contacts[i];
            if (contact.collider1 === collider || contact.collider2 === collider) {
              contact.touching && this._doCollide(CollisionType.CollisionExit, contact);
              contacts.splice(i, 1);
            }
          }
          collider.node.off("group-changed", this.onNodeGroupChanged, this);
        } else cc.errorID(6600);
      },
      attachDebugDrawToCamera: function(camera) {
        if (!this._debugDrawer) return;
        camera.addTarget(this._debugDrawer);
      },
      detachDebugDrawFromCamera: function(camera) {
        if (!this._debugDrawer) return;
        camera.removeTarget(this._debugDrawer);
      },
      onNodeGroupChanged: function(event) {
        var node = event.currentTarget;
        var colliders = node.getComponents(cc.Collider);
        for (var i = 0, l = colliders.length; i < l; i++) {
          this.removeCollider(colliders[i]);
          this.addCollider(colliders[i]);
        }
      },
      drawColliders: function() {
        var debugDrawer = this._debugDrawer;
        if (!this._enabledDebugDraw || !debugDrawer) return;
        debugDrawer.clear();
        var colliders = this._colliders;
        for (var i = 0, l = colliders.length; i < l; i++) {
          var collider = colliders[i];
          if (collider instanceof cc.BoxCollider || collider instanceof cc.PolygonCollider) {
            var ps = collider.world.points;
            if (ps.length > 0) {
              debugDrawer.strokeColor = cc.Color.WHITE;
              debugDrawer.moveTo(ps[0].x, ps[0].y);
              for (var j = 1; j < ps.length; j++) debugDrawer.lineTo(ps[j].x, ps[j].y);
              debugDrawer.close();
              debugDrawer.stroke();
            }
          } else if (collider instanceof cc.CircleCollider) {
            debugDrawer.circle(collider.world.position.x, collider.world.position.y, collider.world.radius);
            debugDrawer.stroke();
          }
          if (this.enabledDrawBoundingBox) {
            var aabb = collider.world.aabb;
            debugDrawer.strokeColor = cc.Color.BLUE;
            debugDrawer.moveTo(aabb.xMin, aabb.yMin);
            debugDrawer.lineTo(aabb.xMin, aabb.yMax);
            debugDrawer.lineTo(aabb.xMax, aabb.yMax);
            debugDrawer.lineTo(aabb.xMax, aabb.yMin);
            debugDrawer.close();
            debugDrawer.stroke();
          }
        }
      },
      onSceneLaunched: function() {
        if (this._enabledDebugDraw && this._debugDrawer) {
          this._debugDrawer.removeFromParent();
          cc.director.getScene()._sgNode.addChild(this._debugDrawer);
        }
      }
    });
    cc.js.getset(CollisionManager.prototype, "enabledDebugDraw", (function() {
      return this._enabledDebugDraw;
    }), (function(value) {
      if (value && !this._enabledDebugDraw) {
        if (!this._debugDrawer) {
          this._debugDrawer = new _ccsg.GraphicsNode();
          this._debugDrawer.retain();
        }
        cc.director.getScene()._sgNode.addChild(this._debugDrawer);
        cc.director.on(cc.Director.EVENT_AFTER_SCENE_LAUNCH, this.onSceneLaunched, this);
      } else if (!value && this._enabledDebugDraw) {
        this._debugDrawer.clear();
        this._debugDrawer.removeFromParent(false);
        cc.director.off(cc.Director.EVENT_AFTER_SCENE_LAUNCH, this.onSceneLaunched, this);
      }
      this._enabledDebugDraw = value;
    }));
    cc.CollisionManager = module.exports = CollisionManager;
  }), {
    "./CCContact": 66
  } ],
  66: [ (function(require, module, exports) {
    var Intersection = require("./CCIntersection");
    var CollisionType = cc.Enum({
      None: 0,
      CollisionEnter: 1,
      CollisionStay: 2,
      CollisionExit: 3
    });
    function Contact(collider1, collider2) {
      this.collider1 = collider1;
      this.collider2 = collider2;
      this.touching = false;
      var isCollider1Polygon = collider1 instanceof cc.BoxCollider || collider1 instanceof cc.PolygonCollider;
      var isCollider2Polygon = collider2 instanceof cc.BoxCollider || collider2 instanceof cc.PolygonCollider;
      var isCollider1Circle = collider1 instanceof cc.CircleCollider;
      var isCollider2Circle = collider2 instanceof cc.CircleCollider;
      if (isCollider1Polygon && isCollider2Polygon) this.testFunc = Intersection.polygonPolygon; else if (isCollider1Circle && isCollider2Circle) this.testFunc = Intersection.circleCircle; else if (isCollider1Polygon && isCollider2Circle) this.testFunc = Intersection.polygonCircle; else if (isCollider1Circle && isCollider2Polygon) {
        this.testFunc = Intersection.polygonCircle;
        this.collider1 = collider2;
        this.collider2 = collider1;
      } else cc.errorID(6601, cc.js.getClassName(collider1), cc.js.getClassName(collider2));
    }
    Contact.prototype.test = function() {
      var world1 = this.collider1.world;
      var world2 = this.collider2.world;
      if (!world1.aabb.intersects(world2.aabb)) return false;
      if (this.testFunc === Intersection.polygonPolygon) return this.testFunc(world1.points, world2.points);
      if (this.testFunc === Intersection.circleCircle) return this.testFunc(world1, world2);
      if (this.testFunc === Intersection.polygonCircle) return this.testFunc(world1.points, world2);
      return false;
    };
    Contact.prototype.updateState = function() {
      var result = this.test();
      var type = CollisionType.None;
      if (result && !this.touching) {
        this.touching = true;
        type = CollisionType.CollisionEnter;
      } else if (result && this.touching) type = CollisionType.CollisionStay; else if (!result && this.touching) {
        this.touching = false;
        type = CollisionType.CollisionExit;
      }
      return type;
    };
    Contact.CollisionType = CollisionType;
    module.exports = Contact;
  }), {
    "./CCIntersection": 67
  } ],
  67: [ (function(require, module, exports) {
    var Intersection = {};
    function lineLine(a1, a2, b1, b2) {
      var ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);
      var ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x);
      var u_b = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
      if (0 !== u_b) {
        var ua = ua_t / u_b;
        var ub = ub_t / u_b;
        if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) return true;
      }
      return false;
    }
    Intersection.lineLine = lineLine;
    function lineRect(a1, a2, b) {
      var r0 = new cc.Vec2(b.x, b.y);
      var r1 = new cc.Vec2(b.x, b.yMax);
      var r2 = new cc.Vec2(b.xMax, b.yMax);
      var r3 = new cc.Vec2(b.xMax, b.y);
      if (lineLine(a1, a2, r0, r1)) return true;
      if (lineLine(a1, a2, r1, r2)) return true;
      if (lineLine(a1, a2, r2, r3)) return true;
      if (lineLine(a1, a2, r3, r0)) return true;
      return false;
    }
    Intersection.lineRect = lineRect;
    function linePolygon(a1, a2, b) {
      var length = b.length;
      for (var i = 0; i < length; ++i) {
        var b1 = b[i];
        var b2 = b[(i + 1) % length];
        if (lineLine(a1, a2, b1, b2)) return true;
      }
      return false;
    }
    Intersection.linePolygon = linePolygon;
    function rectRect(a, b) {
      var a_min_x = a.x;
      var a_min_y = a.y;
      var a_max_x = a.x + a.width;
      var a_max_y = a.y + a.height;
      var b_min_x = b.x;
      var b_min_y = b.y;
      var b_max_x = b.x + b.width;
      var b_max_y = b.y + b.height;
      return a_min_x <= b_max_x && a_max_x >= b_min_x && a_min_y <= b_max_y && a_max_y >= b_min_y;
    }
    Intersection.rectRect = rectRect;
    function rectPolygon(a, b) {
      var i, l;
      var r0 = new cc.Vec2(a.x, a.y);
      var r1 = new cc.Vec2(a.x, a.yMax);
      var r2 = new cc.Vec2(a.xMax, a.yMax);
      var r3 = new cc.Vec2(a.xMax, a.y);
      if (linePolygon(r0, r1, b)) return true;
      if (linePolygon(r1, r2, b)) return true;
      if (linePolygon(r2, r3, b)) return true;
      if (linePolygon(r3, r0, b)) return true;
      for (i = 0, l = b.length; i < l; ++i) if (pointInPolygon(b[i], a)) return true;
      if (pointInPolygon(r0, b)) return true;
      if (pointInPolygon(r1, b)) return true;
      if (pointInPolygon(r2, b)) return true;
      if (pointInPolygon(r3, b)) return true;
      return false;
    }
    Intersection.rectPolygon = rectPolygon;
    function polygonPolygon(a, b) {
      var i, l;
      for (i = 0, l = a.length; i < l; ++i) {
        var a1 = a[i];
        var a2 = a[(i + 1) % l];
        if (linePolygon(a1, a2, b)) return true;
      }
      for (i = 0, l = b.length; i < l; ++i) if (pointInPolygon(b[i], a)) return true;
      for (i = 0, l = a.length; i < l; ++i) if (pointInPolygon(a[i], b)) return true;
      return false;
    }
    Intersection.polygonPolygon = polygonPolygon;
    function circleCircle(a, b) {
      var distance = a.position.sub(b.position).mag();
      return distance < a.radius + b.radius;
    }
    Intersection.circleCircle = circleCircle;
    function polygonCircle(polygon, circle) {
      var position = circle.position;
      if (pointInPolygon(position, polygon)) return true;
      for (var i = 0, l = polygon.length; i < l; i++) {
        var start = 0 === i ? polygon[polygon.length - 1] : polygon[i - 1];
        var end = polygon[i];
        if (pointLineDistance(position, start, end, true) < circle.radius) return true;
      }
      return false;
    }
    Intersection.polygonCircle = polygonCircle;
    function pointInPolygon(point, polygon) {
      var inside = false;
      var x = point.x;
      var y = point.y;
      var length = polygon.length;
      for (var i = 0, j = length - 1; i < length; j = i++) {
        var xi = polygon[i].x, yi = polygon[i].y, xj = polygon[j].x, yj = polygon[j].y, intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
        intersect && (inside = !inside);
      }
      return inside;
    }
    Intersection.pointInPolygon = pointInPolygon;
    function pointLineDistance(point, start, end, isSegment) {
      var dx = end.x - start.x;
      var dy = end.y - start.y;
      var d = dx * dx + dy * dy;
      var t = ((point.x - start.x) * dx + (point.y - start.y) * dy) / d;
      var p;
      p = isSegment ? d ? t < 0 ? start : t > 1 ? end : cc.v2(start.x + t * dx, start.y + t * dy) : start : cc.v2(start.x + t * dx, start.y + t * dy);
      dx = point.x - p.x;
      dy = point.y - p.y;
      return Math.sqrt(dx * dx + dy * dy);
    }
    Intersection.pointLineDistance = pointLineDistance;
    cc.Intersection = module.exports = Intersection;
  }), {} ],
  68: [ (function(require, module, exports) {
    cc.Collider.Polygon = cc.Class({
      properties: {
        threshold: {
          default: 1,
          serializable: false,
          visible: false
        },
        _offset: cc.v2(0, 0),
        offset: {
          get: function() {
            return this._offset;
          },
          set: function(value) {
            this._offset = value;
          },
          type: cc.Vec2
        },
        points: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.points"),
          default: function() {
            return [ cc.v2(-50, -50), cc.v2(50, -50), cc.v2(50, 50), cc.v2(-50, 50) ];
          },
          type: [ cc.Vec2 ]
        }
      },
      resetPointsByContour: false
    });
    var PolygonCollider = cc.Class({
      name: "cc.PolygonCollider",
      extends: cc.Collider,
      mixins: [ cc.Collider.Polygon ],
      editor: false
    });
    cc.PolygonCollider = module.exports = PolygonCollider;
  }), {} ],
  69: [ (function(require, module, exports) {
    require("./CCCollisionManager");
    require("./CCCollider");
    require("./CCBoxCollider");
    require("./CCCircleCollider");
    require("./CCPolygonCollider");
  }), {
    "./CCBoxCollider": 62,
    "./CCCircleCollider": 63,
    "./CCCollider": 64,
    "./CCCollisionManager": 65,
    "./CCPolygonCollider": 68
  } ],
  70: [ (function(require, module, exports) {
    require("./platform/CCClass");
    var Flags = require("./platform/CCObject").Flags;
    var JsArray = require("./platform/js").array;
    var IsStartCalled = Flags.IsStartCalled;
    var IsOnEnableCalled = Flags.IsOnEnableCalled;
    var IsEditorOnEnableCalled = Flags.IsEditorOnEnableCalled;
    var callerFunctor = false;
    var callOnEnableInTryCatch = false;
    var callStartInTryCatch = false;
    var callUpdateInTryCatch = false;
    var callLateUpdateInTryCatch = false;
    var callOnDisableInTryCatch = false;
    var callStart = "c.start();c._objFlags|=" + IsStartCalled;
    var callUpdate = "c.update(dt)";
    var callLateUpdate = "c.lateUpdate(dt)";
    function sortedIndex(array, comp) {
      var order = comp.constructor._executionOrder;
      var id = comp.__instanceId;
      for (var l = 0, h = array.length - 1, m = h >>> 1; l <= h; m = l + h >>> 1) {
        var test = array[m];
        var testOrder = test.constructor._executionOrder;
        if (testOrder > order) h = m - 1; else if (testOrder < order) l = m + 1; else {
          var testId = test.__instanceId;
          if (testId > id) h = m - 1; else {
            if (!(testId < id)) return m;
            l = m + 1;
          }
        }
      }
      return ~l;
    }
    function stableRemoveInactive(iterator, flagToClear) {
      var array = iterator.array;
      var next = iterator.i + 1;
      while (next < array.length) {
        var comp = array[next];
        if (comp._enabled && comp.node._activeInHierarchy) ++next; else {
          iterator.removeAt(next);
          flagToClear && (comp._objFlags &= ~flagToClear);
        }
      }
    }
    var LifeCycleInvoker = cc.Class({
      __ctor__: function(invokeFunc) {
        var Iterator = JsArray.MutableForwardIterator;
        this._zero = new Iterator([]);
        this._neg = new Iterator([]);
        this._pos = new Iterator([]);
        false;
        this._invoke = invokeFunc;
      },
      statics: {
        stableRemoveInactive: stableRemoveInactive
      },
      add: null,
      remove: null,
      invoke: null
    });
    function compareOrder(a, b) {
      return a.constructor._executionOrder - b.constructor._executionOrder;
    }
    var OneOffInvoker = cc.Class({
      extends: LifeCycleInvoker,
      add: function(comp) {
        var order = comp.constructor._executionOrder;
        (0 === order ? this._zero : order < 0 ? this._neg : this._pos).array.push(comp);
      },
      remove: function(comp) {
        var order = comp.constructor._executionOrder;
        (0 === order ? this._zero : order < 0 ? this._neg : this._pos).fastRemove(comp);
      },
      cancelInactive: function(flagToClear) {
        stableRemoveInactive(this._zero, flagToClear);
        stableRemoveInactive(this._neg, flagToClear);
        stableRemoveInactive(this._pos, flagToClear);
      },
      invoke: function() {
        var compsNeg = this._neg;
        if (compsNeg.array.length > 0) {
          compsNeg.array.sort(compareOrder);
          this._invoke(compsNeg);
          compsNeg.array.length = 0;
        }
        this._invoke(this._zero);
        this._zero.array.length = 0;
        var compsPos = this._pos;
        if (compsPos.array.length > 0) {
          compsPos.array.sort(compareOrder);
          this._invoke(compsPos);
          compsPos.array.length = 0;
        }
      }
    });
    var ReusableInvoker = cc.Class({
      extends: LifeCycleInvoker,
      add: function(comp) {
        var order = comp.constructor._executionOrder;
        if (0 === order) this._zero.array.push(comp); else {
          var array = order < 0 ? this._neg.array : this._pos.array;
          var i = sortedIndex(array, comp);
          if (i < 0) array.splice(~i, 0, comp); else {
            true;
            cc.error("component already added");
          }
        }
      },
      remove: function(comp) {
        var order = comp.constructor._executionOrder;
        if (0 === order) this._zero.fastRemove(comp); else {
          var iterator = order < 0 ? this._neg : this._pos;
          var i = sortedIndex(iterator.array, comp);
          i >= 0 && iterator.removeAt(i);
        }
      },
      invoke: function(dt) {
        this._neg.array.length > 0 && this._invoke(this._neg, dt);
        this._invoke(this._zero, dt);
        this._pos.array.length > 0 && this._invoke(this._pos, dt);
      }
    });
    function enableInEditor(comp) {
      if (!(comp._objFlags & IsEditorOnEnableCalled)) {
        cc.engine.emit("component-enabled", comp.uuid);
        comp._objFlags |= IsEditorOnEnableCalled;
      }
    }
    function createInvokeImpl(funcOrCode, useDt) {
      if ("function" === typeof funcOrCode) return useDt ? function(iterator, dt) {
        var array = iterator.array;
        for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
          var comp = array[iterator.i];
          funcOrCode(comp, dt);
        }
      } : function(iterator) {
        var array = iterator.array;
        for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
          var comp = array[iterator.i];
          funcOrCode(comp);
        }
      };
      var body = "var a=it.array;for(it.i=0;it.i<a.length;++it.i){var c=a[it.i];" + funcOrCode + "}";
      return useDt ? Function("it", "dt", body) : Function("it", body);
    }
    function ctor() {
      this.startInvoker = new OneOffInvoker(createInvokeImpl(callStart));
      this.updateInvoker = new ReusableInvoker(createInvokeImpl(callUpdate, true));
      this.lateUpdateInvoker = new ReusableInvoker(createInvokeImpl(callLateUpdate, true));
      this.scheduleInNextFrame = [];
      this._updating = false;
    }
    var ComponentScheduler = cc.Class({
      ctor: ctor,
      unscheduleAll: ctor,
      statics: {
        LifeCycleInvoker: LifeCycleInvoker,
        OneOffInvoker: OneOffInvoker,
        createInvokeImpl: createInvokeImpl,
        invokeOnEnable: function(iterator) {
          var compScheduler = cc.director._compScheduler;
          var array = iterator.array;
          for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
            var comp = array[iterator.i];
            if (comp._enabled) {
              comp.onEnable();
              var deactivatedDuringOnEnable = !comp.node._activeInHierarchy;
              deactivatedDuringOnEnable || compScheduler._onEnabled(comp);
            }
          }
        }
      },
      _onEnabled: function(comp) {
        cc.director.getScheduler().resumeTarget(comp);
        comp._objFlags |= IsOnEnableCalled;
        this._updating ? this.scheduleInNextFrame.push(comp) : this._scheduleImmediate(comp);
      },
      _onDisabled: function(comp) {
        cc.director.getScheduler().pauseTarget(comp);
        comp._objFlags &= ~IsOnEnableCalled;
        var index = this.scheduleInNextFrame.indexOf(comp);
        if (index >= 0) {
          JsArray.fastRemoveAt(this.scheduleInNextFrame, index);
          return;
        }
        !comp.start || comp._objFlags & IsStartCalled || this.startInvoker.remove(comp);
        comp.update && this.updateInvoker.remove(comp);
        comp.lateUpdate && this.lateUpdateInvoker.remove(comp);
      },
      enableComp: function(comp, invoker) {
        if (!(comp._objFlags & IsOnEnableCalled)) {
          if (comp.onEnable) {
            if (invoker) {
              invoker.add(comp);
              return;
            }
            comp.onEnable();
            var deactivatedDuringOnEnable = !comp.node._activeInHierarchy;
            if (deactivatedDuringOnEnable) return;
          }
          this._onEnabled(comp);
        }
      },
      disableComp: function(comp) {
        if (comp._objFlags & IsOnEnableCalled) {
          comp.onDisable && comp.onDisable();
          this._onDisabled(comp);
        }
      },
      _scheduleImmediate: function(comp) {
        !comp.start || comp._objFlags & IsStartCalled || this.startInvoker.add(comp);
        comp.update && this.updateInvoker.add(comp);
        comp.lateUpdate && this.lateUpdateInvoker.add(comp);
      },
      _deferredSchedule: function() {
        var comps = this.scheduleInNextFrame;
        for (var i = 0, len = comps.length; i < len; i++) {
          var comp = comps[i];
          this._scheduleImmediate(comp);
        }
        comps.length = 0;
      },
      startPhase: function() {
        this._updating = true;
        this.scheduleInNextFrame.length > 0 && this._deferredSchedule();
        this.startInvoker.invoke();
      },
      updatePhase: function(dt) {
        this.updateInvoker.invoke(dt);
      },
      lateUpdatePhase: function(dt) {
        this.lateUpdateInvoker.invoke(dt);
        this._updating = false;
      }
    });
    module.exports = ComponentScheduler;
  }), {
    "./platform/CCClass": 175,
    "./platform/CCObject": 181,
    "./platform/js": 196,
    "./utils/misc": 225
  } ],
  71: [ (function(require, module, exports) {
    var AnimationAnimator = require("../../animation/animation-animator");
    var AnimationClip = require("../../animation/animation-clip");
    function equalClips(clip1, clip2) {
      if (clip1 === clip2) return true;
      return clip1 && clip2 && (clip1.name === clip2.name || clip1._uuid === clip2._uuid);
    }
    var Animation = cc.Class({
      name: "cc.Animation",
      extends: require("./CCComponent"),
      mixins: [ cc.EventTarget ],
      editor: false,
      ctor: function() {
        cc.EventTarget.call(this);
        this._animator = null;
        this._nameToState = {};
        this._didInit = false;
        this._currentClip = null;
      },
      properties: {
        _defaultClip: {
          default: null,
          type: AnimationClip
        },
        defaultClip: {
          type: AnimationClip,
          get: function() {
            return this._defaultClip;
          },
          set: function(value) {
            true;
            return;
            var clips;
            var i, l;
          },
          tooltip: (true, "i18n:COMPONENT.animation.default_clip")
        },
        currentClip: {
          get: function() {
            return this._currentClip;
          },
          set: function(value) {
            this._currentClip = value;
          },
          type: AnimationClip,
          visible: false
        },
        _clips: {
          default: [],
          type: [ AnimationClip ],
          tooltip: (true, "i18n:COMPONENT.animation.clips"),
          visible: true
        },
        playOnLoad: {
          default: false,
          tooltip: (true, "i18n:COMPONENT.animation.play_on_load")
        }
      },
      start: function() {
        if ((true, this.playOnLoad) && this._defaultClip) {
          var isPlaying = this._animator && this._animator.isPlaying;
          if (!isPlaying) {
            var state = this.getAnimationState(this._defaultClip.name);
            this._animator.playState(state);
          }
        }
      },
      onEnable: function() {
        this._animator && this._animator.resume();
      },
      onDisable: function() {
        this._animator && this._animator.pause();
      },
      onDestroy: function() {
        this.stop();
      },
      getClips: function() {
        return this._clips;
      },
      play: function(name, startTime) {
        var state = this.playAdditive(name, startTime);
        this._animator.stopStatesExcept(state);
        return state;
      },
      playAdditive: function(name, startTime) {
        this._init();
        var state = this.getAnimationState(name || this._defaultClip && this._defaultClip.name);
        if (state) {
          this.enabled = true;
          var animator = this._animator;
          if (animator.isPlaying && state.isPlaying) if (state.isPaused) animator.resumeState(state); else {
            animator.stopState(state);
            animator.playState(state, startTime);
          } else animator.playState(state, startTime);
          this.currentClip = state.clip;
        }
        return state;
      },
      stop: function(name) {
        if (!this._didInit) return;
        if (name) {
          var state = this._nameToState[name];
          state && this._animator.stopState(state);
        } else this._animator.stop();
      },
      pause: function(name) {
        if (!this._didInit) return;
        if (name) {
          var state = this._nameToState[name];
          state && this._animator.pauseState(state);
        } else this.enabled = false;
      },
      resume: function(name) {
        if (!this._didInit) return;
        if (name) {
          var state = this._nameToState[name];
          state && this._animator.resumeState(state);
        } else this.enabled = true;
      },
      setCurrentTime: function(time, name) {
        this._init();
        if (name) {
          var state = this._nameToState[name];
          state && this._animator.setStateTime(state, time);
        } else this._animator.setStateTime(time);
      },
      getAnimationState: function(name) {
        this._init();
        var state = this._nameToState[name];
        false;
        state && !state.curveLoaded && this._animator._reloadClip(state);
        return state || null;
      },
      addClip: function(clip, newName) {
        if (!clip) {
          cc.warnID(3900);
          return;
        }
        this._init();
        cc.js.array.contains(this._clips, clip) || this._clips.push(clip);
        newName = newName || clip.name;
        var oldState = this._nameToState[newName];
        if (oldState) {
          if (oldState.clip === clip) return oldState;
          var index = this._clips.indexOf(oldState.clip);
          -1 !== index && this._clips.splice(index, 1);
        }
        var newState = new cc.AnimationState(clip, newName);
        this._nameToState[newName] = newState;
        return newState;
      },
      removeClip: function(clip, force) {
        if (!clip) {
          cc.warnID(3901);
          return;
        }
        this._init();
        var state;
        for (var name in this._nameToState) {
          state = this._nameToState[name];
          var stateClip = state.clip;
          if (stateClip === clip) break;
        }
        if (clip === this._defaultClip) {
          if (!force) {
            true;
            cc.warnID(3902);
            return;
          }
          this._defaultClip = null;
        }
        if (state && state.isPlaying) {
          if (!force) {
            true;
            cc.warnID(3903);
            return;
          }
          this.stop(state.name);
        }
        this._clips = this._clips.filter((function(item) {
          return item !== clip;
        }));
        state && delete this._nameToState[state.name];
      },
      sample: function(name) {
        this._init();
        if (name) {
          var state = this._nameToState[name];
          state && state.sample();
        } else this._animator.sample();
      },
      on: function(type, callback, target, useCapture) {
        this._init();
        var ret = cc.EventTarget.prototype.on.call(this, type, callback, target, useCapture);
        var array = this._animator._anims.array;
        for (var i = 0; i < array.length; ++i) array[i]._setListeners(this);
        return ret;
      },
      off: function(type, callback, target, useCapture) {
        this._init();
        cc.EventTarget.prototype.off.call(this, type, callback, target, useCapture);
        var nameToState = this._nameToState;
        for (var name in nameToState) {
          var state = nameToState[name];
          state._setListeners(null);
        }
      },
      _init: function() {
        if (this._didInit) return;
        this._didInit = true;
        this._animator = new AnimationAnimator(this.node, this);
        this._createStates();
      },
      _createStates: function() {
        this._nameToState = {};
        var state = null;
        var defaultClipState = false;
        for (var i = 0; i < this._clips.length; ++i) {
          var clip = this._clips[i];
          if (clip) {
            state = new cc.AnimationState(clip);
            false;
            this._nameToState[state.name] = state;
            equalClips(this._defaultClip, clip) && (defaultClipState = state);
          }
        }
        if (this._defaultClip && !defaultClipState) {
          state = new cc.AnimationState(this._defaultClip);
          false;
          this._nameToState[state.name] = state;
        }
      }
    });
    cc.Animation = module.exports = Animation;
  }), {
    "../../animation/animation-animator": 11,
    "../../animation/animation-clip": 12,
    "./CCComponent": 76
  } ],
  72: [ (function(require, module, exports) {
    var AudioSource = cc.Class({
      name: "cc.AudioSource",
      extends: require("./CCComponent"),
      editor: false,
      ctor: function() {
        this.audio = new cc.Audio();
      },
      properties: {
        _clip: {
          default: "",
          url: cc.AudioClip
        },
        _volume: 1,
        _mute: false,
        _loop: false,
        _pausedFlag: {
          default: false,
          serializable: false
        },
        isPlaying: {
          get: function() {
            if (!this.audio) return false;
            var state = this.audio.getState();
            return state === cc.Audio.State.PLAYING;
          },
          visible: false
        },
        clip: {
          get: function() {
            return this._clip;
          },
          set: function(value) {
            if (value === this._clip) return;
            this._clip = value;
            this.audio.stop();
            this.audio.src = this._clip;
            this.audio.preload && this.audio.preload();
          },
          url: cc.AudioClip,
          tooltip: (true, "i18n:COMPONENT.audio.clip"),
          animatable: false
        },
        volume: {
          get: function() {
            return this._volume;
          },
          set: function(value) {
            value = cc.clamp01(value);
            this._volume = value;
            var audio = this.audio;
            if (audio && !this._mute) {
              audio.setVolume(value);
              audio._loaded || audio.on("load", (function() {
                audio.setVolume(value);
              }));
            }
            return value;
          },
          tooltip: (true, "i18n:COMPONENT.audio.volume")
        },
        mute: {
          get: function() {
            return this._mute;
          },
          set: function(value) {
            this._mute = value;
            this.audio && this.audio.setVolume(value ? 0 : this._volume);
            return value;
          },
          animatable: false,
          tooltip: (true, "i18n:COMPONENT.audio.mute")
        },
        loop: {
          get: function() {
            return this._loop;
          },
          set: function(value) {
            this._loop = value;
            this.audio && this.audio.setLoop(value);
            return value;
          },
          animatable: false,
          tooltip: (true, "i18n:COMPONENT.audio.loop")
        },
        playOnLoad: {
          default: false,
          tooltip: (true, "i18n:COMPONENT.audio.play_on_load"),
          animatable: false
        },
        preload: {
          default: false,
          animatable: false
        }
      },
      _pausedCallback: function() {
        var audio = this.audio;
        if (!audio || audio.paused) return;
        this.audio.pause();
        this._pausedFlag = true;
      },
      _restoreCallback: function() {
        if (!this.audio) return;
        this._pausedFlag && this.audio.resume();
        this._pausedFlag = false;
      },
      onEnable: function() {
        this.playOnLoad && this.play();
        if (this.preload) {
          this.audio.src = this._clip;
          this.audio.preload();
        }
        cc.game.on(cc.game.EVENT_HIDE, this._pausedCallback, this);
        cc.game.on(cc.game.EVENT_SHOW, this._restoreCallback, this);
      },
      onDisable: function() {
        this.stop();
        cc.game.off(cc.game.EVENT_HIDE, this._pausedCallback, this);
        cc.game.off(cc.game.EVENT_SHOW, this._restoreCallback, this);
      },
      onDestroy: function() {
        this.stop();
        cc.audioEngine.uncache(this._clip);
      },
      play: function() {
        if (!this._clip) return;
        var volume = this._mute ? 0 : this._volume;
        var audio = this.audio;
        var loop = this._loop;
        if (audio._loaded) {
          audio.stop();
          audio.setCurrentTime(0);
          audio.play();
          return;
        }
        audio.src = this._clip;
        audio.once("load", (function() {
          audio.setLoop(loop);
          audio.setVolume(volume);
          audio.play();
        }));
        audio.preload();
      },
      stop: function() {
        this.audio && this.audio.stop();
      },
      pause: function() {
        this.audio && this.audio.pause();
      },
      resume: function() {
        this.audio && this.audio.resume();
      },
      rewind: function() {
        this.audio && this.audio.setCurrentTime(0);
      },
      getCurrentTime: function() {
        var time = 0;
        this.audio && (time = this.audio.getCurrentTime());
        return time;
      },
      setCurrentTime: function(time) {
        var audio = this.audio;
        if (!audio) return time;
        if (!audio._loaded) {
          audio.once("load", (function() {
            audio.setCurrentTime(time);
          }));
          return time;
        }
        audio.setCurrentTime(time);
        return time;
      },
      getDuration: function() {
        var time = 0;
        this.audio && (time = this.audio.getDuration());
        return time;
      }
    });
    cc.AudioSource = module.exports = AudioSource;
  }), {
    "./CCComponent": 76
  } ],
  73: [ (function(require, module, exports) {
    var BlockEvents = [ "touchstart", "touchmove", "touchend", "mousedown", "mousemove", "mouseup", "mouseenter", "mouseleave", "mousewheel" ];
    function stopPropagation(event) {
      event.stopPropagation();
    }
    var BlockInputEvents = cc.Class({
      name: "cc.BlockInputEvents",
      extends: require("./CCComponent"),
      editor: {
        menu: "i18n:MAIN_MENU.component.ui/Block Input Events",
        inspector: "packages://inspector/inspectors/comps/block-input-events.js",
        help: "i18n:COMPONENT.help_url.block-input-events"
      },
      onEnable: function() {
        for (var i = 0; i < BlockEvents.length; i++) this.node.on(BlockEvents[i], stopPropagation, this);
      },
      onDisable: function() {
        for (var i = 0; i < BlockEvents.length; i++) this.node.off(BlockEvents[i], stopPropagation, this);
      }
    });
    cc.BlockInputEvents = module.exports = BlockInputEvents;
  }), {
    "./CCComponent": 76
  } ],
  74: [ (function(require, module, exports) {
    var Transition = cc.Enum({
      NONE: 0,
      COLOR: 1,
      SPRITE: 2,
      SCALE: 3
    });
    var Button = cc.Class({
      name: "cc.Button",
      extends: require("./CCComponent"),
      ctor: function() {
        this._resetState();
        this._fromColor = null;
        this._toColor = null;
        this._time = 0;
        this._transitionFinished = true;
        this._fromScale = 1;
        this._toScale = 1;
        this._originalScale = 1;
        this._sprite = null;
        false;
      },
      _resetState: function() {
        this._pressed = false;
        this._hovered = false;
      },
      editor: false,
      properties: {
        interactable: {
          default: true,
          tooltip: (true, "i18n:COMPONENT.button.interactable"),
          notify: function(oldValue) {
            false;
            this._updateState();
            this.interactable || this._resetState();
          },
          animatable: false
        },
        _resizeToTarget: {
          animatable: false,
          set: function(value) {
            value && this._resizeNodeToTargetNode();
          }
        },
        enableAutoGrayEffect: {
          default: false,
          tooltip: (true, "i18n:COMPONENT.button.auto_gray_effect"),
          notify: function() {
            this._updateDisabledState();
          }
        },
        transition: {
          default: Transition.NONE,
          tooltip: (true, "i18n:COMPONENT.button.transition"),
          type: Transition,
          animatable: false
        },
        normalColor: {
          default: cc.color(214, 214, 214),
          displayName: "Normal",
          tooltip: (true, "i18n:COMPONENT.button.normal_color"),
          notify: function() {
            this._updateState();
          }
        },
        pressedColor: {
          default: cc.color(211, 211, 211),
          displayName: "Pressed",
          tooltip: (true, "i18n:COMPONENT.button.pressed_color")
        },
        hoverColor: {
          default: cc.Color.WHITE,
          displayName: "Hover",
          tooltip: (true, "i18n:COMPONENT.button.hover_color")
        },
        disabledColor: {
          default: cc.color(124, 124, 124),
          displayName: "Disabled",
          tooltip: (true, "i18n:COMPONENT.button.disabled_color"),
          notify: function() {
            this._updateState();
          }
        },
        duration: {
          default: .1,
          range: [ 0, 10 ],
          tooltip: (true, "i18n:COMPONENT.button.duration")
        },
        zoomScale: {
          default: 1.2,
          tooltip: (true, "i18n:COMPONENT.button.zoom_scale")
        },
        normalSprite: {
          default: null,
          type: cc.SpriteFrame,
          displayName: "Normal",
          tooltip: (true, "i18n:COMPONENT.button.normal_sprite"),
          notify: function() {
            this._updateState();
          }
        },
        pressedSprite: {
          default: null,
          type: cc.SpriteFrame,
          displayName: "Pressed",
          tooltip: (true, "i18n:COMPONENT.button.pressed_sprite"),
          formerlySerializedAs: "pressedSprite",
          notify: function() {
            this._updateState();
          }
        },
        hoverSprite: {
          default: null,
          type: cc.SpriteFrame,
          displayName: "Hover",
          tooltip: (true, "i18n:COMPONENT.button.hover_sprite"),
          formerlySerializedAs: "hoverSprite",
          notify: function() {
            this._updateState();
          }
        },
        disabledSprite: {
          default: null,
          type: cc.SpriteFrame,
          displayName: "Disabled",
          tooltip: (true, "i18n:COMPONENT.button.disabled_sprite"),
          notify: function() {
            this._updateState();
          }
        },
        target: {
          default: null,
          type: cc.Node,
          tooltip: (true, "i18n:COMPONENT.button.target"),
          notify: function() {
            this._applyTarget();
          }
        },
        clickEvents: {
          default: [],
          type: cc.Component.EventHandler,
          tooltip: (true, "i18n:COMPONENT.button.click_events")
        }
      },
      statics: {
        Transition: Transition
      },
      __preload: function() {
        this.target || (this.target = this.node);
        this._applyTarget();
        this._updateState();
      },
      onEnable: function() {
        this.normalSprite && this.normalSprite.ensureLoadTexture();
        this.hoverSprite && this.hoverSprite.ensureLoadTexture();
        this.pressedSprite && this.pressedSprite.ensureLoadTexture();
        this.disabledSprite && this.disabledSprite.ensureLoadTexture();
        true;
        this._registerEvent();
      },
      update: function(dt) {
        var target = this.target;
        if (this._transitionFinished) return;
        if (this.transition !== Transition.COLOR && this.transition !== Transition.SCALE) return;
        this.time += dt;
        var ratio = 1;
        this.duration > 0 && (ratio = this.time / this.duration);
        if (ratio >= 1) {
          ratio = 1;
          this._transitionFinished = true;
        }
        this.transition === Transition.COLOR ? target.color = this._fromColor.lerp(this._toColor, ratio) : this.transition === Transition.SCALE && (target.scale = cc.lerp(this._fromScale, this._toScale, ratio));
      },
      _registerEvent: function() {
        this.node.on(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this);
        this.node.on(cc.Node.EventType.TOUCH_MOVE, this._onTouchMove, this);
        this.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
        this.node.on(cc.Node.EventType.TOUCH_CANCEL, this._onTouchCancel, this);
        this.node.on(cc.Node.EventType.MOUSE_ENTER, this._onMouseMoveIn, this);
        this.node.on(cc.Node.EventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
      },
      _getTargetSprite: function(target) {
        var sprite = null;
        target && (sprite = target.getComponent(cc.Sprite));
        return sprite;
      },
      _applyTarget: function() {
        this._sprite = this._getTargetSprite(this.target);
        this.target && (this._originalScale = this.target.scale);
      },
      _onTouchBegan: function(event) {
        if (!this.interactable || !this.enabledInHierarchy) return;
        this._pressed = true;
        this._updateState();
        event.stopPropagation();
      },
      _onTouchMove: function(event) {
        if (!this.interactable || !this.enabledInHierarchy || !this._pressed) return;
        var touch = event.touch;
        var hit = this.node._hitTest(touch.getLocation());
        if (this.transition === Transition.SCALE && this.target) if (hit) {
          this._fromScale = this._originalScale;
          this._toScale = this._originalScale * this.zoomScale;
          this._transitionFinished = false;
        } else {
          this.time = 0;
          this._transitionFinished = true;
          this.target.scale = this._originalScale;
        } else {
          var state;
          state = hit ? "pressed" : "normal";
          this._applyTransition(state);
        }
        event.stopPropagation();
      },
      _onTouchEnded: function(event) {
        if (!this.interactable || !this.enabledInHierarchy) return;
        if (this._pressed) {
          cc.Component.EventHandler.emitEvents(this.clickEvents, event);
          this.node.emit("click", this);
        }
        this._pressed = false;
        this._updateState();
        event.stopPropagation();
      },
      _zoomUp: function() {
        this._fromScale = this._originalScale;
        this._toScale = this._originalScale * this.zoomScale;
        this.time = 0;
        this._transitionFinished = false;
      },
      _zoomBack: function() {
        this._fromScale = this.target.scale;
        this._toScale = this._originalScale;
        this.time = 0;
        this._transitionFinished = false;
      },
      _onTouchCancel: function() {
        if (!this.interactable || !this.enabledInHierarchy) return;
        this._pressed = false;
        this._updateState();
      },
      _onMouseMoveIn: function() {
        if (this._pressed || !this.interactable || !this.enabledInHierarchy) return;
        if (this.transition === Transition.SPRITE && !this.hoverSprite) return;
        if (!this._hovered) {
          this._hovered = true;
          this._updateState();
        }
      },
      _onMouseMoveOut: function() {
        if (this._hovered) {
          this._hovered = false;
          this._updateState();
        }
      },
      _updateState: function() {
        var state = this._getButtonState();
        this._applyTransition(state);
        this._updateDisabledState();
      },
      onDisable: function() {
        this._hovered = false;
        this._pressed = false;
        true;
        this.node.off(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this);
        this.node.off(cc.Node.EventType.TOUCH_MOVE, this._onTouchMove, this);
        this.node.off(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
        this.node.off(cc.Node.EventType.TOUCH_CANCEL, this._onTouchCancel, this);
        this.node.off(cc.Node.EventType.MOUSE_ENTER, this._onMouseMoveIn, this);
        this.node.off(cc.Node.EventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
      },
      _getButtonState: function() {
        var state;
        state = this.interactable ? this._pressed ? "pressed" : this._hovered ? "hover" : "normal" : "disabled";
        return state;
      },
      _updateColorTransition: function(state) {
        var color = this[state + "Color"];
        var target = this.target;
        false;
        this._fromColor = target.color.clone();
        this._toColor = color;
        this.time = 0;
        this._transitionFinished = false;
      },
      _updateSpriteTransition: function(state) {
        var sprite = this[state + "Sprite"];
        this._sprite && sprite && (this._sprite.spriteFrame = sprite);
      },
      _updateScaleTransition: function(state) {
        "pressed" === state ? this._zoomUp() : this._zoomBack();
      },
      _applyTransition: function(state) {
        var transition = this.transition;
        transition === Transition.COLOR ? this._updateColorTransition(state) : transition === Transition.SPRITE ? this._updateSpriteTransition(state) : transition === Transition.SCALE && this._updateScaleTransition(state);
      },
      _resizeNodeToTargetNode: false,
      _updateDisabledState: function() {
        this._sprite && this._sprite._sgNode.setState(0);
        this.enableAutoGrayEffect && this.transition !== Transition.COLOR && (this.transition === Transition.SPRITE && this.disabledSprite || this._sprite && !this.interactable && this._sprite._sgNode.setState(1));
      }
    });
    cc.Button = module.exports = Button;
  }), {
    "./CCComponent": 76
  } ],
  75: [ (function(require, module, exports) {
    var designResolutionWrapper = {
      getContentSize: function() {
        return cc.visibleRect;
      },
      setContentSize: function(size) {},
      _getWidth: function() {
        return this.getContentSize().width;
      },
      _getHeight: function() {
        return this.getContentSize().height;
      }
    };
    var Canvas = cc.Class({
      name: "cc.Canvas",
      extends: require("./CCComponent"),
      editor: false,
      resetInEditor: false,
      statics: {
        instance: null
      },
      properties: {
        _designResolution: cc.size(960, 640),
        designResolution: {
          get: function() {
            return cc.size(this._designResolution);
          },
          set: function(value) {
            this._designResolution.width = value.width;
            this._designResolution.height = value.height;
            this.applySettings();
          },
          tooltip: (true, "i18n:COMPONENT.canvas.design_resolution")
        },
        _fitWidth: false,
        _fitHeight: true,
        fitHeight: {
          get: function() {
            return this._fitHeight;
          },
          set: function(value) {
            if (this._fitHeight !== value) {
              this._fitHeight = value;
              this.applySettings();
            }
          },
          tooltip: (true, "i18n:COMPONENT.canvas.fit_height")
        },
        fitWidth: {
          get: function() {
            return this._fitWidth;
          },
          set: function(value) {
            if (this._fitWidth !== value) {
              this._fitWidth = value;
              this.applySettings();
            }
          },
          tooltip: (true, "i18n:COMPONENT.canvas.fit_width")
        }
      },
      ctor: function() {
        false;
        this._thisOnResized = this.onResized.bind(this);
      },
      __preload: function() {
        true;
        var Flags = cc.Object.Flags;
        this._objFlags |= Flags.IsPositionLocked | Flags.IsAnchorLocked | Flags.IsSizeLocked;
        if (Canvas.instance) return cc.errorID(6700, this.node.name, Canvas.instance.node.name);
        Canvas.instance = this;
        if (this.node._sizeProvider) {
          true;
          var renderer = this.node.getComponent(cc._RendererUnderSG);
          renderer ? cc.errorID(6701, cc.js.getClassName(renderer)) : cc.errorID(6702);
        } else this.node._sizeProvider = designResolutionWrapper;
        cc.director.on(cc.Director.EVENT_BEFORE_VISIT, this.alignWithScreen, this);
        false;
        true;
        cc.sys.isMobile ? window.addEventListener("resize", this._thisOnResized) : cc.eventManager.addCustomListener("canvas-resize", this._thisOnResized);
        this.applySettings();
        this.onResized();
      },
      onDestroy: function() {
        this.node._sizeProvider === designResolutionWrapper && (this.node._sizeProvider = null);
        cc.director.off(cc.Director.EVENT_BEFORE_VISIT, this.alignWithScreen, this);
        false;
        true;
        cc.sys.isMobile ? window.removeEventListener("resize", this._thisOnResized) : cc.eventManager.removeCustomListeners("canvas-resize", this._thisOnResized);
        Canvas.instance === this && (Canvas.instance = null);
      },
      alignWithScreen: function() {
        var designSize;
        false;
        var canvasSize = cc.visibleRect;
        var clipTopRight = !this.fitHeight && !this.fitWidth;
        var offsetX = 0;
        var offsetY = 0;
        if (clipTopRight) {
          designSize = cc.view.getDesignResolutionSize();
          offsetX = .5 * (designSize.width - canvasSize.width);
          offsetY = .5 * (designSize.height - canvasSize.height);
        }
        this.node.setPosition(.5 * canvasSize.width + offsetX, .5 * canvasSize.height + offsetY);
      },
      onResized: function() {
        this.alignWithScreen();
      },
      applySettings: function() {
        var ResolutionPolicy = cc.ResolutionPolicy;
        var policy;
        policy = this.fitHeight && this.fitWidth ? ResolutionPolicy.SHOW_ALL : this.fitHeight || this.fitWidth ? this.fitWidth ? ResolutionPolicy.FIXED_WIDTH : ResolutionPolicy.FIXED_HEIGHT : ResolutionPolicy.NO_BORDER;
        var designRes = this._designResolution;
        false;
        cc.view.setDesignResolutionSize(designRes.width, designRes.height, policy);
      }
    });
    cc.Canvas = module.exports = Canvas;
  }), {
    "./CCComponent": 76
  } ],
  76: [ (function(require, module, exports) {
    var CCObject = require("../platform/CCObject");
    var JS = require("../platform/js");
    var idGenerater = new (require("../platform/id-generater"))("Comp");
    var IsOnEnableCalled = CCObject.Flags.IsOnEnableCalled;
    var IsOnLoadCalled = CCObject.Flags.IsOnLoadCalled;
    var Component = cc.Class({
      name: "cc.Component",
      extends: CCObject,
      ctor: function() {
        this.__instanceId = cc.ClassManager.getNewInstanceId();
        this.__eventTargets = [];
      },
      properties: {
        node: {
          default: null,
          visible: false
        },
        name: {
          get: function() {
            if (this._name) return this._name;
            var className = cc.js.getClassName(this);
            var trimLeft = className.lastIndexOf(".");
            trimLeft >= 0 && (className = className.slice(trimLeft + 1));
            return this.node.name + "<" + className + ">";
          },
          set: function(value) {
            this._name = value;
          },
          visible: false
        },
        _id: {
          default: "",
          serializable: false
        },
        uuid: {
          get: function() {
            var id = this._id;
            if (!id) {
              id = this._id = idGenerater.getNewId();
              false, false;
            }
            return id;
          },
          visible: false
        },
        __scriptAsset: false,
        _enabled: true,
        enabled: {
          get: function() {
            return this._enabled;
          },
          set: function(value) {
            if (this._enabled !== value) {
              this._enabled = value;
              if (this.node._activeInHierarchy) {
                var compScheduler = cc.director._compScheduler;
                value ? compScheduler.enableComp(this) : compScheduler.disableComp(this);
              }
            }
          },
          visible: false
        },
        enabledInHierarchy: {
          get: function() {
            return (this._objFlags & IsOnEnableCalled) > 0;
          },
          visible: false
        },
        _isOnLoadCalled: {
          get: function() {
            return this._objFlags & IsOnLoadCalled;
          }
        }
      },
      update: null,
      lateUpdate: null,
      __preload: null,
      onLoad: null,
      start: null,
      onEnable: null,
      onDisable: null,
      onDestroy: null,
      onFocusInEditor: null,
      onLostFocusInEditor: null,
      resetInEditor: null,
      addComponent: function(typeOrClassName) {
        return this.node.addComponent(typeOrClassName);
      },
      getComponent: function(typeOrClassName) {
        return this.node.getComponent(typeOrClassName);
      },
      getComponents: function(typeOrClassName) {
        return this.node.getComponents(typeOrClassName);
      },
      getComponentInChildren: function(typeOrClassName) {
        return this.node.getComponentInChildren(typeOrClassName);
      },
      getComponentsInChildren: function(typeOrClassName) {
        return this.node.getComponentsInChildren(typeOrClassName);
      },
      _getLocalBounds: null,
      onRestore: null,
      destroy: function() {
        var depend;
        false;
        this._super() && this._enabled && this.node._activeInHierarchy && cc.director._compScheduler.disableComp(this);
      },
      _onPreDestroy: function() {
        this.unscheduleAllCallbacks();
        var eventTargets = this.__eventTargets;
        for (var i = 0, l = eventTargets.length; i < l; ++i) {
          var target = eventTargets[i];
          target && target.targetOff(this);
        }
        eventTargets.length = 0;
        false;
        cc.director._nodeActivator.destroyComp(this);
        this.node._removeComponent(this);
        false, false;
      },
      _instantiate: function(cloned) {
        cloned || (cloned = cc.instantiate._clone(this, this));
        cloned.node = null;
        return cloned;
      },
      isRunning: function() {
        return this.enabledInHierarchy;
      },
      schedule: function(callback, interval, repeat, delay) {
        cc.assertID(callback, 1619);
        cc.assertID(interval >= 0, 1620);
        interval = interval || 0;
        repeat = isNaN(repeat) ? cc.macro.REPEAT_FOREVER : repeat;
        delay = delay || 0;
        var scheduler = cc.director.getScheduler();
        var paused = scheduler.isTargetPaused(this);
        scheduler.schedule(callback, this, interval, repeat, delay, paused);
      },
      scheduleOnce: function(callback, delay) {
        this.schedule(callback, 0, 0, delay);
      },
      unschedule: function(callback_fn) {
        if (!callback_fn) return;
        cc.director.getScheduler().unschedule(callback_fn, this);
      },
      unscheduleAllCallbacks: function() {
        cc.director.getScheduler().unscheduleAllForTarget(this);
      }
    });
    Component._requireComponent = null;
    Component._executionOrder = 0;
    false, false;
    JS.value(Component, "_registerEditorProps", (function(cls, props) {
      var reqComp = props.requireComponent;
      reqComp && (cls._requireComponent = reqComp);
      var order = props.executionOrder;
      order && "number" === typeof order && (cls._executionOrder = order);
      var name;
      var key;
      var val;
      var willExecuteInEditMode;
      false, false;
    }));
    Component.prototype.__scriptUuid = "";
    cc.Component = module.exports = Component;
  }), {
    "../platform/CCObject": 181,
    "../platform/id-generater": 192,
    "../platform/js": 196
  } ],
  77: [ (function(require, module, exports) {
    cc.Component.EventHandler = cc.Class({
      name: "cc.ClickEvent",
      properties: {
        target: {
          default: null,
          type: cc.Node
        },
        component: {
          default: ""
        },
        handler: {
          default: ""
        },
        customEventData: {
          default: ""
        }
      },
      statics: {
        emitEvents: function(events) {
          "use strict";
          var args, i, l;
          if (arguments.length > 0) {
            args = new Array(arguments.length - 1);
            for (i = 0, l = args.length; i < l; i++) args[i] = arguments[i + 1];
          }
          for (i = 0, l = events.length; i < l; i++) {
            var event = events[i];
            if (!(event instanceof cc.Component.EventHandler)) continue;
            event.emit(args);
          }
        }
      },
      emit: function(params) {
        var target = this.target;
        if (!cc.isValid(target)) return;
        var comp = target.getComponent(this.component);
        if (!cc.isValid(comp)) return;
        var handler = comp[this.handler];
        if ("function" !== typeof handler) return;
        if (null != this.customEventData && "" !== this.customEventData) {
          params = params.slice();
          params.push(this.customEventData);
        }
        handler.apply(comp, params);
      }
    });
  }), {} ],
  78: [ (function(require, module, exports) {
    require("../editbox/CCSGEditBox");
    var KeyboardReturnType = _ccsg.EditBox.KeyboardReturnType;
    var InputMode = _ccsg.EditBox.InputMode;
    var InputFlag = _ccsg.EditBox.InputFlag;
    var EditBox = cc.Class({
      name: "cc.EditBox",
      extends: cc._RendererUnderSG,
      editor: false,
      properties: {
        _useOriginalSize: true,
        _string: "",
        string: {
          tooltip: (true, "i18n:COMPONENT.editbox.string"),
          get: function() {
            return this._sgNode.string;
          },
          set: function(value) {
            this._sgNode.string = this._string = value;
          }
        },
        backgroundImage: {
          tooltip: (true, "i18n:COMPONENT.editbox.backgroundImage"),
          default: null,
          type: cc.SpriteFrame,
          notify: function() {
            var sgNode = this._sgNode;
            var backgroundSprite = sgNode.getBackgroundSprite();
            if (this.backgroundImage) {
              var sprite = this._createBackgroundSprite();
              sprite.setContentSize(sgNode.getContentSize());
            } else backgroundSprite.removeFromParent();
          }
        },
        returnType: {
          default: KeyboardReturnType.DEFAULT,
          tooltip: (true, "i18n:COMPONENT.editbox.returnType"),
          displayName: "KeyboardReturnType",
          type: KeyboardReturnType,
          notify: function() {
            this._sgNode.returnType = this.returnType;
          }
        },
        inputFlag: {
          tooltip: (true, "i18n:COMPONENT.editbox.input_flag"),
          default: InputFlag.DEFAULT,
          type: InputFlag,
          notify: function() {
            this._sgNode.inputFlag = this.inputFlag;
          }
        },
        inputMode: {
          tooltip: (true, "i18n:COMPONENT.editbox.input_mode"),
          default: InputMode.ANY,
          type: InputMode,
          notify: function() {
            this._sgNode.inputMode = this.inputMode;
          }
        },
        fontSize: {
          tooltip: (true, "i18n:COMPONENT.editbox.font_size"),
          default: 20,
          notify: function() {
            this._sgNode.fontSize = this.fontSize;
          }
        },
        lineHeight: {
          tooltip: (true, "i18n:COMPONENT.editbox.line_height"),
          default: 40,
          notify: function() {
            this._sgNode.setLineHeight(this.lineHeight);
          }
        },
        fontColor: {
          tooltip: (true, "i18n:COMPONENT.editbox.font_color"),
          default: cc.Color.WHITE,
          notify: function() {
            this._sgNode.fontColor = this.fontColor;
          }
        },
        placeholder: {
          tooltip: (true, "i18n:COMPONENT.editbox.placeholder"),
          default: "Enter text here...",
          notify: function() {
            this._sgNode.placeholder = this.placeholder;
          }
        },
        placeholderFontSize: {
          tooltip: (true, "i18n:COMPONENT.editbox.placeholder_font_size"),
          default: 20,
          notify: function() {
            this._sgNode.placeholderFontSize = this.placeholderFontSize;
          }
        },
        placeholderFontColor: {
          tooltip: (true, "i18n:COMPONENT.editbox.placeholder_font_color"),
          default: cc.Color.GRAY,
          notify: function() {
            this._sgNode.placeholderFontColor = this.placeholderFontColor;
          }
        },
        maxLength: {
          tooltip: (true, "i18n:COMPONENT.editbox.max_length"),
          default: 20,
          notify: function() {
            this._sgNode.maxLength = this.maxLength;
          }
        },
        stayOnTop: {
          tooltip: (true, "i18n:COMPONENT.editbox.stay_on_top"),
          default: false,
          notify: function() {
            true;
            this._sgNode.stayOnTop(this.stayOnTop);
            this._sgNode.fontSize = this.fontSize;
            this._sgNode.fontColor = this.fontColor;
          }
        },
        _tabIndex: 0,
        tabIndex: {
          tooltip: (true, "i18n:COMPONENT.editbox.tab_index"),
          get: function() {
            return this._tabIndex;
          },
          set: function(value) {
            this._tabIndex = value;
            this._sgNode.setTabIndex(value);
          }
        },
        editingDidBegan: {
          default: [],
          type: cc.Component.EventHandler
        },
        textChanged: {
          default: [],
          type: cc.Component.EventHandler
        },
        editingDidEnded: {
          default: [],
          type: cc.Component.EventHandler
        },
        editingReturn: {
          default: [],
          type: cc.Component.EventHandler
        }
      },
      statics: {
        KeyboardReturnType: KeyboardReturnType,
        InputFlag: InputFlag,
        InputMode: InputMode
      },
      _applyCapInset: function(sprite) {
        var backgroundImage = this.backgroundImage;
        sprite.setInsetTop(backgroundImage.insetTop);
        sprite.setInsetBottom(backgroundImage.insetBottom);
        sprite.setInsetRight(backgroundImage.insetRight);
        sprite.setInsetLeft(backgroundImage.insetLeft);
      },
      _createSgNode: function() {
        return new _ccsg.EditBox(cc.size(160, 40));
      },
      _createBackgroundSprite: function() {
        var sgNode = this._sgNode;
        var bgSprite = new cc.Scale9Sprite();
        bgSprite.setRenderingType(cc.Scale9Sprite.RenderingType.SLICED);
        if (this.backgroundImage) {
          this.backgroundImage.ensureLoadTexture();
          bgSprite.setSpriteFrame(this.backgroundImage);
          this._applyCapInset(bgSprite);
        }
        sgNode.initWithSizeAndBackgroundSprite(cc.size(160, 40), bgSprite);
        return bgSprite;
      },
      _initSgNode: function() {
        var sgNode = this._sgNode;
        true;
        sgNode.createDomElementIfNeeded();
        this._createBackgroundSprite();
        false;
        sgNode.setContentSize(this.node.getContentSize());
        sgNode.inputMode = this.inputMode;
        sgNode.maxLength = this.maxLength;
        sgNode.string = this._string;
        sgNode.fontSize = this.fontSize;
        sgNode.fontColor = this.fontColor;
        sgNode.placeholder = this.placeholder;
        sgNode.placeholderFontSize = this.placeholderFontSize;
        sgNode.placeholderFontColor = this.placeholderFontColor;
        sgNode.inputFlag = this.inputFlag;
        sgNode.returnType = this.returnType;
        sgNode.setLineHeight(this.lineHeight);
        sgNode.stayOnTop(this.stayOnTop);
        sgNode.setTabIndex(this.tabIndex);
        sgNode.setDelegate(this);
      },
      editBoxEditingDidBegan: function() {
        cc.Component.EventHandler.emitEvents(this.editingDidBegan, this);
        this.node.emit("editing-did-began", this);
      },
      editBoxEditingDidEnded: function() {
        cc.Component.EventHandler.emitEvents(this.editingDidEnded, this);
        this.node.emit("editing-did-ended", this);
      },
      editBoxTextChanged: function(editBox, text) {
        cc.Component.EventHandler.emitEvents(this.textChanged, text, this);
        this.node.emit("text-changed", this);
      },
      editBoxEditingReturn: function() {
        cc.Component.EventHandler.emitEvents(this.editingReturn, this);
        this.node.emit("editing-return", this);
      },
      onDestroy: function() {
        this._sgNode.setDelegate(null);
        this._super();
      },
      __preload: function() {
        this._super();
        true;
        this._registerEvent();
      },
      _registerEvent: function() {
        true;
        this.node.on(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this);
        this.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
      },
      _onTouchBegan: function(event) {
        this._sgNode && this._sgNode._onTouchBegan(event.touch);
        event.stopPropagation();
      },
      _onTouchEnded: function(event) {
        this._sgNode && this._sgNode._onTouchEnded();
        event.stopPropagation();
      },
      setFocus: function() {
        this._sgNode && this._sgNode.setFocus();
      },
      isFocused: function() {
        var isFocused = false;
        this._sgNode && (isFocused = this._sgNode.isFocused());
        return isFocused;
      }
    });
    false;
    cc.EditBox = module.exports = EditBox;
  }), {
    "../editbox/CCSGEditBox": 105
  } ],
  79: [ (function(require, module, exports) {
    require("../label/CCSGLabel");
    require("../label/CCSGLabelCanvasRenderCmd");
    require("../label/CCSGLabelWebGLRenderCmd");
    var HorizontalAlign = cc.TextAlignment;
    var VerticalAlign = cc.VerticalTextAlignment;
    var Overflow = _ccsg.Label.Overflow;
    function debounce(func, wait, immediate) {
      var timeout;
      return function() {
        var context = this;
        var later = function() {
          timeout = null;
          immediate || func.apply(context, arguments);
        };
        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        callNow && func.apply(context, arguments);
      };
    }
    var Label = cc.Class({
      name: "cc.Label",
      extends: cc._RendererUnderSG,
      ctor: function() {
        false;
      },
      editor: false,
      _updateSgNodeString: function() {
        this._sgNode.setString(this.string);
        this._updateNodeSize();
      },
      _updateSgNodeFontSize: function() {
        if (this._sgNode) {
          this._sgNode.setFontSize(this._fontSize);
          this._updateNodeSize();
        }
      },
      properties: {
        _useOriginalSize: true,
        string: {
          default: "Label",
          multiline: true,
          tooltip: (true, "i18n:COMPONENT.label.string"),
          notify: function() {
            if (this._sgNode) {
              false;
              this._updateSgNodeString();
            }
          }
        },
        horizontalAlign: {
          default: HorizontalAlign.LEFT,
          type: HorizontalAlign,
          tooltip: (true, "i18n:COMPONENT.label.horizontal_align"),
          notify: function() {
            this._sgNode && this._sgNode.setHorizontalAlign(this.horizontalAlign);
          },
          animatable: false
        },
        verticalAlign: {
          default: VerticalAlign.TOP,
          type: VerticalAlign,
          tooltip: (true, "i18n:COMPONENT.label.vertical_align"),
          notify: function() {
            this._sgNode && this._sgNode.setVerticalAlign(this.verticalAlign);
          },
          animatable: false
        },
        _actualFontSize: {
          default: 40
        },
        actualFontSize: {
          displayName: "Actual Font Size",
          animatable: false,
          readonly: true,
          get: function() {
            this._sgNode && (this._actualFontSize = this._sgNode.getFontSize());
            return this._actualFontSize;
          }
        },
        _fontSize: 40,
        fontSize: {
          get: function() {
            return this._fontSize;
          },
          set: function(value) {
            this._fontSize = value;
            false;
            this._updateSgNodeFontSize();
          },
          tooltip: (true, "i18n:COMPONENT.label.font_size")
        },
        fontFamily: {
          default: "Arial",
          tooltip: (true, "i18n:COMPONENT.label.font_family"),
          notify: function() {
            this._sgNode && this._sgNode.setFontFamily(this.fontFamily);
          },
          animatable: false
        },
        _lineHeight: 40,
        lineHeight: {
          get: function() {
            this._sgNode && (this._lineHeight = this._sgNode.getLineHeight());
            return this._lineHeight;
          },
          set: function(value) {
            this._lineHeight = value;
            if (this._sgNode) {
              this._sgNode.setLineHeight(value);
              this._updateNodeSize();
            }
          },
          tooltip: (true, "i18n:COMPONENT.label.line_height")
        },
        overflow: {
          default: Overflow.NONE,
          type: Overflow,
          tooltip: (true, "i18n:COMPONENT.label.overflow"),
          notify: function() {
            if (this._sgNode) {
              this._sgNode.setOverflow(this.overflow);
              this._updateNodeSize();
            }
          },
          animatable: false
        },
        _enableWrapText: true,
        enableWrapText: {
          get: function() {
            this._sgNode && (this._enableWrapText = this._sgNode.isWrapTextEnabled());
            return this._enableWrapText;
          },
          set: function(value) {
            this._enableWrapText = value;
            this._sgNode && this._sgNode.enableWrapText(value);
          },
          animatable: false,
          tooltip: (true, "i18n:COMPONENT.label.wrap")
        },
        _N$file: null,
        font: {
          get: function() {
            return this._N$file;
          },
          set: function(value) {
            value || (this._isSystemFontUsed = true);
            false;
            this._N$file = value;
            this._bmFontOriginalSize = -1;
            value && this._isSystemFontUsed && (this._isSystemFontUsed = false);
            if (this._sgNode) {
              "string" === typeof value && cc.warnID(4e3);
              var font = this.font;
              if (font instanceof cc.BitmapFont) if (font.spriteFrame) {
                true;
                this._sgNode.setFontAsset(font);
              } else {
                cc.warnID(4011, font.name);
                this._sgNode.setFontFamily("");
              } else this._sgNode.setFontAsset(font);
            }
            value instanceof cc.BitmapFont && (this._bmFontOriginalSize = value.fontSize);
          },
          type: cc.Font,
          tooltip: (true, "i18n:COMPONENT.label.font"),
          animatable: false
        },
        _isSystemFontUsed: true,
        useSystemFont: {
          get: function() {
            return this._isSystemFontUsed;
          },
          set: function(value) {
            false;
            this._isSystemFontUsed = !!value;
            if (value) {
              this.font = null;
              this._sgNode && this._sgNode.setFontFamily(this.fontFamily);
            }
          },
          animatable: false,
          tooltip: (true, "i18n:COMPONENT.label.system_font")
        },
        _bmFontOriginalSize: {
          displayName: "BMFont Original Size",
          default: -1,
          serializable: false,
          readonly: true,
          visible: true,
          animatable: false
        },
        _spacingX: 0,
        spacingX: {
          get: function() {
            return this._spacingX;
          },
          set: function(value) {
            this._spacingX = value;
            if (this._sgNode) {
              this._sgNode.setSpacingX(this.spacingX);
              this._updateNodeSize();
            }
          }
        }
      },
      statics: {
        HorizontalAlign: HorizontalAlign,
        VerticalAlign: VerticalAlign,
        Overflow: Overflow
      },
      __preload: function() {
        this._super();
        true;
        this._sgNode.on("load", this._updateNodeSize, this);
        this._updateNodeSize();
      },
      _createSgNode: function() {
        return null;
      },
      _initSgNode: function() {
        var font = this.font;
        "string" === typeof font && cc.warnID(4e3);
        var sgNode;
        if (font instanceof cc.BitmapFont) if (font.spriteFrame) {
          false;
          sgNode = this._sgNode = _ccsg.Label.pool.get(this.string, font);
        } else {
          cc.warnID(4011, font.name);
          sgNode = this._sgNode = _ccsg.Label.pool.get(this.string);
        } else sgNode = this._sgNode = _ccsg.Label.pool.get(this.string, font, null, this._fontSize);
        false;
        font instanceof cc.BitmapFont && (this._bmFontOriginalSize = font.fontSize);
        sgNode.setVisible(false);
        sgNode.setHorizontalAlign(this.horizontalAlign);
        sgNode.setVerticalAlign(this.verticalAlign);
        sgNode.setFontSize(this._fontSize);
        this.useSystemFont && sgNode.setFontFamily(this.fontFamily);
        sgNode.setOverflow(this.overflow);
        sgNode.enableWrapText(this._enableWrapText);
        sgNode.setLineHeight(this._lineHeight);
        sgNode.setString(this.string);
        font instanceof cc.BitmapFont && sgNode.setSpacingX(this.spacingX);
        false;
        false;
        sgNode.setContentSize(this.node.getContentSize());
        sgNode.setColor(this.node.color);
      },
      _updateNodeSize: function() {
        var initialized = this._sgNode && this._sgNode.parent;
        initialized && (this.overflow !== Overflow.NONE && this.overflow !== Overflow.RESIZE_HEIGHT || this.node.setContentSize(this._sgNode.getContentSize()));
      },
      onDestroy: function() {
        var sgNodeBeforeDestroy = this._sgNode;
        this._super();
        if (sgNodeBeforeDestroy) {
          sgNodeBeforeDestroy.removeFromParent(true);
          _ccsg.Label.pool.put(sgNodeBeforeDestroy);
        }
      }
    });
    cc.Label = module.exports = Label;
  }), {
    "../label/CCSGLabel": 126,
    "../label/CCSGLabelCanvasRenderCmd": 127,
    "../label/CCSGLabelWebGLRenderCmd": 128
  } ],
  80: [ (function(require, module, exports) {
    var LabelOutline = cc.Class({
      name: "cc.LabelOutline",
      extends: require("./CCComponent"),
      editor: false,
      ctor: function() {
        this._labelSGNode = null;
      },
      properties: {
        _color: cc.color(255, 255, 255, 255),
        _width: 1,
        color: {
          get: function() {
            return this._color;
          },
          set: function(value) {
            this._color = cc.color(value);
            this._labelSGNode && this._labelSGNode.setOutlineColor(cc.color(this._color));
          }
        },
        width: {
          get: function() {
            return this._width;
          },
          set: function(value) {
            this._width = value;
            if (this._labelSGNode) {
              this._labelSGNode.setOutlineWidth(value);
              this._labelSGNode.setMargin(value);
            }
          }
        }
      },
      onEnable: function() {
        var label = this.node.getComponent("cc.Label");
        var sgNode = this._labelSGNode = label && label._sgNode;
        if (this._labelSGNode) {
          sgNode.setOutlined(true);
          sgNode.setOutlineColor(cc.color(this._color));
          sgNode.setOutlineWidth(this._width);
          sgNode.setMargin(this._width);
        }
      },
      onDisable: function() {
        if (this._labelSGNode) {
          this._labelSGNode.setOutlined(false);
          this._labelSGNode.setMargin(0);
        }
        this._labelSGNode = null;
      }
    });
    cc.LabelOutline = module.exports = LabelOutline;
  }), {
    "./CCComponent": 76
  } ],
  81: [ (function(require, module, exports) {
    var Type = cc.Enum({
      NONE: 0,
      HORIZONTAL: 1,
      VERTICAL: 2,
      GRID: 3
    });
    var ResizeMode = cc.Enum({
      NONE: 0,
      CONTAINER: 1,
      CHILDREN: 2
    });
    var AxisDirection = cc.Enum({
      HORIZONTAL: 0,
      VERTICAL: 1
    });
    var VerticalDirection = cc.Enum({
      BOTTOM_TO_TOP: 0,
      TOP_TO_BOTTOM: 1
    });
    var HorizontalDirection = cc.Enum({
      LEFT_TO_RIGHT: 0,
      RIGHT_TO_LEFT: 1
    });
    var Layout = cc.Class({
      name: "cc.Layout",
      extends: require("./CCComponent"),
      editor: false,
      properties: {
        _layoutSize: cc.size(300, 200),
        _layoutDirty: {
          default: true,
          serializable: false
        },
        _resize: ResizeMode.NONE,
        _N$layoutType: Type.NONE,
        type: {
          type: Type,
          get: function() {
            return this._N$layoutType;
          },
          set: function(value) {
            this._N$layoutType = value;
            var reLayouted;
            false;
            this._doLayoutDirty();
          },
          tooltip: (true, "i18n:COMPONENT.layout.layout_type"),
          animatable: false
        },
        resizeMode: {
          type: ResizeMode,
          tooltip: (true, "i18n:COMPONENT.layout.resize_mode"),
          animatable: false,
          get: function() {
            return this._resize;
          },
          set: function(value) {
            if (this.type === Type.NONE && value === ResizeMode.CHILDREN) return;
            this._resize = value;
            var reLayouted;
            false;
            this._doLayoutDirty();
          }
        },
        cellSize: {
          default: cc.size(40, 40),
          tooltip: (true, "i18n:COMPONENT.layout.cell_size"),
          type: cc.Size,
          notify: function() {
            this._doLayoutDirty();
          }
        },
        startAxis: {
          default: AxisDirection.HORIZONTAL,
          tooltip: (true, "i18n:COMPONENT.layout.start_axis"),
          type: AxisDirection,
          notify: function() {
            var reLayouted;
            false;
            this._doLayoutDirty();
          },
          animatable: false
        },
        _N$padding: {
          default: 0
        },
        paddingLeft: {
          default: 0,
          tooltip: (true, "i18n:COMPONENT.layout.padding_left"),
          notify: function() {
            this._doLayoutDirty();
          }
        },
        paddingRight: {
          default: 0,
          tooltip: (true, "i18n:COMPONENT.layout.padding_right"),
          notify: function() {
            this._doLayoutDirty();
          }
        },
        paddingTop: {
          default: 0,
          tooltip: (true, "i18n:COMPONENT.layout.padding_top"),
          notify: function() {
            this._doLayoutDirty();
          }
        },
        paddingBottom: {
          default: 0,
          tooltip: (true, "i18n:COMPONENT.layout.padding_bottom"),
          notify: function() {
            this._doLayoutDirty();
          }
        },
        spacingX: {
          default: 0,
          notify: function() {
            this._doLayoutDirty();
          },
          tooltip: (true, "i18n:COMPONENT.layout.space_x")
        },
        spacingY: {
          default: 0,
          notify: function() {
            this._doLayoutDirty();
          },
          tooltip: (true, "i18n:COMPONENT.layout.space_y")
        },
        verticalDirection: {
          default: VerticalDirection.TOP_TO_BOTTOM,
          type: VerticalDirection,
          notify: function() {
            this._doLayoutDirty();
          },
          tooltip: (true, "i18n:COMPONENT.layout.vertical_direction"),
          animatable: false
        },
        horizontalDirection: {
          default: HorizontalDirection.LEFT_TO_RIGHT,
          type: HorizontalDirection,
          notify: function() {
            this._doLayoutDirty();
          },
          tooltip: (true, "i18n:COMPONENT.layout.horizontal_direction"),
          animatable: false
        }
      },
      statics: {
        Type: Type,
        VerticalDirection: VerticalDirection,
        HorizontalDirection: HorizontalDirection,
        ResizeMode: ResizeMode,
        AxisDirection: AxisDirection
      },
      _migratePaddingData: function() {
        this.paddingLeft = this._N$padding;
        this.paddingRight = this._N$padding;
        this.paddingTop = this._N$padding;
        this.paddingBottom = this._N$padding;
        this._N$padding = 0;
      },
      onEnable: function() {
        this._addEventListeners();
        cc.sizeEqualToSize(this.node.getContentSize(), cc.size(0, 0)) && this.node.setContentSize(this._layoutSize);
        0 !== this._N$padding && this._migratePaddingData();
        this._doLayoutDirty();
      },
      onDisable: function() {
        this._removeEventListeners();
      },
      _doLayoutDirty: function() {
        this._layoutDirty = true;
      },
      _addEventListeners: function() {
        cc.director.on(cc.Director.EVENT_BEFORE_VISIT, this.updateLayout, this);
        this.node.on("size-changed", this._resized, this);
        this.node.on("anchor-changed", this._doLayoutDirty, this);
        this.node.on("child-added", this._childAdded, this);
        this.node.on("child-removed", this._childRemoved, this);
        this.node.on("child-reorder", this._doLayoutDirty, this);
        this._addChildrenEventListeners();
      },
      _removeEventListeners: function() {
        cc.director.off(cc.Director.EVENT_BEFORE_VISIT, this.updateLayout, this);
        this.node.off("size-changed", this._resized, this);
        this.node.off("anchor-changed", this._doLayoutDirty, this);
        this.node.off("child-added", this._childAdded, this);
        this.node.off("child-removed", this._childRemoved, this);
        this.node.off("child-reorder", this._doLayoutDirty, this);
        this._removeChildrenEventListeners();
      },
      _addChildrenEventListeners: function() {
        var children = this.node.children;
        children.forEach(function(child) {
          child.on("size-changed", this._doLayoutDirty, this);
          child.on("position-changed", this._doLayoutDirty, this);
          child.on("anchor-changed", this._doLayoutDirty, this);
          child.on("active-in-hierarchy-changed", this._doLayoutDirty, this);
        }.bind(this));
      },
      _removeChildrenEventListeners: function() {
        var children = this.node.children;
        children.forEach(function(child) {
          child.off("size-changed", this._doLayoutDirty, this);
          child.off("position-changed", this._doLayoutDirty, this);
          child.off("anchor-changed", this._doLayoutDirty, this);
          child.off("active-in-hierarchy-changed", this._doLayoutDirty, this);
        }.bind(this));
      },
      _childAdded: function(event) {
        var child = event.detail;
        child.on("size-changed", this._doLayoutDirty, this);
        child.on("position-changed", this._doLayoutDirty, this);
        child.on("anchor-changed", this._doLayoutDirty, this);
        child.on("active-in-hierarchy-changed", this._doLayoutDirty, this);
        this._doLayoutDirty();
      },
      _childRemoved: function(event) {
        var child = event.detail;
        child.off("size-changed", this._doLayoutDirty, this);
        child.off("position-changed", this._doLayoutDirty, this);
        child.off("anchor-changed", this._doLayoutDirty, this);
        child.off("active-in-hierarchy-changed", this._doLayoutDirty, this);
        this._doLayoutDirty();
      },
      _resized: function() {
        this._layoutSize = this.node.getContentSize();
        this._doLayoutDirty();
      },
      _doLayoutHorizontally: function(baseWidth, rowBreak, fnPositionY, applyChildren) {
        var layoutAnchor = this.node.getAnchorPoint();
        var children = this.node.children;
        var sign = 1;
        var paddingX = this.paddingLeft;
        var leftBoundaryOfLayout = -layoutAnchor.x * baseWidth;
        if (this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
          sign = -1;
          leftBoundaryOfLayout = (1 - layoutAnchor.x) * baseWidth;
          paddingX = this.paddingRight;
        }
        var nextX = leftBoundaryOfLayout + sign * paddingX - sign * this.spacingX;
        var rowMaxHeight = 0;
        var tempMaxHeight = 0;
        var secondMaxHeight = 0;
        var row = 0;
        var containerResizeBoundary = 0;
        var maxHeightChildAnchorY = 0;
        var newChildWidth = this.cellSize.width;
        this.type !== Type.GRID && this.resizeMode === ResizeMode.CHILDREN && (newChildWidth = (baseWidth - (this.paddingLeft + this.paddingRight) - (children.length - 1) * this.spacingX) / children.length);
        children.forEach(function(child) {
          if (!child.activeInHierarchy) return;
          if (this._resize === ResizeMode.CHILDREN) {
            child.width = newChildWidth;
            this.type === Type.GRID && (child.height = this.cellSize.height);
          }
          var anchorX = child.anchorX;
          secondMaxHeight > tempMaxHeight && (tempMaxHeight = secondMaxHeight);
          if (child.height >= tempMaxHeight) {
            secondMaxHeight = tempMaxHeight;
            tempMaxHeight = child.height;
            maxHeightChildAnchorY = child.getAnchorPoint().y;
          }
          this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && (anchorX = 1 - child.anchorX);
          nextX = nextX + sign * anchorX * child.width + sign * this.spacingX;
          var rightBoundaryOfChild = sign * (1 - anchorX) * child.width;
          if (rowBreak) {
            var rowBreakBoundary = nextX + rightBoundaryOfChild + sign * (sign > 0 ? this.paddingRight : this.paddingLeft);
            var leftToRightRowBreak = this.horizontalDirection === HorizontalDirection.LEFT_TO_RIGHT && rowBreakBoundary > (1 - layoutAnchor.x) * baseWidth;
            var rightToLeftRowBreak = this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && rowBreakBoundary < -layoutAnchor.x * baseWidth;
            if (leftToRightRowBreak || rightToLeftRowBreak) {
              if (child.height >= tempMaxHeight) {
                0 === secondMaxHeight && (secondMaxHeight = tempMaxHeight);
                rowMaxHeight += secondMaxHeight;
                secondMaxHeight = tempMaxHeight;
              } else {
                rowMaxHeight += tempMaxHeight;
                secondMaxHeight = child.height;
                tempMaxHeight = 0;
              }
              nextX = leftBoundaryOfLayout + sign * (paddingX + anchorX * child.width);
              row++;
            }
          }
          var finalPositionY = fnPositionY(child, rowMaxHeight, row);
          baseWidth >= child.width + this.paddingLeft + this.paddingRight && applyChildren && child.setPosition(cc.p(nextX, finalPositionY));
          var signX = 1;
          var tempFinalPositionY;
          var topMarign = 0 === tempMaxHeight ? child.height : tempMaxHeight;
          if (this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
            containerResizeBoundary = containerResizeBoundary || this.node._contentSize.height;
            signX = -1;
            tempFinalPositionY = finalPositionY + signX * (topMarign * maxHeightChildAnchorY + this.paddingBottom);
            tempFinalPositionY < containerResizeBoundary && (containerResizeBoundary = tempFinalPositionY);
          } else {
            containerResizeBoundary = containerResizeBoundary || -this.node._contentSize.height;
            tempFinalPositionY = finalPositionY + signX * (topMarign * maxHeightChildAnchorY + this.paddingTop);
            tempFinalPositionY > containerResizeBoundary && (containerResizeBoundary = tempFinalPositionY);
          }
          nextX += rightBoundaryOfChild;
        }.bind(this));
        return containerResizeBoundary;
      },
      _getVerticalBaseHeight: function(children) {
        var newHeight = 0;
        var activeChildCount = 0;
        if (this.resizeMode === ResizeMode.CONTAINER) {
          children.forEach((function(child) {
            if (!child.activeInHierarchy) return;
            activeChildCount++;
            newHeight += child.height;
          }));
          newHeight += (activeChildCount - 1) * this.spacingY + this.paddingBottom + this.paddingTop;
        } else newHeight = this.node.getContentSize().height;
        return newHeight;
      },
      _doLayoutVertically: function(baseHeight, columnBreak, fnPositionX, applyChildren) {
        var layoutAnchor = this.node.getAnchorPoint();
        var children = this.node.children;
        var sign = 1;
        var paddingY = this.paddingBottom;
        var bottomBoundaryOfLayout = -layoutAnchor.y * baseHeight;
        if (this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
          sign = -1;
          bottomBoundaryOfLayout = (1 - layoutAnchor.y) * baseHeight;
          paddingY = this.paddingTop;
        }
        var nextY = bottomBoundaryOfLayout + sign * paddingY - sign * this.spacingY;
        var columnMaxWidth = 0;
        var tempMaxWidth = 0;
        var secondMaxWidth = 0;
        var column = 0;
        var containerResizeBoundary = 0;
        var maxWidthChildAnchorX = 0;
        var newChildHeight = this.cellSize.height;
        this.type !== Type.GRID && this.resizeMode === ResizeMode.CHILDREN && (newChildHeight = (baseHeight - (this.paddingTop + this.paddingBottom) - (children.length - 1) * this.spacingY) / children.length);
        children.forEach(function(child) {
          if (!child.activeInHierarchy) return;
          if (this.resizeMode === ResizeMode.CHILDREN) {
            child.height = newChildHeight;
            this.type === Type.GRID && (child.width = this.cellSize.width);
          }
          var anchorY = child.anchorY;
          secondMaxWidth > tempMaxWidth && (tempMaxWidth = secondMaxWidth);
          if (child.width >= tempMaxWidth) {
            secondMaxWidth = tempMaxWidth;
            tempMaxWidth = child.width;
            maxWidthChildAnchorX = child.getAnchorPoint().x;
          }
          this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM && (anchorY = 1 - child.anchorY);
          nextY = nextY + sign * anchorY * child.height + sign * this.spacingY;
          var topBoundaryOfChild = sign * (1 - anchorY) * child.height;
          if (columnBreak) {
            var columnBreakBoundary = nextY + topBoundaryOfChild + sign * (sign > 0 ? this.paddingTop : this.paddingBottom);
            var bottomToTopColumnBreak = this.verticalDirection === VerticalDirection.BOTTOM_TO_TOP && columnBreakBoundary > (1 - layoutAnchor.y) * baseHeight;
            var topToBottomColumnBreak = this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM && columnBreakBoundary < -layoutAnchor.y * baseHeight;
            if (bottomToTopColumnBreak || topToBottomColumnBreak) {
              if (child.width >= tempMaxWidth) {
                0 === secondMaxWidth && (secondMaxWidth = tempMaxWidth);
                columnMaxWidth += secondMaxWidth;
                secondMaxWidth = tempMaxWidth;
              } else {
                columnMaxWidth += tempMaxWidth;
                secondMaxWidth = child.width;
                tempMaxWidth = 0;
              }
              nextY = bottomBoundaryOfLayout + sign * (paddingY + anchorY * child.height);
              column++;
            }
          }
          var finalPositionX = fnPositionX(child, columnMaxWidth, column);
          baseHeight >= child.height + (this.paddingTop + this.paddingBottom) && applyChildren && child.setPosition(cc.p(finalPositionX, nextY));
          var signX = 1;
          var tempFinalPositionX;
          var rightMarign = 0 === tempMaxWidth ? child.width : tempMaxWidth;
          if (this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
            signX = -1;
            containerResizeBoundary = containerResizeBoundary || this.node._contentSize.width;
            tempFinalPositionX = finalPositionX + signX * (rightMarign * maxWidthChildAnchorX + this.paddingLeft);
            tempFinalPositionX < containerResizeBoundary && (containerResizeBoundary = tempFinalPositionX);
          } else {
            containerResizeBoundary = containerResizeBoundary || -this.node._contentSize.width;
            tempFinalPositionX = finalPositionX + signX * (rightMarign * maxWidthChildAnchorX + this.paddingRight);
            tempFinalPositionX > containerResizeBoundary && (containerResizeBoundary = tempFinalPositionX);
          }
          nextY += topBoundaryOfChild;
        }.bind(this));
        return containerResizeBoundary;
      },
      _doLayoutBasic: function() {
        var children = this.node.children;
        var allChildrenBoundingBox = null;
        children.forEach((function(child) {
          if (!child.activeInHierarchy) return;
          allChildrenBoundingBox = allChildrenBoundingBox ? cc.rectUnion(allChildrenBoundingBox, child.getBoundingBoxToWorld()) : child.getBoundingBoxToWorld();
        }));
        if (allChildrenBoundingBox) {
          var leftBottomInParentSpace = this.node.parent.convertToNodeSpaceAR(cc.p(allChildrenBoundingBox.x, allChildrenBoundingBox.y));
          leftBottomInParentSpace = cc.pAdd(leftBottomInParentSpace, cc.p(-this.paddingLeft, -this.paddingBottom));
          var rightTopInParentSpace = this.node.parent.convertToNodeSpaceAR(cc.p(allChildrenBoundingBox.x + allChildrenBoundingBox.width, allChildrenBoundingBox.y + allChildrenBoundingBox.height));
          rightTopInParentSpace = cc.pAdd(rightTopInParentSpace, cc.p(this.paddingRight, this.paddingTop));
          var newSize = cc.size(parseFloat((rightTopInParentSpace.x - leftBottomInParentSpace.x).toFixed(2)), parseFloat((rightTopInParentSpace.y - leftBottomInParentSpace.y).toFixed(2)));
          var layoutPosition = this.node.getPosition();
          var newAnchorX = (layoutPosition.x - leftBottomInParentSpace.x) / newSize.width;
          var newAnchorY = (layoutPosition.y - leftBottomInParentSpace.y) / newSize.height;
          var newAnchor = cc.p(parseFloat(newAnchorX.toFixed(2)), parseFloat(newAnchorY.toFixed(2)));
          this.node.setAnchorPoint(newAnchor);
          this.node.setContentSize(newSize);
        }
      },
      _doLayoutGridAxisHorizontal: function(layoutAnchor, layoutSize) {
        var baseWidth = layoutSize.width;
        var sign = 1;
        var bottomBoundaryOfLayout = -layoutAnchor.y * layoutSize.height;
        var paddingY = this.paddingBottom;
        if (this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
          sign = -1;
          bottomBoundaryOfLayout = (1 - layoutAnchor.y) * layoutSize.height;
          paddingY = this.paddingTop;
        }
        var fnPositionY = function(child, topOffset, row) {
          return bottomBoundaryOfLayout + sign * (topOffset + child.anchorY * child.height + paddingY + row * this.spacingY);
        }.bind(this);
        var newHeight = 0;
        if (this.resizeMode === ResizeMode.CONTAINER) {
          var boundary = this._doLayoutHorizontally(baseWidth, true, fnPositionY, false);
          newHeight = bottomBoundaryOfLayout - boundary;
          newHeight < 0 && (newHeight *= -1);
          bottomBoundaryOfLayout = -layoutAnchor.y * newHeight;
          if (this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
            sign = -1;
            bottomBoundaryOfLayout = (1 - layoutAnchor.y) * newHeight;
          }
        }
        this._doLayoutHorizontally(baseWidth, true, fnPositionY, true);
        this.resizeMode === ResizeMode.CONTAINER && this.node.setContentSize(baseWidth, newHeight);
      },
      _doLayoutGridAxisVertical: function(layoutAnchor, layoutSize) {
        var baseHeight = layoutSize.height;
        var sign = 1;
        var leftBoundaryOfLayout = -layoutAnchor.x * layoutSize.width;
        var paddingX = this.paddingLeft;
        if (this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
          sign = -1;
          leftBoundaryOfLayout = (1 - layoutAnchor.x) * layoutSize.width;
          paddingX = this.paddingRight;
        }
        var fnPositionX = function(child, leftOffset, column) {
          return leftBoundaryOfLayout + sign * (leftOffset + child.anchorX * child.width + paddingX + column * this.spacingX);
        }.bind(this);
        var newWidth = 0;
        if (this.resizeMode === ResizeMode.CONTAINER) {
          var boundary = this._doLayoutVertically(baseHeight, true, fnPositionX, false);
          newWidth = leftBoundaryOfLayout - boundary;
          newWidth < 0 && (newWidth *= -1);
          leftBoundaryOfLayout = -layoutAnchor.x * newWidth;
          if (this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
            sign = -1;
            leftBoundaryOfLayout = (1 - layoutAnchor.x) * newWidth;
          }
        }
        this._doLayoutVertically(baseHeight, true, fnPositionX, true);
        this.resizeMode === ResizeMode.CONTAINER && this.node.setContentSize(newWidth, baseHeight);
      },
      _doLayoutGrid: function() {
        var layoutAnchor = this.node.getAnchorPoint();
        var layoutSize = this.node.getContentSize();
        this.startAxis === AxisDirection.HORIZONTAL ? this._doLayoutGridAxisHorizontal(layoutAnchor, layoutSize) : this.startAxis === AxisDirection.VERTICAL && this._doLayoutGridAxisVertical(layoutAnchor, layoutSize);
      },
      _getHorizontalBaseWidth: function(children) {
        var newWidth = 0;
        var activeChildCount = 0;
        if (this.resizeMode === ResizeMode.CONTAINER) {
          children.forEach((function(child) {
            if (!child.activeInHierarchy) return;
            activeChildCount++;
            newWidth += child.width;
          }));
          newWidth += (activeChildCount - 1) * this.spacingX + this.paddingLeft + this.paddingRight;
        } else newWidth = this.node.getContentSize().width;
        return newWidth;
      },
      _doLayout: function() {
        if (this.type === Type.HORIZONTAL) {
          var newWidth = this._getHorizontalBaseWidth(this.node.children);
          var fnPositionY = function(child) {
            return child.y;
          };
          this._doLayoutHorizontally(newWidth, false, fnPositionY, true);
          this.node.width = newWidth;
        } else if (this.type === Type.VERTICAL) {
          var newHeight = this._getVerticalBaseHeight(this.node.children);
          var fnPositionX = function(child) {
            return child.x;
          };
          this._doLayoutVertically(newHeight, false, fnPositionX, true);
          this.node.height = newHeight;
        } else this.type === Type.NONE ? this.resizeMode === ResizeMode.CONTAINER && this._doLayoutBasic() : this.type === Type.GRID && this._doLayoutGrid();
      },
      updateLayout: function() {
        if (this._layoutDirty && this.node.children.length > 0) {
          this._doLayout();
          this._layoutDirty = false;
        }
      }
    });
    Object.defineProperty(Layout.prototype, "padding", {
      get: function() {
        cc.warnID(4100);
        return this.paddingLeft;
      },
      set: function(value) {
        this._N$padding = value;
        this._migratePaddingData();
        this._doLayoutDirty();
      }
    });
    cc.Layout = module.exports = Layout;
  }), {
    "./CCComponent": 76
  } ],
  82: [ (function(require, module, exports) {
    require("../../clipping-nodes/CCClippingNode");
    require("../../clipping-nodes/CCClippingNodeCanvasRenderCmd");
    require("../../clipping-nodes/CCClippingNodeWebGLRenderCmd");
    require("../../shape-nodes/CCDrawNode");
    var Base = cc._RendererInSG;
    var MaskType = cc.Enum({
      RECT: 0,
      ELLIPSE: 1,
      IMAGE_STENCIL: 2
    });
    var SEGEMENTS_MIN = 3;
    var SEGEMENTS_MAX = 1e4;
    var Mask = cc.Class({
      name: "cc.Mask",
      extends: Base,
      editor: false,
      properties: {
        _clippingStencil: {
          default: null,
          serializable: false
        },
        _type: MaskType.RECT,
        type: {
          get: function() {
            return this._type;
          },
          set: function(value) {
            this._type = value;
            this._refreshStencil();
          },
          type: MaskType,
          tooltip: (true, "i18n:COMPONENT.mask.type")
        },
        spriteFrame: {
          default: null,
          type: cc.SpriteFrame,
          tooltip: (true, "i18n:COMPONENT.mask.spriteFrame"),
          notify: function() {
            this._refreshStencil();
          }
        },
        alphaThreshold: {
          default: 1,
          type: cc.Float,
          range: [ 0, 1, .1 ],
          slide: true,
          tooltip: (true, "i18n:COMPONENT.mask.alphaThreshold"),
          notify: function() {
            if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
              cc.warnID(4201);
              return;
            }
            this._sgNode.setAlphaThreshold(this.alphaThreshold);
          }
        },
        inverted: {
          default: false,
          type: cc.Boolean,
          tooltip: (true, "i18n:COMPONENT.mask.inverted"),
          notify: function() {
            if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
              cc.warnID(4202);
              return;
            }
            this._sgNode.setInverted(this.inverted);
          }
        },
        _segements: 64,
        segements: {
          get: function() {
            return this._segements;
          },
          set: function(value) {
            this._segements = cc.clampf(value, SEGEMENTS_MIN, SEGEMENTS_MAX);
            this._refreshStencil();
          },
          tooltip: (true, "i18n:COMPONENT.mask.segements")
        },
        _resizeToTarget: {
          animatable: false,
          set: function(value) {
            value && this._resizeNodeToTargetNode();
          }
        }
      },
      statics: {
        Type: MaskType
      },
      _resizeNodeToTargetNode: false,
      _initSgNode: function() {},
      _createSgNode: function() {
        return new cc.ClippingNode();
      },
      _hitTest: function(point) {
        var size = this.node.getContentSize(), w = size.width, h = size.height, trans = this.node.getNodeToWorldTransform();
        if (this.type === MaskType.RECT || this.type === MaskType.IMAGE_STENCIL) {
          var rect = cc.rect(0, 0, w, h);
          cc._rectApplyAffineTransformIn(rect, trans);
          var left = point.x - rect.x, right = rect.x + rect.width - point.x, bottom = point.y - rect.y, top = rect.y + rect.height - point.y;
          return left >= 0 && right >= 0 && top >= 0 && bottom >= 0;
        }
        if (this.type === MaskType.ELLIPSE) {
          var a = w / 2, b = h / 2;
          var cx = trans.a * a + trans.c * b + trans.tx;
          var cy = trans.b * a + trans.d * b + trans.ty;
          var px = point.x - cx, py = point.y - cy;
          return px * px / (a * a) + py * py / (b * b) < 1;
        }
      },
      onEnable: function() {
        this._super();
        this.spriteFrame && this.spriteFrame.ensureLoadTexture();
        this._refreshStencil();
        this.node.on("size-changed", this._refreshStencil, this);
        this.node.on("anchor-changed", this._refreshStencil, this);
      },
      onDisable: function() {
        this._super();
        this.node.off("size-changed", this._refreshStencil, this);
        this.node.off("anchor-changed", this._refreshStencil, this);
      },
      _calculateCircle: function(center, radius, segements) {
        var polies = [];
        var anglePerStep = 2 * Math.PI / segements;
        for (var step = 0; step < segements; ++step) polies.push(cc.v2(radius.x * Math.cos(anglePerStep * step) + center.x, radius.y * Math.sin(anglePerStep * step) + center.y));
        return polies;
      },
      _refreshStencil: function() {
        if (this.type === MaskType.IMAGE_STENCIL && cc._renderType !== cc.game.RENDER_TYPE_WEBGL && true) {
          cc.warnID(4200);
          return;
        }
        var contentSize = this.node.getContentSize();
        var anchorPoint = this.node.getAnchorPoint();
        var stencil = this._clippingStencil;
        if (this._type === MaskType.IMAGE_STENCIL) {
          var isSgSprite = stencil instanceof cc.Scale9Sprite;
          if (!isSgSprite || stencil._spriteFrame !== this.spriteFrame) {
            stencil = new cc.Scale9Sprite();
            stencil.setSpriteFrame(this.spriteFrame);
            this._sgNode.setStencil(stencil);
          }
          stencil.setContentSize(contentSize);
          stencil.setAnchorPoint(anchorPoint);
          this._sgNode.setAlphaThreshold(this.alphaThreshold);
        } else {
          var isDrawNode = stencil instanceof cc.DrawNode;
          if (!isDrawNode) {
            stencil = new cc.DrawNode();
            false;
            this._sgNode.setStencil(stencil);
          }
          var width = contentSize.width;
          var height = contentSize.height;
          var x = -width * anchorPoint.x;
          var y = -height * anchorPoint.y;
          var color = cc.color(255, 255, 255, 0);
          stencil.clear();
          if (this._type === MaskType.RECT) {
            var rectangle = [ cc.v2(x, y), cc.v2(x + width, y), cc.v2(x + width, y + height), cc.v2(x, y + height) ];
            stencil.drawPoly(rectangle, color, 0, color);
          } else if (this._type === MaskType.ELLIPSE) {
            var center = cc.v2(x + width / 2, y + height / 2);
            var radius = {
              x: width / 2,
              y: height / 2
            };
            stencil.drawPoly(this._calculateCircle(center, radius, this._segements), color, 0, color);
          }
        }
        this._sgNode.setInverted(this.inverted);
        this._clippingStencil = stencil;
        true;
        cc.renderer.childrenOrderDirty = true;
      }
    });
    false;
    cc.Mask = module.exports = Mask;
  }), {
    "../../clipping-nodes/CCClippingNode": 25,
    "../../clipping-nodes/CCClippingNodeCanvasRenderCmd": 26,
    "../../clipping-nodes/CCClippingNodeWebGLRenderCmd": 27,
    "../../shape-nodes/CCDrawNode": 274
  } ],
  83: [ (function(require, module, exports) {
    var SizeMode = cc.Enum({
      Unified: 0,
      Free: 1
    });
    var Direction = cc.Enum({
      Horizontal: 0,
      Vertical: 1
    });
    var EventType = cc.Enum({
      PAGE_TURNING: 0
    });
    var PageView = cc.Class({
      name: "cc.PageView",
      extends: cc.ScrollView,
      editor: false,
      ctor: function() {
        this._curPageIdx = 0;
        this._lastPageIdx = 0;
        this._pages = [];
        this._scrollCenterOffsetX = [];
        this._scrollCenterOffsetY = [];
      },
      properties: {
        sizeMode: {
          default: SizeMode.Unified,
          type: SizeMode,
          tooltip: (true, "i18n:COMPONENT.pageview.sizeMode"),
          notify: function() {
            this._syncSizeMode();
          }
        },
        direction: {
          default: Direction.Horizontal,
          type: Direction,
          tooltip: (true, "i18n:COMPONENT.pageview.direction"),
          notify: function() {
            this._syncScrollDirection();
          }
        },
        scrollThreshold: {
          default: .5,
          type: cc.Float,
          slide: true,
          range: [ 0, 1, .01 ],
          tooltip: (true, "i18n:COMPONENT.pageview.scrollThreshold")
        },
        autoPageTurningThreshold: {
          default: 100,
          type: cc.Float,
          tooltip: (true, "i18n:COMPONENT.pageview.autoPageTurningThreshold")
        },
        pageTurningEventTiming: {
          default: .1,
          type: cc.Float,
          range: [ 0, 1, .01 ],
          tooltip: (true, "i18n:COMPONENT.pageview.pageTurningEventTiming")
        },
        indicator: {
          default: null,
          type: cc.PageViewIndicator,
          tooltip: (true, "i18n:COMPONENT.pageview.indicator"),
          notify: function() {
            this.indicator && this.indicator.setPageView(this);
          }
        },
        pageTurningSpeed: {
          default: .3,
          type: cc.Float,
          tooltip: (true, "i18n:COMPONENT.pageview.pageTurningSpeed")
        },
        pageEvents: {
          default: [],
          type: cc.Component.EventHandler,
          tooltip: (true, "i18n:COMPONENT.pageview.pageEvents")
        }
      },
      statics: {
        SizeMode: SizeMode,
        Direction: Direction,
        EventType: EventType
      },
      __preload: function() {
        this.node.on("size-changed", this._updateAllPagesSize, this);
      },
      onEnable: function() {
        this._super();
        true;
        this.node.on("scroll-ended-with-threshold", this._dispatchPageTurningEvent, this);
      },
      onDisable: function() {
        this._super();
        true;
        this.node.off("scroll-ended-with-threshold", this._dispatchPageTurningEvent, this);
      },
      onLoad: function() {
        this._initPages();
        this.indicator && this.indicator.setPageView(this);
      },
      onDestroy: function() {
        this.node.off("size-changed", this._updateAllPagesSize, this);
      },
      getCurrentPageIndex: function() {
        return this._curPageIdx;
      },
      setCurrentPageIndex: function(index) {
        this.scrollToPage(index, true);
      },
      getPages: function() {
        return this._pages;
      },
      addPage: function(page) {
        if (!page || -1 !== this._pages.indexOf(page) || !this.content) return;
        this.content.addChild(page);
        this._pages.push(page);
        this._updatePageView();
      },
      insertPage: function(page, index) {
        if (index < 0 || !page || -1 !== this._pages.indexOf(page) || !this.content) return;
        var pageCount = this._pages.length;
        if (index >= pageCount) this.addPage(page); else {
          this._pages.splice(index, 0, page);
          this.content.addChild(page);
          this._updatePageView();
        }
      },
      removePage: function(page) {
        if (!page || !this.content) return;
        var index = this._pages.indexOf(page);
        if (-1 === index) {
          cc.warnID(4300, page.name);
          return;
        }
        this.removePageAtIndex(index);
      },
      removePageAtIndex: function(index) {
        var pageList = this._pages;
        if (index < 0 || index >= pageList.length) return;
        var page = pageList[index];
        if (!page) return;
        this.content.removeChild(page);
        pageList.splice(index, 1);
        this._updatePageView();
      },
      removeAllPages: function() {
        if (!this.content) return;
        var locPages = this._pages;
        for (var i = 0, len = locPages.length; i < len; i++) this.content.removeChild(locPages[i]);
        this._pages.length = 0;
        this._updatePageView();
      },
      scrollToPage: function(idx, timeInSecond) {
        if (idx < 0 || idx >= this._pages.length) return;
        timeInSecond = void 0 !== timeInSecond ? timeInSecond : .3;
        this._curPageIdx = idx;
        this.scrollToOffset(this._moveOffsetValue(idx), timeInSecond, true);
        this.indicator && this.indicator._changedState();
      },
      getScrollEndedEventTiming: function() {
        return this.pageTurningEventTiming;
      },
      _syncScrollDirection: function() {
        this.horizontal = this.direction === Direction.Horizontal;
        this.vertical = this.direction === Direction.Vertical;
      },
      _syncSizeMode: function() {
        if (!this.content) return;
        var layout = this.content.getComponent(cc.Layout);
        if (layout) {
          if (0 === this._pages.length) layout.padding = 0; else {
            var lastPage = this._pages[this._pages.length - 1];
            if (this.sizeMode === SizeMode.Free) if (this.direction === Direction.Horizontal) {
              layout.paddingLeft = (this.node.width - this._pages[0].width) / 2;
              layout.paddingRight = (this.node.width - lastPage.width) / 2;
            } else if (this.direction === Direction.Vertical) {
              layout.paddingTop = (this.node.height - this._pages[0].height) / 2;
              layout.paddingBottom = (this.node.height - lastPage.height) / 2;
            }
          }
          layout.updateLayout();
        }
      },
      _updatePageView: function() {
        var pageCount = this._pages.length;
        if (this._curPageIdx >= pageCount) {
          this._curPageIdx = 0 === pageCount ? 0 : pageCount - 1;
          this._lastPageIdx = this._curPageIdx;
        }
        for (var i = 0; i < pageCount; ++i) {
          this._pages[i].setSiblingIndex(i);
          this.direction === Direction.Horizontal ? this._scrollCenterOffsetX[i] = Math.abs(this.content.x + this._pages[i].x) : this._scrollCenterOffsetY[i] = Math.abs(this.content.y + this._pages[i].y);
        }
        var layout = this.content.getComponent(cc.Layout);
        layout && layout.enabled && layout.updateLayout();
        this.indicator && this.indicator._refresh();
      },
      _updateAllPagesSize: function() {
        if (this.sizeMode !== SizeMode.Unified) return;
        var locPages = this._pages;
        var selfSize = this.node.getContentSize();
        for (var i = 0, len = locPages.length; i < len; i++) locPages[i].setContentSize(selfSize);
      },
      _initPages: function() {
        if (!this.content) return;
        var children = this.content.children;
        for (var i = 0; i < children.length; ++i) {
          var page = children[i];
          if (this._pages.indexOf(page) >= 0) continue;
          this._pages.push(page);
        }
        this._syncScrollDirection();
        this._syncSizeMode();
        this._updatePageView();
      },
      _dispatchPageTurningEvent: function() {
        if (this._lastPageIdx === this._curPageIdx) return;
        this._lastPageIdx = this._curPageIdx;
        cc.Component.EventHandler.emitEvents(this.pageEvents, this, EventType.PAGE_TURNING);
        this.node.emit("page-turning", this);
      },
      _isScrollable: function(offset, index, nextIndex) {
        if (this.sizeMode === SizeMode.Free) {
          var curPageCenter, nextPageCenter;
          if (this.direction === Direction.Horizontal) {
            curPageCenter = this._scrollCenterOffsetX[index];
            nextPageCenter = this._scrollCenterOffsetX[nextIndex];
            return Math.abs(offset.x) >= Math.abs(curPageCenter - nextPageCenter) * this.scrollThreshold;
          }
          if (this.direction === Direction.Vertical) {
            curPageCenter = this._scrollCenterOffsetY[index];
            nextPageCenter = this._scrollCenterOffsetY[nextIndex];
            return Math.abs(offset.y) >= Math.abs(curPageCenter - nextPageCenter) * this.scrollThreshold;
          }
        } else {
          if (this.direction === Direction.Horizontal) return Math.abs(offset.x) >= this.node.width * this.scrollThreshold;
          if (this.direction === Direction.Vertical) return Math.abs(offset.y) >= this.node.height * this.scrollThreshold;
        }
      },
      _isQuicklyScrollable: function(touchMoveVelocity) {
        if (this.direction === Direction.Horizontal) {
          if (Math.abs(touchMoveVelocity.x) > this.autoPageTurningThreshold) return true;
        } else if (this.direction === Direction.Vertical && Math.abs(touchMoveVelocity.y) > this.autoPageTurningThreshold) return true;
        return false;
      },
      _moveOffsetValue: function(idx) {
        var offset = cc.p(0, 0);
        this.sizeMode === SizeMode.Free ? this.direction === Direction.Horizontal ? offset.x = this._scrollCenterOffsetX[idx] : this.direction === Direction.Vertical && (offset.y = this._scrollCenterOffsetY[idx]) : this.direction === Direction.Horizontal ? offset.x = idx * this.node.width : this.direction === Direction.Vertical && (offset.y = idx * this.node.height);
        return offset;
      },
      _getDragDirection: function(moveOffset) {
        if (this.direction === Direction.Horizontal) {
          if (0 === moveOffset.x) return 0;
          return moveOffset.x > 0 ? 1 : -1;
        }
        if (this.direction === Direction.Vertical) {
          if (0 === moveOffset.y) return 0;
          return moveOffset.y < 0 ? 1 : -1;
        }
      },
      _handleReleaseLogic: function(touch) {
        var bounceBackStarted = this._startBounceBackIfNeeded();
        var moveOffset = cc.pSub(this._touchBeganPosition, this._touchEndPosition);
        if (bounceBackStarted) {
          var dragDirection = this._getDragDirection(moveOffset);
          if (0 === dragDirection) return;
          this._curPageIdx = dragDirection > 0 ? this._pages.length - 1 : 0;
          this.indicator && this.indicator._changedState();
        } else {
          var index = this._curPageIdx, nextIndex = index + this._getDragDirection(moveOffset);
          var timeInSecond = this.pageTurningSpeed * Math.abs(index - nextIndex);
          if (nextIndex < this._pages.length) {
            if (this._isScrollable(moveOffset, index, nextIndex)) {
              this.scrollToPage(nextIndex, timeInSecond);
              return;
            }
            var touchMoveVelocity = this._calculateTouchMoveVelocity();
            if (this._isQuicklyScrollable(touchMoveVelocity)) {
              this.scrollToPage(nextIndex, timeInSecond);
              return;
            }
          }
          this.scrollToPage(index, timeInSecond);
        }
      },
      _onTouchBegan: function(event, captureListeners) {
        this._touchBeganPosition = event.touch.getLocation();
        this._super(event, captureListeners);
      },
      _onTouchMoved: function(event, captureListeners) {
        this._super(event, captureListeners);
      },
      _onTouchEnded: function(event, captureListeners) {
        this._touchEndPosition = event.touch.getLocation();
        this._super(event, captureListeners);
      },
      _onTouchCancelled: function(event, captureListeners) {
        this._touchEndPosition = event.touch.getLocation();
        this._super(event, captureListeners);
      },
      _onMouseWheel: function() {}
    });
    cc.PageView = module.exports = PageView;
  }), {} ],
  84: [ (function(require, module, exports) {
    var Direction = cc.Enum({
      HORIZONTAL: 0,
      VERTICAL: 1
    });
    var PageViewIndicator = cc.Class({
      name: "cc.PageViewIndicator",
      extends: require("./CCComponent"),
      editor: false,
      properties: {
        _layout: null,
        _pageView: null,
        _indicators: [],
        spriteFrame: {
          default: null,
          type: cc.SpriteFrame,
          tooltip: (true, "i18n:COMPONENT.pageview_indicator.spriteFrame")
        },
        direction: {
          default: Direction.HORIZONTAL,
          type: Direction,
          tooltip: (true, "i18n:COMPONENT.pageview_indicator.direction")
        },
        cellSize: {
          default: cc.size(20, 20),
          tooltip: (true, "i18n:COMPONENT.pageview_indicator.cell_size")
        },
        spacing: {
          default: 0,
          tooltip: (true, "i18n:COMPONENT.pageview_indicator.spacing")
        }
      },
      statics: {
        Direction: Direction
      },
      onLoad: function() {
        this._updateLayout();
      },
      setPageView: function(target) {
        this._pageView = target;
        this._refresh();
      },
      _updateLayout: function() {
        this._layout = this.getComponent(cc.Layout);
        this._layout || (this._layout = this.addComponent(cc.Layout));
        if (this.direction === Direction.HORIZONTAL) {
          this._layout.type = cc.Layout.Type.HORIZONTAL;
          this._layout.spacingX = this.spacing;
        } else if (this.direction === Direction.VERTICAL) {
          this._layout.type = cc.Layout.Type.VERTICAL;
          this._layout.spacingY = this.spacing;
        }
        this._layout.resizeMode = cc.Layout.ResizeMode.CONTAINER;
      },
      _createIndicator: function() {
        var node = new cc.Node();
        var sprite = node.addComponent(cc.Sprite);
        sprite.spriteFrame = this.spriteFrame;
        node.parent = this.node;
        node.width = this.cellSize.width;
        node.height = this.cellSize.height;
        return node;
      },
      _changedState: function() {
        var indicators = this._indicators;
        if (0 === indicators.length) return;
        var idx = this._pageView._curPageIdx;
        if (idx >= indicators.length) return;
        for (var i = 0; i < indicators.length; ++i) {
          var node = indicators[i];
          node.opacity = 127.5;
        }
        indicators[idx].opacity = 255;
      },
      _refresh: function() {
        if (!this._pageView) return;
        var indicators = this._indicators;
        var pages = this._pageView.getPages();
        if (pages.length === indicators.length) return;
        var i = 0;
        if (pages.length > indicators.length) for (i = 0; i < pages.length; ++i) indicators[i] || (indicators[i] = this._createIndicator()); else {
          var count = indicators.length - pages.length;
          for (i = count; i > 0; --i) {
            var node = indicators[i - 1];
            this.node.removeChild(node);
            indicators.splice(i - 1, 1);
          }
        }
        this._layout && this._layout.enabledInHierarchy && this._layout.updateLayout();
        this._changedState();
      }
    });
    cc.PageViewIndicator = module.exports = PageViewIndicator;
  }), {
    "./CCComponent": 76
  } ],
  85: [ (function(require, module, exports) {
    var Mode = cc.Enum({
      HORIZONTAL: 0,
      VERTICAL: 1,
      FILLED: 2
    });
    var ProgressBar = cc.Class({
      name: "cc.ProgressBar",
      extends: require("./CCComponent"),
      editor: false,
      _initBarSprite: function() {
        if (this.barSprite) {
          var entity = this.barSprite.node;
          if (!entity) return;
          var nodeSize = this.node.getContentSize();
          var nodeAnchor = this.node.getAnchorPoint();
          var entitySize = entity.getContentSize();
          entity.parent === this.node && this.node.setContentSize(entitySize);
          this.barSprite.fillType === cc.Sprite.FillType.RADIAL && (this.mode = Mode.FILLED);
          var barSpriteSize = entity.getContentSize();
          this.mode === Mode.HORIZONTAL ? this.totalLength = barSpriteSize.width : this.mode === Mode.VERTICAL ? this.totalLength = barSpriteSize.height : this.totalLength = this.barSprite.fillRange;
          if (entity.parent === this.node) {
            var x = -nodeSize.width * nodeAnchor.x;
            var y = 0;
            entity.setPosition(cc.p(x, y));
          }
        }
      },
      _updateBarStatus: function() {
        if (this.barSprite) {
          var entity = this.barSprite.node;
          if (!entity) return;
          var entityAnchorPoint = entity.getAnchorPoint();
          var entitySize = entity.getContentSize();
          var entityPosition = entity.getPosition();
          var anchorPoint = cc.p(0, .5);
          var progress = cc.clamp01(this.progress);
          var actualLenth = this.totalLength * progress;
          var finalContentSize;
          var totalWidth;
          var totalHeight;
          switch (this.mode) {
           case Mode.HORIZONTAL:
            this.reverse && (anchorPoint = cc.p(1, .5));
            finalContentSize = cc.size(actualLenth, entitySize.height);
            totalWidth = this.totalLength;
            totalHeight = entitySize.height;
            break;

           case Mode.VERTICAL:
            anchorPoint = this.reverse ? cc.p(.5, 1) : cc.p(.5, 0);
            finalContentSize = cc.size(entitySize.width, actualLenth);
            totalWidth = entitySize.width;
            totalHeight = this.totalLength;
          }
          if (this.mode === Mode.FILLED) if (this.barSprite.type !== cc.Sprite.Type.FILLED) cc.warn("ProgressBar FILLED mode only works when barSprite's Type is FILLED!"); else {
            this.reverse && (actualLenth *= -1);
            this.barSprite.fillRange = actualLenth;
          } else if (this.barSprite.type !== cc.Sprite.Type.FILLED) {
            var anchorOffsetX = anchorPoint.x - entityAnchorPoint.x;
            var anchorOffsetY = anchorPoint.y - entityAnchorPoint.y;
            var finalPosition = cc.p(totalWidth * anchorOffsetX, totalHeight * anchorOffsetY);
            entity.setPosition(cc.pAdd(entityPosition, finalPosition));
            entity.setAnchorPoint(anchorPoint);
            entity.setContentSize(finalContentSize);
          } else cc.warn("ProgressBar non-FILLED mode only works when barSprite's Type is non-FILLED!");
        }
      },
      properties: {
        barSprite: {
          default: null,
          type: cc.Sprite,
          tooltip: (true, "i18n:COMPONENT.progress.bar_sprite"),
          notify: function() {
            this._initBarSprite();
          },
          animatable: false
        },
        mode: {
          default: Mode.HORIZONTAL,
          type: Mode,
          tooltip: (true, "i18n:COMPONENT.progress.mode"),
          notify: function() {
            if (this.barSprite) {
              var entity = this.barSprite.node;
              if (!entity) return;
              var entitySize = entity.getContentSize();
              this.mode === Mode.HORIZONTAL ? this.totalLength = entitySize.width : this.mode === Mode.VERTICAL ? this.totalLength = entitySize.height : this.mode === Mode.FILLED && (this.totalLength = this.barSprite.fillRange);
            }
          },
          animatable: false
        },
        _N$totalLength: 1,
        totalLength: {
          range: [ 0, Number.MAX_VALUE ],
          tooltip: (true, "i18n:COMPONENT.progress.total_length"),
          get: function() {
            return this._N$totalLength;
          },
          set: function(value) {
            this.mode === Mode.FILLED && (value = cc.clamp01(value));
            this._N$totalLength = value;
            this._updateBarStatus();
          }
        },
        progress: {
          default: 1,
          type: "Float",
          range: [ 0, 1, .1 ],
          slide: true,
          tooltip: (true, "i18n:COMPONENT.progress.progress"),
          notify: function() {
            this._updateBarStatus();
          }
        },
        reverse: {
          default: false,
          tooltip: (true, "i18n:COMPONENT.progress.reverse"),
          notify: function() {
            this.barSprite && (this.barSprite.fillStart = 1 - this.barSprite.fillStart);
            this._updateBarStatus();
          },
          animatable: false
        }
      },
      statics: {
        Mode: Mode
      }
    });
    cc.ProgressBar = module.exports = ProgressBar;
  }), {
    "./CCComponent": 76
  } ],
  86: [ (function(require, module, exports) {
    var RendererInSG = cc.Class({
      extends: require("./CCSGComponent"),
      name: "cc._RendererInSG",
      ctor: function() {
        var sgNode = this._sgNode = this._createSgNode();
        sgNode.setVisible(false);
        false;
        false;
        this._plainNode = new _ccsg.Node();
        false;
      },
      __preload: function() {
        this._initSgNode();
        var sgSize;
        false;
      },
      onEnable: function() {
        false;
        this._replaceSgNode(this._sgNode);
      },
      onDisable: function() {
        this._replaceSgNode(this._plainNode);
      },
      onDestroy: function() {
        this._removeSgNode();
        var releasedByNode;
        false;
      },
      _replaceSgNode: function(sgNode) {
        false;
        var node = this.node;
        var replaced = node._sgNode;
        replaced._entity = null;
        false;
        var children = replaced.getChildren().slice();
        replaced.removeAllChildren(false);
        if (sgNode.getChildrenCount() > 0) {
          false;
          sgNode.removeAllChildren(false);
        }
        for (var i = 0, len = children.length; i < len; ++i) sgNode.addChild(children[i]);
        var parentNode = replaced.getParent();
        if (parentNode) {
          true;
          parentNode.removeChild(replaced, false);
          parentNode.addChild(sgNode);
          sgNode._arrivalOrder = replaced._arrivalOrder;
          cc.renderer.childrenOrderDirty = parentNode._reorderChildDirty = true;
        }
        node._sgNode = sgNode;
        node._sgNode._entity = node;
        node._updateSgNode();
      }
    });
    cc._RendererInSG = module.exports = RendererInSG;
  }), {
    "./CCSGComponent": 89
  } ],
  87: [ (function(require, module, exports) {
    var RendererUnderSG = cc.Class({
      extends: require("./CCSGComponent"),
      name: "cc._RendererUnderSG",
      ctor: function() {
        var sgNode = this._sgNode = this._createSgNode();
        if (sgNode) {
          false;
          sgNode.setVisible(false);
        }
      },
      __preload: function() {
        this._initSgNode();
        this._registSizeProvider();
        this._appendSgNode(this._sgNode);
      },
      onEnable: function() {
        this._sgNode && this._sgNode.setVisible(true);
      },
      onDisable: function() {
        this._sgNode && this._sgNode.setVisible(false);
      },
      onDestroy: function() {
        this.node._sizeProvider === this._sgNode && (this.node._sizeProvider = null);
        this._removeSgNode();
      },
      _appendSgNode: function(sgNode) {
        if (!sgNode) return;
        var node = this.node;
        sgNode.setColor(node._color);
        node._cascadeOpacityEnabled || sgNode.setOpacity(node._opacity);
        sgNode.setAnchorPoint(node._anchorPoint);
        sgNode.setOpacityModifyRGB(node._opacityModifyRGB);
        sgNode.setLocalZOrder(-1);
        var sgParent = node._sgNode;
        sgParent.addChild(sgNode);
      }
    });
    cc._RendererUnderSG = module.exports = RendererUnderSG;
  }), {
    "./CCSGComponent": 89
  } ],
  88: [ (function(require, module, exports) {
    require("../label/CCHtmlTextParser");
    require("../label/CCTextUtils");
    var HorizontalAlign = cc.TextAlignment;
    var VerticalAlign = cc.VerticalTextAlignment;
    function debounce(func, wait, immediate) {
      var timeout;
      return function() {
        var context = this;
        var later = function() {
          timeout = null;
          immediate || func.apply(context, arguments);
        };
        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        callNow && func.apply(context, arguments);
      };
    }
    var RichText = cc.Class({
      name: "cc.RichText",
      extends: cc._RendererUnderSG,
      ctor: function() {
        this._textArray = null;
        this._labelSegments = [];
        this._labelSegmentsCache = [];
        this._linesWidth = [];
        this._resetState();
        false;
        this._updateRichTextStatus = this._updateRichText;
      },
      editor: false,
      properties: {
        string: {
          default: "<color=#00ff00>Rich</c><color=#0fffff>Text</color>",
          multiline: true,
          tooltip: (true, "i18n:COMPONENT.richtext.string"),
          notify: function() {
            this._updateRichTextStatus();
          }
        },
        horizontalAlign: {
          default: HorizontalAlign.LEFT,
          type: HorizontalAlign,
          tooltip: (true, "i18n:COMPONENT.richtext.horizontal_align"),
          animatable: false,
          notify: function(oldValue) {
            if (this.horizontalAlign === oldValue) return;
            this._layoutDirty = true;
            this._updateRichTextStatus();
          }
        },
        fontSize: {
          default: 40,
          tooltip: (true, "i18n:COMPONENT.richtext.font_size"),
          notify: function(oldValue) {
            if (this.fontSize === oldValue) return;
            this._layoutDirty = true;
            this._updateRichTextStatus();
          }
        },
        font: {
          default: null,
          type: cc.TTFFont,
          tooltip: (true, "i18n:COMPONENT.richtext.font"),
          notify: function(oldValue) {
            if (this.font === oldValue) return;
            this._layoutDirty = true;
            (true, this.font) && this._onTTFLoaded();
            this._updateRichTextStatus();
          }
        },
        maxWidth: {
          default: 0,
          tooltip: (true, "i18n:COMPONENT.richtext.max_width"),
          notify: function(oldValue) {
            if (this.maxWidth === oldValue) return;
            this._layoutDirty = true;
            this._updateRichTextStatus();
          }
        },
        lineHeight: {
          default: 40,
          tooltip: (true, "i18n:COMPONENT.richtext.line_height"),
          notify: function(oldValue) {
            if (this.lineHeight === oldValue) return;
            this._layoutDirty = true;
            this._updateRichTextStatus();
          }
        },
        imageAtlas: {
          default: null,
          type: cc.SpriteAtlas,
          tooltip: (true, "i18n:COMPONENT.richtext.image_atlas"),
          notify: function(oldValue) {
            if (this.imageAtlas === oldValue) return;
            this._layoutDirty = true;
            this._updateRichTextStatus();
          }
        },
        handleTouchEvent: {
          default: true,
          tooltip: (true, "i18n:COMPONENT.richtext.handleTouchEvent"),
          notify: function(oldValue) {
            if (this.handleTouchEvent === oldValue) return;
            this.enabledInHierarchy && (this.handleTouchEvent ? this._addEventListeners() : this._removeEventListeners());
          }
        }
      },
      statics: {
        HorizontalAlign: HorizontalAlign,
        VerticalAlign: VerticalAlign
      },
      onEnable: function() {
        this._super();
        this.handleTouchEvent && this._addEventListeners();
      },
      onDisable: function() {
        this._super();
        this.handleTouchEvent && this._removeEventListeners();
      },
      _addEventListeners: function() {
        this.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
      },
      _removeEventListeners: function() {
        this.node.off(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
      },
      _createSgNode: function() {
        var sgNode = new _ccsg.Node();
        sgNode.setCascadeOpacityEnabled(true);
        var self = this;
        sgNode.setColor = function() {
          self._updateLabelSegmentTextAttributes();
        };
        sgNode._setContentSize = sgNode.setContentSize;
        sgNode.setContentSize = function() {};
        return sgNode;
      },
      _updateLabelSegmentTextAttributes: function() {
        this._labelSegments.forEach(function(item) {
          this._applyTextAttribute(item);
        }.bind(this));
      },
      _initSgNode: function() {
        this._updateRichText();
        true;
        this._onTTFLoaded();
      },
      _createFontLabel: function(string) {
        return _ccsg.Label.pool.get(string, this.font, null, this.fontSize);
      },
      _getFontRawUrl: function() {
        var isAsset = this.font instanceof cc.TTFFont;
        var fntRawUrl = isAsset ? this.font.rawUrl : "";
        return fntRawUrl;
      },
      _onTTFLoaded: function() {
        var rawUrl = this._getFontRawUrl();
        if (!rawUrl) return;
        var self = this;
        var callback = function() {
          self._layoutDirty = true;
          self._updateRichText();
        };
        cc.CustomFontLoader.loadTTF(rawUrl, callback);
      },
      _measureText: function(styleIndex, string) {
        var self = this;
        var func = function(string) {
          var label;
          if (0 === self._labelSegmentsCache.length) {
            label = self._createFontLabel(string);
            self._labelSegmentsCache.push(label);
          } else {
            label = self._labelSegmentsCache[0];
            label.setString(string);
          }
          label._styleIndex = styleIndex;
          self._applyTextAttribute(label);
          var labelSize = label.getContentSize();
          return labelSize.width;
        };
        return string ? func(string) : func;
      },
      _onTouchEnded: function(event) {
        var components = this.node.getComponents(cc.Component);
        for (var i = 0; i < this._labelSegments.length; ++i) {
          var labelSegment = this._labelSegments[i];
          var clickHandler = labelSegment._clickHandler;
          if (clickHandler && this._containsTouchLocation(labelSegment, event.touch.getLocation())) {
            components.forEach((function(component) {
              component.enabledInHierarchy && component[clickHandler] && component[clickHandler](event);
            }));
            event.stopPropagation();
          }
        }
      },
      _containsTouchLocation: function(label, point) {
        var myRect = label.getBoundingBoxToWorld();
        return cc.rectContainsPoint(myRect, point);
      },
      _resetState: function() {
        var sgNode = this._sgNode;
        sgNode && sgNode.removeAllChildren();
        this._labelSegments.length = 0;
        this._labelSegmentsCache.length = 0;
        this._linesWidth.length = 0;
        this._lineOffsetX = 0;
        this._lineCount = 1;
        this._labelWidth = 0;
        this._labelHeight = 0;
        this._layoutDirty = true;
      },
      _addLabelSegment: function(stringToken, styleIndex) {
        var labelSegment;
        if (0 === this._labelSegmentsCache.length) labelSegment = this._createFontLabel(stringToken); else {
          labelSegment = this._labelSegmentsCache.pop();
          labelSegment.setString(stringToken);
        }
        labelSegment._styleIndex = styleIndex;
        labelSegment._lineCount = this._lineCount;
        this._applyTextAttribute(labelSegment);
        labelSegment.setAnchorPoint(0, 0);
        this._sgNode.addChild(labelSegment);
        this._labelSegments.push(labelSegment);
        var size;
        false;
        return labelSegment;
      },
      _updateRichTextWithMaxWidth: function(labelString, labelWidth, styleIndex) {
        var fragmentWidth = labelWidth;
        var labelSegment;
        if (this._lineOffsetX > 0 && fragmentWidth + this._lineOffsetX > this.maxWidth) {
          var checkStartIndex = 0;
          while (this._lineOffsetX <= this.maxWidth) {
            var checkEndIndex = this._getFirstWordLen(labelString, checkStartIndex, labelString.length);
            var checkString = labelString.substr(checkStartIndex, checkEndIndex);
            var checkStringWidth = this._measureText(styleIndex, checkString);
            if (!(this._lineOffsetX + checkStringWidth <= this.maxWidth)) {
              if (checkStartIndex > 0) {
                var remainingString = labelString.substr(0, checkStartIndex);
                this._addLabelSegment(remainingString, styleIndex);
                labelString = labelString.substr(checkStartIndex, labelString.length);
                fragmentWidth = this._measureText(styleIndex, labelString);
              }
              this._updateLineInfo();
              break;
            }
            this._lineOffsetX += checkStringWidth;
            checkStartIndex += checkEndIndex;
          }
        }
        if (fragmentWidth > this.maxWidth) {
          var fragments = cc.TextUtils.fragmentText(labelString, fragmentWidth, this.maxWidth, this._measureText(styleIndex));
          for (var k = 0; k < fragments.length; ++k) {
            var splitString = fragments[k];
            labelSegment = this._addLabelSegment(splitString, styleIndex);
            var labelSize = labelSegment.getContentSize();
            this._lineOffsetX += labelSize.width;
            fragments.length > 1 && k < fragments.length - 1 && this._updateLineInfo();
          }
        } else {
          this._lineOffsetX += fragmentWidth;
          this._addLabelSegment(labelString, styleIndex);
        }
      },
      _isLastComponentCR: function(stringToken) {
        return stringToken.length - 1 === stringToken.lastIndexOf("\n");
      },
      _updateLineInfo: function() {
        this._linesWidth.push(this._lineOffsetX);
        this._lineOffsetX = 0;
        this._lineCount++;
      },
      _needsUpdateTextLayout: function(newTextArray) {
        if (this._layoutDirty || !this._textArray || !newTextArray) return t